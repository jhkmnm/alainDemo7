/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ApiServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 创建产品
    * @param price (optional)
    * @return Success
    */
   productPost(productName: string, price: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/Product?';
      if (productName === undefined || productName === null) throw new Error("The parameter 'productName' must be defined and cannot be null.");
      else url_ += 'productName=' + encodeURIComponent('' + productName) + '&';
      if (price === null) throw new Error("The parameter 'price' cannot be null.");
      else if (price !== undefined) url_ += 'price=' + encodeURIComponent('' + price) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processProductPost(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processProductPost(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processProductPost(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 实时消息测试
    * @param message (optional)
    * @return Success
    */
   productGet(message: string | null | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/Product?';
      if (message !== undefined && message !== null) url_ += 'message=' + encodeURIComponent('' + message) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processProductGet(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processProductGet(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processProductGet(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class AccountServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Account/ActivateEmail';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processActivateEmail(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processActivateEmail(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processActivateEmail(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @return Success
    */
   backToImpersonator(): Observable<ImpersonateOutput> {
      let url_ = this.baseUrl + '/api/services/app/Account/BackToImpersonator';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processBackToImpersonator(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processBackToImpersonator(<any>response_);
                  } catch (e) {
                     return <Observable<ImpersonateOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<ImpersonateOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = ImpersonateOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<ImpersonateOutput>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
      let url_ = this.baseUrl + '/api/services/app/Account/Impersonate';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processImpersonate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processImpersonate(<any>response_);
                  } catch (e) {
                     return <Observable<ImpersonateOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<ImpersonateOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = ImpersonateOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<ImpersonateOutput>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
      let url_ = this.baseUrl + '/api/services/app/Account/IsTenantAvailable';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processIsTenantAvailable(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processIsTenantAvailable(<any>response_);
                  } catch (e) {
                     return <Observable<IsTenantAvailableOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<IsTenantAvailableOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = IsTenantAvailableOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<IsTenantAvailableOutput>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   register(body: RegisterInput | undefined): Observable<RegisterOutput> {
      let url_ = this.baseUrl + '/api/services/app/Account/Register';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processRegister(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processRegister(<any>response_);
                  } catch (e) {
                     return <Observable<RegisterOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<RegisterOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = RegisterOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<RegisterOutput>(<any>null);
   }

   /**
    * 重置密码
    * @param body (optional) 请求参数
    * @return Success
    */
   resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
      let url_ = this.baseUrl + '/api/services/app/Account/ResetPassword';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processResetPassword(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processResetPassword(<any>response_);
                  } catch (e) {
                     return <Observable<ResetPasswordOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<ResetPasswordOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = ResetPasswordOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<ResetPasswordOutput>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
      let url_ = this.baseUrl + '/api/services/app/Account/ResolveTenantId';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processResolveTenantId(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processResolveTenantId(<any>response_);
                  } catch (e) {
                     return <Observable<number>>(<any>_observableThrow(e));
                  }
               } else return <Observable<number>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<number>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Account/SendEmailActivationLink';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processSendEmailActivationLink(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processSendEmailActivationLink(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Account/SendPasswordResetCode';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processSendPasswordResetCode(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processSendPasswordResetCode(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
      let url_ = this.baseUrl + '/api/services/app/Account/SwitchToLinkedAccount';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processSwitchToLinkedAccount(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processSwitchToLinkedAccount(<any>response_);
                  } catch (e) {
                     return <Observable<SwitchToLinkedAccountOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<SwitchToLinkedAccountOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
   }
}

@Injectable()
export class AuditLogServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param startDate (optional) 开始时间
    * @param endDate (optional) 结束时间
    * @param userName (optional) 用户名
    * @param serviceName (optional) 服务名称
    * @param methodName (optional) 方法名称
    * @param browserInfo (optional) 浏览器信息
    * @param hasException (optional) 是否包含异常
    * @param minExecutionDuration (optional) 最小执行时长
    * @param maxExecutionDuration (optional) 最大执行时长
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getAuditLogsToExcel(
      startDate: Date | null | undefined,
      endDate: Date | null | undefined,
      userName: string | null | undefined,
      serviceName: string | null | undefined,
      methodName: string | null | undefined,
      browserInfo: string | null | undefined,
      hasException: boolean | null | undefined,
      minExecutionDuration: number | null | undefined,
      maxExecutionDuration: number | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<FileDto> {
      let url_ = this.baseUrl + '/api/services/app/AuditLog/GetAuditLogsToExcel?';
      if (startDate !== undefined && startDate !== null) url_ += 'startDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
      if (endDate !== undefined && endDate !== null) url_ += 'endDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
      if (userName !== undefined && userName !== null) url_ += 'userName=' + encodeURIComponent('' + userName) + '&';
      if (serviceName !== undefined && serviceName !== null) url_ += 'serviceName=' + encodeURIComponent('' + serviceName) + '&';
      if (methodName !== undefined && methodName !== null) url_ += 'methodName=' + encodeURIComponent('' + methodName) + '&';
      if (browserInfo !== undefined && browserInfo !== null) url_ += 'browserInfo=' + encodeURIComponent('' + browserInfo) + '&';
      if (hasException !== undefined && hasException !== null) url_ += 'hasException=' + encodeURIComponent('' + hasException) + '&';
      if (minExecutionDuration !== undefined && minExecutionDuration !== null)
         url_ += 'minExecutionDuration=' + encodeURIComponent('' + minExecutionDuration) + '&';
      if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
         url_ += 'maxExecutionDuration=' + encodeURIComponent('' + maxExecutionDuration) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAuditLogsToExcel(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAuditLogsToExcel(<any>response_);
                  } catch (e) {
                     return <Observable<FileDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<FileDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = FileDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<FileDto>(<any>null);
   }

   /**
    * @param startDate (optional)
    * @param endDate (optional)
    * @param userName (optional)
    * @param entityTypeFullName (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getEntityChanges(
      startDate: Date | undefined,
      endDate: Date | undefined,
      userName: string | null | undefined,
      entityTypeFullName: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<EntityChangeListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/AuditLog/GetEntityChanges?';
      if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
      else if (startDate !== undefined) url_ += 'startDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
      if (endDate === null) throw new Error("The parameter 'endDate' cannot be null.");
      else if (endDate !== undefined) url_ += 'endDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
      if (userName !== undefined && userName !== null) url_ += 'userName=' + encodeURIComponent('' + userName) + '&';
      if (entityTypeFullName !== undefined && entityTypeFullName !== null)
         url_ += 'entityTypeFullName=' + encodeURIComponent('' + entityTypeFullName) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEntityChanges(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEntityChanges(<any>response_);
                  } catch (e) {
                     return <Observable<EntityChangeListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<EntityChangeListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEntityChanges(response: HttpResponseBase): Observable<EntityChangeListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = EntityChangeListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<EntityChangeListDtoPagedResultDto>(<any>null);
   }

   /**
    * @param startDate (optional)
    * @param endDate (optional)
    * @param userName (optional)
    * @param entityTypeFullName (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getEntityChangesToExcel(
      startDate: Date | undefined,
      endDate: Date | undefined,
      userName: string | null | undefined,
      entityTypeFullName: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<FileDto> {
      let url_ = this.baseUrl + '/api/services/app/AuditLog/GetEntityChangesToExcel?';
      if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
      else if (startDate !== undefined) url_ += 'startDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
      if (endDate === null) throw new Error("The parameter 'endDate' cannot be null.");
      else if (endDate !== undefined) url_ += 'endDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
      if (userName !== undefined && userName !== null) url_ += 'userName=' + encodeURIComponent('' + userName) + '&';
      if (entityTypeFullName !== undefined && entityTypeFullName !== null)
         url_ += 'entityTypeFullName=' + encodeURIComponent('' + entityTypeFullName) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEntityChangesToExcel(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEntityChangesToExcel(<any>response_);
                  } catch (e) {
                     return <Observable<FileDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<FileDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = FileDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<FileDto>(<any>null);
   }

   /**
    * @return Success
    */
   getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
      let url_ = this.baseUrl + '/api/services/app/AuditLog/GetEntityHistoryObjectTypes';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEntityHistoryObjectTypes(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEntityHistoryObjectTypes(<any>response_);
                  } catch (e) {
                     return <Observable<NameValueDto[]>>(<any>_observableThrow(e));
                  }
               } else return <Observable<NameValueDto[]>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               if (Array.isArray(resultData200)) {
                  result200 = [] as any;
                  for (let item of resultData200) result200.push(NameValueDto.fromJS(item));
               }
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<NameValueDto[]>(<any>null);
   }

   /**
    * @param startDate (optional) 开始时间
    * @param endDate (optional) 结束时间
    * @param userName (optional) 用户名
    * @param serviceName (optional) 服务名称
    * @param methodName (optional) 方法名称
    * @param browserInfo (optional) 浏览器信息
    * @param hasException (optional) 是否包含异常
    * @param minExecutionDuration (optional) 最小执行时长
    * @param maxExecutionDuration (optional) 最大执行时长
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getPagedAuditLogs(
      startDate: Date | null | undefined,
      endDate: Date | null | undefined,
      userName: string | null | undefined,
      serviceName: string | null | undefined,
      methodName: string | null | undefined,
      browserInfo: string | null | undefined,
      hasException: boolean | null | undefined,
      minExecutionDuration: number | null | undefined,
      maxExecutionDuration: number | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<AuditLogListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/AuditLog/GetPagedAuditLogs?';
      if (startDate !== undefined && startDate !== null) url_ += 'startDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
      if (endDate !== undefined && endDate !== null) url_ += 'endDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
      if (userName !== undefined && userName !== null) url_ += 'userName=' + encodeURIComponent('' + userName) + '&';
      if (serviceName !== undefined && serviceName !== null) url_ += 'serviceName=' + encodeURIComponent('' + serviceName) + '&';
      if (methodName !== undefined && methodName !== null) url_ += 'methodName=' + encodeURIComponent('' + methodName) + '&';
      if (browserInfo !== undefined && browserInfo !== null) url_ += 'browserInfo=' + encodeURIComponent('' + browserInfo) + '&';
      if (hasException !== undefined && hasException !== null) url_ += 'hasException=' + encodeURIComponent('' + hasException) + '&';
      if (minExecutionDuration !== undefined && minExecutionDuration !== null)
         url_ += 'minExecutionDuration=' + encodeURIComponent('' + minExecutionDuration) + '&';
      if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
         url_ += 'maxExecutionDuration=' + encodeURIComponent('' + maxExecutionDuration) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetPagedAuditLogs(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetPagedAuditLogs(<any>response_);
                  } catch (e) {
                     return <Observable<AuditLogListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<AuditLogListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetPagedAuditLogs(response: HttpResponseBase): Observable<AuditLogListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = AuditLogListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<AuditLogListDtoPagedResultDto>(<any>null);
   }
}

@Injectable()
export class CommonLookupServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   findUsers(body: CommonLookupFindUsersInput | undefined): Observable<NameValueDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/CommonLookup/FindUsers';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processFindUsers(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processFindUsers(<any>response_);
                  } catch (e) {
                     return <Observable<NameValueDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<NameValueDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processFindUsers(response: HttpResponseBase): Observable<NameValueDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = NameValueDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<NameValueDtoPagedResultDto>(<any>null);
   }

   /**
    * @return Success
    */
   getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
      let url_ = this.baseUrl + '/api/services/app/CommonLookup/GetDefaultEditionName';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetDefaultEditionName(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetDefaultEditionName(<any>response_);
                  } catch (e) {
                     return <Observable<GetDefaultEditionNameOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetDefaultEditionNameOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetDefaultEditionNameOutput>(<any>null);
   }

   /**
    * @param onlyFreeItems (optional)
    * @return Success
    */
   getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/CommonLookup/GetEditionsForCombobox?';
      if (onlyFreeItems === null) throw new Error("The parameter 'onlyFreeItems' cannot be null.");
      else if (onlyFreeItems !== undefined) url_ += 'onlyFreeItems=' + encodeURIComponent('' + onlyFreeItems) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEditionsForCombobox(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEditionsForCombobox(<any>response_);
                  } catch (e) {
                     return <Observable<SubscribableEditionComboboxItemDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<SubscribableEditionComboboxItemDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = SubscribableEditionComboboxItemDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<SubscribableEditionComboboxItemDtoListResultDto>(<any>null);
   }

   /**
    * @return Success
    */
   getValidateCodeTypesForCombobox(): Observable<Int32ComboboxItemDtoTListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/CommonLookup/GetValidateCodeTypesForCombobox';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetValidateCodeTypesForCombobox(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetValidateCodeTypesForCombobox(<any>response_);
                  } catch (e) {
                     return <Observable<Int32ComboboxItemDtoTListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<Int32ComboboxItemDtoTListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetValidateCodeTypesForCombobox(response: HttpResponseBase): Observable<Int32ComboboxItemDtoTListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = Int32ComboboxItemDtoTListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<Int32ComboboxItemDtoTListResultDto>(<any>null);
   }
}

@Injectable()
export class DemoJavaScriptServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 执行表达式
    * @param body (optional)
    * @return Success
    */
   evaluate(body: JavaScriptEvaluateInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/DemoJavaScript/Evaluate';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processEvaluate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processEvaluate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processEvaluate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 执行执行函数
    * @param body (optional)
    * @return Success
    */
   invokeMethod(body: JavaScriptInvokeMethodInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/DemoJavaScript/InvokeMethod';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processInvokeMethod(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processInvokeMethod(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processInvokeMethod(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 包含全局变量执行执行函数
    * @param body (optional)
    * @return Success
    */
   invokeMethodWithGlobalFields(body: JavaScriptInvokeMethodWithGlobalFieldsInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/DemoJavaScript/InvokeMethodWithGlobalFields';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processInvokeMethodWithGlobalFields(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processInvokeMethodWithGlobalFields(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processInvokeMethodWithGlobalFields(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class DemoMongoDbServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 创建对象
    * @param body (optional)
    * @return Success
    */
   create(body: OrderTest | undefined): Observable<OrderTest> {
      let url_ = this.baseUrl + '/api/services/app/DemoMongoDb/Create';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreate(<any>response_);
                  } catch (e) {
                     return <Observable<OrderTest>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrderTest>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreate(response: HttpResponseBase): Observable<OrderTest> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = OrderTest.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrderTest>(<any>null);
   }

   /**
    * 获取单个记录
    * @param id (optional)
    * @return Success
    */
   get(id: string | null | undefined): Observable<OrderTest> {
      let url_ = this.baseUrl + '/api/services/app/DemoMongoDb/Get?';
      if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGet(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGet(<any>response_);
                  } catch (e) {
                     return <Observable<OrderTest>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrderTest>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGet(response: HttpResponseBase): Observable<OrderTest> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = OrderTest.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrderTest>(<any>null);
   }

   /**
    * @return Success
    */
   getIDSeqence(): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/DemoMongoDb/GetIDSeqence';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetIDSeqence(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetIDSeqence(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetIDSeqence(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 获取列表
    * @return Success
    */
   gets(): Observable<OrderTest[]> {
      let url_ = this.baseUrl + '/api/services/app/DemoMongoDb/Gets';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGets(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGets(<any>response_);
                  } catch (e) {
                     return <Observable<OrderTest[]>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrderTest[]>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGets(response: HttpResponseBase): Observable<OrderTest[]> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               if (Array.isArray(resultData200)) {
                  result200 = [] as any;
                  for (let item of resultData200) result200.push(OrderTest.fromJS(item));
               }
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrderTest[]>(<any>null);
   }
}

@Injectable()
export class DicServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   createOrUpdate(body: CreateOrUpdateDicInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Dic/CreateOrUpdate';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreateOrUpdate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreateOrUpdate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param dicCode (optional)
    * @return Success
    */
   get(dicCode: string | null | undefined): Observable<DicCacheItem> {
      let url_ = this.baseUrl + '/api/services/app/Dic/Get?';
      if (dicCode !== undefined && dicCode !== null) url_ += 'dicCode=' + encodeURIComponent('' + dicCode) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGet(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGet(<any>response_);
                  } catch (e) {
                     return <Observable<DicCacheItem>>(<any>_observableThrow(e));
                  }
               } else return <Observable<DicCacheItem>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGet(response: HttpResponseBase): Observable<DicCacheItem> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = DicCacheItem.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<DicCacheItem>(<any>null);
   }

   /**
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @param filterText (optional)
    * @return Success
    */
   getDicPaging(
      maxResultCount: number | undefined,
      skipCount: number | undefined,
      filterText: string | null | undefined
   ): Observable<DicOutputPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Dic/GetDicPaging?';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetDicPaging(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetDicPaging(<any>response_);
                  } catch (e) {
                     return <Observable<DicOutputPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<DicOutputPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetDicPaging(response: HttpResponseBase): Observable<DicOutputPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = DicOutputPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<DicOutputPagedResultDto>(<any>null);
   }

   /**
    * @return Success
    */
   removeDetail(dicCode: string, detailKey: string): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Dic/RemoveDetail?';
      if (dicCode === undefined || dicCode === null) throw new Error("The parameter 'dicCode' must be defined and cannot be null.");
      else url_ += 'dicCode=' + encodeURIComponent('' + dicCode) + '&';
      if (detailKey === undefined || detailKey === null) throw new Error("The parameter 'detailKey' must be defined and cannot be null.");
      else url_ += 'detailKey=' + encodeURIComponent('' + detailKey) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processRemoveDetail(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processRemoveDetail(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processRemoveDetail(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @return Success
    */
   removeDic(dicCode: string): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Dic/RemoveDic?';
      if (dicCode === undefined || dicCode === null) throw new Error("The parameter 'dicCode' must be defined and cannot be null.");
      else url_ += 'dicCode=' + encodeURIComponent('' + dicCode) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processRemoveDic(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processRemoveDic(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processRemoveDic(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class EditionServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   createOrUpdateEdition(body: CreateOrUpdateEditionDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Edition/CreateOrUpdateEdition';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreateOrUpdateEdition(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreateOrUpdateEdition(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreateOrUpdateEdition(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   deleteEdition(id: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Edition/DeleteEdition?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDeleteEdition(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDeleteEdition(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param selectedEditionId (optional)
    * @param addAllItem (optional)
    * @param onlyFreeItems (optional)
    * @return Success
    */
   getEditionComboboxItems(
      selectedEditionId: number | null | undefined,
      addAllItem: boolean | undefined,
      onlyFreeItems: boolean | undefined
   ): Observable<SubscribableEditionComboboxItemDto[]> {
      let url_ = this.baseUrl + '/api/services/app/Edition/GetEditionComboboxItems?';
      if (selectedEditionId !== undefined && selectedEditionId !== null)
         url_ += 'selectedEditionId=' + encodeURIComponent('' + selectedEditionId) + '&';
      if (addAllItem === null) throw new Error("The parameter 'addAllItem' cannot be null.");
      else if (addAllItem !== undefined) url_ += 'addAllItem=' + encodeURIComponent('' + addAllItem) + '&';
      if (onlyFreeItems === null) throw new Error("The parameter 'onlyFreeItems' cannot be null.");
      else if (onlyFreeItems !== undefined) url_ += 'onlyFreeItems=' + encodeURIComponent('' + onlyFreeItems) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEditionComboboxItems(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEditionComboboxItems(<any>response_);
                  } catch (e) {
                     return <Observable<SubscribableEditionComboboxItemDto[]>>(<any>_observableThrow(e));
                  }
               } else return <Observable<SubscribableEditionComboboxItemDto[]>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               if (Array.isArray(resultData200)) {
                  result200 = [] as any;
                  for (let item of resultData200) result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
               }
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
      let url_ = this.baseUrl + '/api/services/app/Edition/GetEditionForEdit?';
      if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEditionForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEditionForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<GetEditionEditOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetEditionEditOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetEditionEditOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetEditionEditOutput>(<any>null);
   }

   /**
    * @return Success
    */
   getEditions(): Observable<EditionListDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Edition/GetEditions';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEditions(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEditions(<any>response_);
                  } catch (e) {
                     return <Observable<EditionListDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<EditionListDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEditions(response: HttpResponseBase): Observable<EditionListDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = EditionListDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<EditionListDtoListResultDto>(<any>null);
   }

   /**
    * @param editionId (optional)
    * @return Success
    */
   getTenantCount(editionId: number | undefined): Observable<number> {
      let url_ = this.baseUrl + '/api/services/app/Edition/GetTenantCount?';
      if (editionId === null) throw new Error("The parameter 'editionId' cannot be null.");
      else if (editionId !== undefined) url_ += 'editionId=' + encodeURIComponent('' + editionId) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetTenantCount(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetTenantCount(<any>response_);
                  } catch (e) {
                     return <Observable<number>>(<any>_observableThrow(e));
                  }
               } else return <Observable<number>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<number>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Edition/MoveTenantsToAnotherEdition';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processMoveTenantsToAnotherEdition(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processMoveTenantsToAnotherEdition(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class HangfireServiceServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 加入队列
    * @param body (optional)
    * @return Success
    */
   addEnqueueJob(body: RecurringJobInput | undefined): Observable<boolean> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/AddEnqueueJob';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processAddEnqueueJob(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processAddEnqueueJob(<any>response_);
                  } catch (e) {
                     return <Observable<boolean>>(<any>_observableThrow(e));
                  }
               } else return <Observable<boolean>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processAddEnqueueJob(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<boolean>(<any>null);
   }

   /**
    * 删除普通作业
    * @param jobId (optional)
    * @return Success
    */
   deleteJob(jobId: string[] | null | undefined): Observable<boolean> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/DeleteJob?';
      if (jobId !== undefined && jobId !== null)
         jobId &&
            jobId.forEach((item) => {
               url_ += 'jobId=' + encodeURIComponent('' + item) + '&';
            });
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDeleteJob(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDeleteJob(<any>response_);
                  } catch (e) {
                     return <Observable<boolean>>(<any>_observableThrow(e));
                  }
               } else return <Observable<boolean>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDeleteJob(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<boolean>(<any>null);
   }

   /**
    * 删除周期性作业
    * @param jobId (optional)
    * @return Success
    */
   deleteRecurringJob(jobId: string[] | null | undefined): Observable<boolean> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/DeleteRecurringJob?';
      if (jobId !== undefined && jobId !== null)
         jobId &&
            jobId.forEach((item) => {
               url_ += 'jobId=' + encodeURIComponent('' + item) + '&';
            });
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDeleteRecurringJob(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDeleteRecurringJob(<any>response_);
                  } catch (e) {
                     return <Observable<boolean>>(<any>_observableThrow(e));
                  }
               } else return <Observable<boolean>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDeleteRecurringJob(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<boolean>(<any>null);
   }

   /**
    * 获取所有作业
    * @param jobState (optional)
    * @param queueName (optional)
    * @param filterText (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getAllJobs(
      jobState: JobState | undefined,
      queueName: string | null | undefined,
      filterText: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<HangFireStorageJobPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/GetAllJobs?';
      if (jobState === null) throw new Error("The parameter 'jobState' cannot be null.");
      else if (jobState !== undefined) url_ += 'jobState=' + encodeURIComponent('' + jobState) + '&';
      if (queueName !== undefined && queueName !== null) url_ += 'queueName=' + encodeURIComponent('' + queueName) + '&';
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAllJobs(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAllJobs(<any>response_);
                  } catch (e) {
                     return <Observable<HangFireStorageJobPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<HangFireStorageJobPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAllJobs(response: HttpResponseBase): Observable<HangFireStorageJobPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = HangFireStorageJobPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<HangFireStorageJobPagedResultDto>(<any>null);
   }

   /**
    * 获取所有周期性作业
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @param filterText (optional)
    * @return Success
    */
   getAllRecurringJob(
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined,
      filterText: string | null | undefined
   ): Observable<RecurringResultList> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/GetAllRecurringJob?';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAllRecurringJob(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAllRecurringJob(<any>response_);
                  } catch (e) {
                     return <Observable<RecurringResultList>>(<any>_observableThrow(e));
                  }
               } else return <Observable<RecurringResultList>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAllRecurringJob(response: HttpResponseBase): Observable<RecurringResultList> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = RecurringResultList.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<RecurringResultList>(<any>null);
   }

   /**
    * 获取Dashboard仪表盘-数据
    * @return Success
    */
   getDashboardData(searchTimeType: SearchTimeType): Observable<DashboardIndexDetailDto> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/GetDashboardData?';
      if (searchTimeType === undefined || searchTimeType === null)
         throw new Error("The parameter 'searchTimeType' must be defined and cannot be null.");
      else url_ += 'searchTimeType=' + encodeURIComponent('' + searchTimeType) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetDashboardData(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetDashboardData(<any>response_);
                  } catch (e) {
                     return <Observable<DashboardIndexDetailDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<DashboardIndexDetailDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetDashboardData(response: HttpResponseBase): Observable<DashboardIndexDetailDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = DashboardIndexDetailDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<DashboardIndexDetailDto>(<any>null);
   }

   /**
    * 获取统计数据
    * @return Success
    */
   getDashboardStatistics(): Observable<StatisticsInfoDto> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/GetDashboardStatistics';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetDashboardStatistics(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetDashboardStatistics(<any>response_);
                  } catch (e) {
                     return <Observable<StatisticsInfoDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<StatisticsInfoDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetDashboardStatistics(response: HttpResponseBase): Observable<StatisticsInfoDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = StatisticsInfoDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<StatisticsInfoDto>(<any>null);
   }

   /**
    * 查看作业详情信息
    * @param id (optional)
    * @return Success
    */
   getJobDetail(id: string | null | undefined): Observable<HangfireJobDetailDto> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/GetJobDetail?';
      if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetJobDetail(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetJobDetail(<any>response_);
                  } catch (e) {
                     return <Observable<HangfireJobDetailDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<HangfireJobDetailDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetJobDetail(response: HttpResponseBase): Observable<HangfireJobDetailDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = HangfireJobDetailDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<HangfireJobDetailDto>(<any>null);
   }

   /**
    * 获取重试的作业数据
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @param filterText (optional)
    * @return Success
    */
   getRetriesJob(
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined,
      filterText: string | null | undefined
   ): Observable<RetriesResultList> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/GetRetriesJob?';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetRetriesJob(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetRetriesJob(<any>response_);
                  } catch (e) {
                     return <Observable<RetriesResultList>>(<any>_observableThrow(e));
                  }
               } else return <Observable<RetriesResultList>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetRetriesJob(response: HttpResponseBase): Observable<RetriesResultList> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = RetriesResultList.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<RetriesResultList>(<any>null);
   }

   /**
    * 获取所有服务
    * @return Success
    */
   getServer(): Observable<ServerResultList> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/GetServer';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetServer(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetServer(<any>response_);
                  } catch (e) {
                     return <Observable<ServerResultList>>(<any>_observableThrow(e));
                  }
               } else return <Observable<ServerResultList>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetServer(response: HttpResponseBase): Observable<ServerResultList> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = ServerResultList.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<ServerResultList>(<any>null);
   }

   /**
    * 重新加入队列
    * @param body (optional)
    * @return Success
    */
   requeue(body: RecurringJobInput | undefined): Observable<boolean> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/Requeue';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processRequeue(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processRequeue(<any>response_);
                  } catch (e) {
                     return <Observable<boolean>>(<any>_observableThrow(e));
                  }
               } else return <Observable<boolean>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processRequeue(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<boolean>(<any>null);
   }

   /**
    * 执行作业
    * @param body (optional)
    * @return Success
    */
   runRecurringJob(body: RecurringJobInput | undefined): Observable<boolean> {
      let url_ = this.baseUrl + '/api/services/app/HangfireService/RunRecurringJob';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processRunRecurringJob(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processRunRecurringJob(<any>response_);
                  } catch (e) {
                     return <Observable<boolean>>(<any>_observableThrow(e));
                  }
               } else return <Observable<boolean>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processRunRecurringJob(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<boolean>(<any>null);
   }
}

@Injectable()
export class HostCachingServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @return Success
    */
   clearAllCaches(): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/HostCaching/ClearAllCaches';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processClearAllCaches(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processClearAllCaches(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   clearCache(body: StringEntityDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/HostCaching/ClearCache';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processClearCache(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processClearCache(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processClearCache(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @return Success
    */
   getAllCaches(): Observable<HostCacheDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/HostCaching/GetAllCaches';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAllCaches(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAllCaches(<any>response_);
                  } catch (e) {
                     return <Observable<HostCacheDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<HostCacheDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAllCaches(response: HttpResponseBase): Observable<HostCacheDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = HostCacheDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<HostCacheDtoListResultDto>(<any>null);
   }
}

@Injectable()
export class HostSettingsServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @return Success
    */
   getAllSettings(): Observable<HostSettingsEditDto> {
      let url_ = this.baseUrl + '/api/services/app/HostSettings/GetAllSettings';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAllSettings(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAllSettings(<any>response_);
                  } catch (e) {
                     return <Observable<HostSettingsEditDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<HostSettingsEditDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = HostSettingsEditDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<HostSettingsEditDto>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/HostSettings/SendTestEmail';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processSendTestEmail(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processSendTestEmail(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/HostSettings/UpdateAllSettings';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdateAllSettings(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdateAllSettings(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class InvalidUserExporterServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   exportToFile(body: ImportUserDto[] | null | undefined): Observable<FileDto> {
      let url_ = this.baseUrl + '/api/services/app/InvalidUserExporter/ExportToFile';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processExportToFile(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processExportToFile(<any>response_);
                  } catch (e) {
                     return <Observable<FileDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<FileDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processExportToFile(response: HttpResponseBase): Observable<FileDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = FileDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<FileDto>(<any>null);
   }
}

@Injectable()
export class LanguageServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 批量删除
    * @param body (optional)
    * @return Success
    */
   batchDelete(body: number[] | null | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Language/BatchDelete';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processBatchDelete(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processBatchDelete(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processBatchDelete(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Language/CreateOrUpdateLanguage';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreateOrUpdateLanguage(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreateOrUpdateLanguage(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   deleteLanguage(id: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Language/DeleteLanguage?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDeleteLanguage(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDeleteLanguage(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
      let url_ = this.baseUrl + '/api/services/app/Language/GetLanguageForEdit?';
      if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetLanguageForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetLanguageForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<GetLanguageForEditOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetLanguageForEditOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetLanguageForEditOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetLanguageForEditOutput>(<any>null);
   }

   /**
    * @return Success
    */
   getLanguages(): Observable<GetLanguagesOutput> {
      let url_ = this.baseUrl + '/api/services/app/Language/GetLanguages';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetLanguages(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetLanguages(<any>response_);
                  } catch (e) {
                     return <Observable<GetLanguagesOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetLanguagesOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetLanguagesOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetLanguagesOutput>(<any>null);
   }

   /**
    * @param sourceName 语言名称
    * @param baseLanguageName (optional) 原语言名称
    * @param targetLanguageName 目标语言名称
    * @param targetValueFilter (optional) 目标值过滤
    * @param filterText (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getLanguageTexts(
      sourceName: string,
      baseLanguageName: string | null | undefined,
      targetLanguageName: string,
      targetValueFilter: string | null | undefined,
      filterText: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<LanguageTextListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Language/GetLanguageTexts?';
      if (sourceName === undefined || sourceName === null) throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
      else url_ += 'sourceName=' + encodeURIComponent('' + sourceName) + '&';
      if (baseLanguageName !== undefined && baseLanguageName !== null) url_ += 'baseLanguageName=' + encodeURIComponent('' + baseLanguageName) + '&';
      if (targetLanguageName === undefined || targetLanguageName === null)
         throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
      else url_ += 'targetLanguageName=' + encodeURIComponent('' + targetLanguageName) + '&';
      if (targetValueFilter !== undefined && targetValueFilter !== null)
         url_ += 'targetValueFilter=' + encodeURIComponent('' + targetValueFilter) + '&';
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetLanguageTexts(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetLanguageTexts(<any>response_);
                  } catch (e) {
                     return <Observable<LanguageTextListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<LanguageTextListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetLanguageTexts(response: HttpResponseBase): Observable<LanguageTextListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = LanguageTextListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<LanguageTextListDtoPagedResultDto>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Language/SetDefaultLanguage';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processSetDefaultLanguage(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processSetDefaultLanguage(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 修改语言的文本内容
    * @param body (optional)
    * @return Success
    */
   updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Language/UpdateLanguageText';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdateLanguageText(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdateLanguageText(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class NotificationServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 删除通知
    * @param id (optional)
    * @return Success
    */
   deleteNotification(id: string | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Notification/DeleteNotification?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDeleteNotification(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDeleteNotification(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @return Success
    */
   getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
      let url_ = this.baseUrl + '/api/services/app/Notification/GetNotificationSettings';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetNotificationSettings(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetNotificationSettings(<any>response_);
                  } catch (e) {
                     return <Observable<GetNotificationSettingsOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetNotificationSettingsOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetNotificationSettingsOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetNotificationSettingsOutput>(<any>null);
   }

   /**
    * @param state (optional) 是否阅读枚举 0是未读 1是已经阅读
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getPagedUserNotifications(
      state: UserNotificationState | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<GetNotificationsOutput> {
      let url_ = this.baseUrl + '/api/services/app/Notification/GetPagedUserNotifications?';
      if (state === null) throw new Error("The parameter 'state' cannot be null.");
      else if (state !== undefined) url_ += 'state=' + encodeURIComponent('' + state) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetPagedUserNotifications(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetPagedUserNotifications(<any>response_);
                  } catch (e) {
                     return <Observable<GetNotificationsOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetNotificationsOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetPagedUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetNotificationsOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetNotificationsOutput>(<any>null);
   }

   /**
    * @return Success
    */
   makeAllUserNotificationsAsRead(): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Notification/MakeAllUserNotificationsAsRead';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processMakeAllUserNotificationsAsRead(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processMakeAllUserNotificationsAsRead(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processMakeAllUserNotificationsAsRead(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   makeNotificationAsRead(body: GuidEntityDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Notification/MakeNotificationAsRead';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processMakeNotificationAsRead(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processMakeNotificationAsRead(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processMakeNotificationAsRead(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param msg (optional)
    * @param tenantId (optional)
    * @param userId (optional)
    * @return Success
    */
   sendNoticeToUser(msg: string | null | undefined, tenantId: number | null | undefined, userId: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Notification/SendNoticeToUser?';
      if (msg !== undefined && msg !== null) url_ += 'msg=' + encodeURIComponent('' + msg) + '&';
      if (tenantId !== undefined && tenantId !== null) url_ += 'tenantId=' + encodeURIComponent('' + tenantId) + '&';
      if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
      else if (userId !== undefined) url_ += 'userId=' + encodeURIComponent('' + userId) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processSendNoticeToUser(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processSendNoticeToUser(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processSendNoticeToUser(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 更新消息设置
    * @param body (optional)
    * @return Success
    */
   updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Notification/UpdateNotificationSettings';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdateNotificationSettings(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdateNotificationSettings(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class OrderServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 创建订单
    * @param body (optional) 创建订单
    * @return Success
    */
   create(body: CreateOrderInput | undefined): Observable<string> {
      let url_ = this.baseUrl + '/api/services/app/Order/Create';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreate(<any>response_);
                  } catch (e) {
                     return <Observable<string>>(<any>_observableThrow(e));
                  }
               } else return <Observable<string>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreate(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<string>(<any>null);
   }

   /**
    * 获取
    * @return Success
    */
   get(): Observable<WeatherForecast[]> {
      let url_ = this.baseUrl + '/api/services/app/Order/Get';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGet(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGet(<any>response_);
                  } catch (e) {
                     return <Observable<WeatherForecast[]>>(<any>_observableThrow(e));
                  }
               } else return <Observable<WeatherForecast[]>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               if (Array.isArray(resultData200)) {
                  result200 = [] as any;
                  for (let item of resultData200) result200.push(WeatherForecast.fromJS(item));
               }
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<WeatherForecast[]>(<any>null);
   }

   /**
    * 获取订单变化历史属性变化详情
    * @param entityChangeId (optional)
    * @param excludeAuditProperties (optional)
    * @return Success
    */
   getEntityPropertyChanges(entityChangeId: number | undefined, excludeAuditProperties: boolean | undefined): Observable<EntityPropertyChangeDto[]> {
      let url_ = this.baseUrl + '/api/services/app/Order/GetEntityPropertyChanges?';
      if (entityChangeId === null) throw new Error("The parameter 'entityChangeId' cannot be null.");
      else if (entityChangeId !== undefined) url_ += 'entityChangeId=' + encodeURIComponent('' + entityChangeId) + '&';
      if (excludeAuditProperties === null) throw new Error("The parameter 'excludeAuditProperties' cannot be null.");
      else if (excludeAuditProperties !== undefined) url_ += 'excludeAuditProperties=' + encodeURIComponent('' + excludeAuditProperties) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEntityPropertyChanges(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEntityPropertyChanges(<any>response_);
                  } catch (e) {
                     return <Observable<EntityPropertyChangeDto[]>>(<any>_observableThrow(e));
                  }
               } else return <Observable<EntityPropertyChangeDto[]>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               if (Array.isArray(resultData200)) {
                  result200 = [] as any;
                  for (let item of resultData200) result200.push(EntityPropertyChangeDto.fromJS(item));
               }
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<EntityPropertyChangeDto[]>(<any>null);
   }

   /**
    * 获取订单变化历史记录详情
    * @param entityTypeFullName (optional)
    * @param entityId (optional)
    * @param propertyName (optional)
    * @param excludeAuditProperties (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getEntityTypeChangeDetails(
      entityTypeFullName: string | null | undefined,
      entityId: string | null | undefined,
      propertyName: string | null | undefined,
      excludeAuditProperties: boolean | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<EntityPropertyChangeDetailDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Order/GetEntityTypeChangeDetails?';
      if (entityTypeFullName !== undefined && entityTypeFullName !== null)
         url_ += 'entityTypeFullName=' + encodeURIComponent('' + entityTypeFullName) + '&';
      if (entityId !== undefined && entityId !== null) url_ += 'entityId=' + encodeURIComponent('' + entityId) + '&';
      if (propertyName !== undefined && propertyName !== null) url_ += 'propertyName=' + encodeURIComponent('' + propertyName) + '&';
      if (excludeAuditProperties === null) throw new Error("The parameter 'excludeAuditProperties' cannot be null.");
      else if (excludeAuditProperties !== undefined) url_ += 'excludeAuditProperties=' + encodeURIComponent('' + excludeAuditProperties) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEntityTypeChangeDetails(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEntityTypeChangeDetails(<any>response_);
                  } catch (e) {
                     return <Observable<EntityPropertyChangeDetailDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<EntityPropertyChangeDetailDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEntityTypeChangeDetails(response: HttpResponseBase): Observable<EntityPropertyChangeDetailDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = EntityPropertyChangeDetailDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<EntityPropertyChangeDetailDtoPagedResultDto>(<any>null);
   }

   /**
    * 获取订单变化历史记录
    * @param entityTypeFullName (optional)
    * @param entityId (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getEntityTypeChanges(
      entityTypeFullName: string | null | undefined,
      entityId: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<EntityChangeListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Order/GetEntityTypeChanges?';
      if (entityTypeFullName !== undefined && entityTypeFullName !== null)
         url_ += 'entityTypeFullName=' + encodeURIComponent('' + entityTypeFullName) + '&';
      if (entityId !== undefined && entityId !== null) url_ += 'entityId=' + encodeURIComponent('' + entityId) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetEntityTypeChanges(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetEntityTypeChanges(<any>response_);
                  } catch (e) {
                     return <Observable<EntityChangeListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<EntityChangeListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<EntityChangeListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = EntityChangeListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<EntityChangeListDtoPagedResultDto>(<any>null);
   }

   /**
    * 修改订单
    * @param body (optional) 修改订单
    * @return Success
    */
   update(body: UpdateOrderInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Order/Update';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class OrganizationUnitServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   addUsers(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/AddUsers';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processAddUsers(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processAddUsers(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processAddUsers(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 批量从组织中移除用户
    * @param organizationUnitId (optional) 组织机构Id
    * @param body (optional) 用户Id列表
    * @return Success
    */
   batchRemoveUserFromOrganizationUnit(organizationUnitId: number | undefined, body: number[] | null | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/BatchRemoveUserFromOrganizationUnit?';
      if (organizationUnitId === null) throw new Error("The parameter 'organizationUnitId' cannot be null.");
      else if (organizationUnitId !== undefined) url_ += 'organizationUnitId=' + encodeURIComponent('' + organizationUnitId) + '&';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processBatchRemoveUserFromOrganizationUnit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processBatchRemoveUserFromOrganizationUnit(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processBatchRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   create(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitListDto> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/Create';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreate(<any>response_);
                  } catch (e) {
                     return <Observable<OrganizationUnitListDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrganizationUnitListDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreate(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = OrganizationUnitListDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrganizationUnitListDto>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   delete(id: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/Delete?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDelete(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDelete(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDelete(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   findUsers(body: FindUsersInput | undefined): Observable<NameValueDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/FindUsers';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processFindUsers(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processFindUsers(<any>response_);
                  } catch (e) {
                     return <Observable<NameValueDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<NameValueDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processFindUsers(response: HttpResponseBase): Observable<NameValueDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = NameValueDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<NameValueDtoPagedResultDto>(<any>null);
   }

   /**
    * @return Success
    */
   getAllOrganizationUnitList(): Observable<OrganizationUnitListDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/GetAllOrganizationUnitList';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAllOrganizationUnitList(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAllOrganizationUnitList(<any>response_);
                  } catch (e) {
                     return <Observable<OrganizationUnitListDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrganizationUnitListDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAllOrganizationUnitList(response: HttpResponseBase): Observable<OrganizationUnitListDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = OrganizationUnitListDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrganizationUnitListDtoListResultDto>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   getForEdit(id: number | undefined): Observable<OrganizationUnitListDto> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/GetForEdit?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<OrganizationUnitListDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrganizationUnitListDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetForEdit(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = OrganizationUnitListDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrganizationUnitListDto>(<any>null);
   }

   /**
    * @param id (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getPagedOrganizationUnitRoles(
      id: number | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<OrganizationUnitRoleListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/GetPagedOrganizationUnitRoles?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetPagedOrganizationUnitRoles(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetPagedOrganizationUnitRoles(<any>response_);
                  } catch (e) {
                     return <Observable<OrganizationUnitRoleListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrganizationUnitRoleListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetPagedOrganizationUnitRoles(response: HttpResponseBase): Observable<OrganizationUnitRoleListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = OrganizationUnitRoleListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrganizationUnitRoleListDtoPagedResultDto>(<any>null);
   }

   /**
    * @param id (optional)
    * @param filterText (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getPagedOrganizationUnitUsers(
      id: number | undefined,
      filterText: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<OrganizationUnitUserListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/GetPagedOrganizationUnitUsers?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetPagedOrganizationUnitUsers(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetPagedOrganizationUnitUsers(<any>response_);
                  } catch (e) {
                     return <Observable<OrganizationUnitUserListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrganizationUnitUserListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetPagedOrganizationUnitUsers(response: HttpResponseBase): Observable<OrganizationUnitUserListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = OrganizationUnitUserListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrganizationUnitUserListDtoPagedResultDto>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   isInOrganizationUnit(body: UserToOrganizationUnitInput | undefined): Observable<boolean> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/IsInOrganizationUnit';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processIsInOrganizationUnit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processIsInOrganizationUnit(<any>response_);
                  } catch (e) {
                     return <Observable<boolean>>(<any>_observableThrow(e));
                  }
               } else return <Observable<boolean>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processIsInOrganizationUnit(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<boolean>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   move(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitListDto> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/Move';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processMove(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processMove(<any>response_);
                  } catch (e) {
                     return <Observable<OrganizationUnitListDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrganizationUnitListDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processMove(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = OrganizationUnitListDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrganizationUnitListDto>(<any>null);
   }

   /**
    * @param userId (optional)
    * @param organizationUnitId (optional)
    * @return Success
    */
   removeUser(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/RemoveUser?';
      if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
      else if (userId !== undefined) url_ += 'userId=' + encodeURIComponent('' + userId) + '&';
      if (organizationUnitId === null) throw new Error("The parameter 'organizationUnitId' cannot be null.");
      else if (organizationUnitId !== undefined) url_ += 'organizationUnitId=' + encodeURIComponent('' + organizationUnitId) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processRemoveUser(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processRemoveUser(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processRemoveUser(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   update(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitListDto> {
      let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/Update';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdate(<any>response_);
                  } catch (e) {
                     return <Observable<OrganizationUnitListDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<OrganizationUnitListDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdate(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = OrganizationUnitListDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<OrganizationUnitListDto>(<any>null);
   }
}

@Injectable()
export class PermissionServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @return Success
    */
   getAllPermissions(): Observable<FlatPermissionWithLevelDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Permission/GetAllPermissions';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAllPermissions(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAllPermissions(<any>response_);
                  } catch (e) {
                     return <Observable<FlatPermissionWithLevelDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<FlatPermissionWithLevelDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAllPermissions(response: HttpResponseBase): Observable<FlatPermissionWithLevelDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = FlatPermissionWithLevelDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<FlatPermissionWithLevelDtoListResultDto>(<any>null);
   }

   /**
    * @return Success
    */
   getAllPermissionsTree(): Observable<TreePermissionDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Permission/GetAllPermissionsTree';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAllPermissionsTree(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAllPermissionsTree(<any>response_);
                  } catch (e) {
                     return <Observable<TreePermissionDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<TreePermissionDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAllPermissionsTree(response: HttpResponseBase): Observable<TreePermissionDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = TreePermissionDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<TreePermissionDtoListResultDto>(<any>null);
   }
}

@Injectable()
export class ProductServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 批量创建产品
    * @param maxCount (optional)
    * @return Success
    */
   batchCreate(maxCount: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Product/BatchCreate?';
      if (maxCount === null) throw new Error("The parameter 'maxCount' cannot be null.");
      else if (maxCount !== undefined) url_ += 'maxCount=' + encodeURIComponent('' + maxCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processBatchCreate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processBatchCreate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processBatchCreate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @return Success
    */
   cacheTest(): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Product/CacheTest';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCacheTest(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCacheTest(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCacheTest(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 创建
    * @param body (optional)
    * @return Success
    */
   create(body: CreateProductInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Product/Create';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 获取
    * @param productName (optional)
    * @return Success
    */
   get(productName: string | null | undefined): Observable<Product> {
      let url_ = this.baseUrl + '/api/services/app/Product/Get?';
      if (productName !== undefined && productName !== null) url_ += 'productName=' + encodeURIComponent('' + productName) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGet(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGet(<any>response_);
                  } catch (e) {
                     return <Observable<Product>>(<any>_observableThrow(e));
                  }
               } else return <Observable<Product>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGet(response: HttpResponseBase): Observable<Product> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = Product.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<Product>(<any>null);
   }

   /**
    * 获取产品名称(缓存)
    * @param id (optional)
    * @return Success
    */
   getById(id: number | undefined): Observable<string> {
      let url_ = this.baseUrl + '/api/services/app/Product/GetById?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetById(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetById(<any>response_);
                  } catch (e) {
                     return <Observable<string>>(<any>_observableThrow(e));
                  }
               } else return <Observable<string>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetById(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<string>(<any>null);
   }

   /**
    * 更新
    * @param productName (optional)
    * @return Success
    */
   update(productName: string | null | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Product/Update?';
      if (productName !== undefined && productName !== null) url_ += 'productName=' + encodeURIComponent('' + productName) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class ProfileServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Profile/ChangeLanguage';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processChangeLanguage(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processChangeLanguage(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   changePassword(body: ChangePasswordInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Profile/ChangePassword';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processChangePassword(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processChangePassword(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processChangePassword(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 删除用户头像
    * @param profilePictureId (optional) 头像ID
    * @return Success
    */
   deleteProfilePictureById(profilePictureId: string | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Profile/DeleteProfilePictureById?';
      if (profilePictureId === null) throw new Error("The parameter 'profilePictureId' cannot be null.");
      else if (profilePictureId !== undefined) url_ += 'profilePictureId=' + encodeURIComponent('' + profilePictureId) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDeleteProfilePictureById(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDeleteProfilePictureById(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDeleteProfilePictureById(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 获取当前的个人信息
    * @return Success
    */
   getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
      let url_ = this.baseUrl + '/api/services/app/Profile/GetCurrentUserProfileForEdit';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetCurrentUserProfileForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetCurrentUserProfileForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<CurrentUserProfileEditDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<CurrentUserProfileEditDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = CurrentUserProfileEditDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<CurrentUserProfileEditDto>(<any>null);
   }

   /**
    * @param profilePictureId (optional)
    * @return Success
    */
   getProfilePictureById(profilePictureId: string | undefined): Observable<GetProfilePictureOutputDto> {
      let url_ = this.baseUrl + '/api/services/app/Profile/GetProfilePictureById?';
      if (profilePictureId === null) throw new Error("The parameter 'profilePictureId' cannot be null.");
      else if (profilePictureId !== undefined) url_ += 'profilePictureId=' + encodeURIComponent('' + profilePictureId) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetProfilePictureById(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetProfilePictureById(<any>response_);
                  } catch (e) {
                     return <Observable<GetProfilePictureOutputDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetProfilePictureOutputDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutputDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetProfilePictureOutputDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetProfilePictureOutputDto>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Profile/UpdateCurrentUserProfile';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdateCurrentUserProfile(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdateCurrentUserProfile(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Profile/UpdateProfilePicture';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdateProfilePicture(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdateProfilePicture(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class RedisLockServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @return Success
    */
   lockTest(): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/RedisLock/LockTest';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processLockTest(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processLockTest(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processLockTest(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class RoleServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 批量删除角色
    * @param body (optional)
    * @return Success
    */
   batchDelete(body: number[] | null | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Role/BatchDelete';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processBatchDelete(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processBatchDelete(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processBatchDelete(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   createOrUpdate(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Role/CreateOrUpdate';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreateOrUpdate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreateOrUpdate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   delete(id: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Role/Delete?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDelete(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDelete(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDelete(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 服务于前端RoleComboxComponent 组件信息，
    * @param permission (optional) 权限名称
    * @return Success
    */
   getAll(permission: string | null | undefined): Observable<RoleListDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Role/GetAll?';
      if (permission !== undefined && permission !== null) url_ += 'permission=' + encodeURIComponent('' + permission) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAll(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAll(<any>response_);
                  } catch (e) {
                     return <Observable<RoleListDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<RoleListDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAll(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = RoleListDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<RoleListDtoListResultDto>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   getForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
      let url_ = this.baseUrl + '/api/services/app/Role/GetForEdit?';
      if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<GetRoleForEditOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetRoleForEditOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetRoleForEditOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetRoleForEditOutput>(<any>null);
   }

   /**
    * @param permissionNames (optional) 权限名称
    * @param filterText (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getPaged(
      permissionNames: string[] | null | undefined,
      filterText: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<RoleListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Role/GetPaged?';
      if (permissionNames !== undefined && permissionNames !== null)
         permissionNames &&
            permissionNames.forEach((item) => {
               url_ += 'permissionNames=' + encodeURIComponent('' + item) + '&';
            });
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetPaged(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetPaged(<any>response_);
                  } catch (e) {
                     return <Observable<RoleListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<RoleListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetPaged(response: HttpResponseBase): Observable<RoleListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = RoleListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<RoleListDtoPagedResultDto>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   updatePermissions(body: UpdateRolePermissionsInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Role/UpdatePermissions';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdatePermissions(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdatePermissions(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdatePermissions(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class SequenceDefinerServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @return Success
    */
   createDemo(): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/SequenceDefiner/CreateDemo';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreateDemo(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreateDemo(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreateDemo(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   createOrUpdate(body: CreateOrUpdateSequenceDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/SequenceDefiner/CreateOrUpdate';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreateOrUpdate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreateOrUpdate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param filter (optional) 过滤条件
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getPagedDefinitions(
      filter: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<SequenceDefinitionListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/SequenceDefiner/GetPagedDefinitions?';
      if (filter !== undefined && filter !== null) url_ += 'filter=' + encodeURIComponent('' + filter) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetPagedDefinitions(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetPagedDefinitions(<any>response_);
                  } catch (e) {
                     return <Observable<SequenceDefinitionListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<SequenceDefinitionListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetPagedDefinitions(response: HttpResponseBase): Observable<SequenceDefinitionListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = SequenceDefinitionListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<SequenceDefinitionListDtoPagedResultDto>(<any>null);
   }
}

@Injectable()
export class SequenceGeneratorServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param sequenceCode (optional)
    * @return Success
    */
   nextSequence(sequenceCode: string | null | undefined): Observable<string> {
      let url_ = this.baseUrl + '/api/services/app/SequenceGenerator/NextSequence?';
      if (sequenceCode !== undefined && sequenceCode !== null) url_ += 'sequenceCode=' + encodeURIComponent('' + sequenceCode) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processNextSequence(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processNextSequence(<any>response_);
                  } catch (e) {
                     return <Observable<string>>(<any>_observableThrow(e));
                  }
               } else return <Observable<string>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processNextSequence(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<string>(<any>null);
   }
}

@Injectable()
export class SessionServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @return Success
    */
   generateUser(): Observable<User> {
      let url_ = this.baseUrl + '/api/services/app/Session/GenerateUser';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGenerateUser(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGenerateUser(<any>response_);
                  } catch (e) {
                     return <Observable<User>>(<any>_observableThrow(e));
                  }
               } else return <Observable<User>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGenerateUser(response: HttpResponseBase): Observable<User> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = User.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<User>(<any>null);
   }

   /**
    * 获取当前用户登录信息
    * @return Success
    */
   getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
      let url_ = this.baseUrl + '/api/services/app/Session/GetCurrentLoginInformations';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetCurrentLoginInformations(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetCurrentLoginInformations(<any>response_);
                  } catch (e) {
                     return <Observable<GetCurrentLoginInformationsOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetCurrentLoginInformationsOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
   }

   /**
    * @return Success
    */
   getUserConfigurations(): Observable<AbpUserConfigurationDto> {
      let url_ = this.baseUrl + '/api/services/app/Session/GetUserConfigurations';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetUserConfigurations(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetUserConfigurations(<any>response_);
                  } catch (e) {
                     return <Observable<AbpUserConfigurationDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<AbpUserConfigurationDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetUserConfigurations(response: HttpResponseBase): Observable<AbpUserConfigurationDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = AbpUserConfigurationDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<AbpUserConfigurationDto>(<any>null);
   }

   /**
    * @return Success
    */
   updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
      let url_ = this.baseUrl + '/api/services/app/Session/UpdateUserSignInToken';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdateUserSignInToken(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdateUserSignInToken(<any>response_);
                  } catch (e) {
                     return <Observable<UpdateUserSignInTokenOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<UpdateUserSignInTokenOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
   }
}

@Injectable()
export class SettingsAppServiceBaseServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/SettingsAppServiceBase/SendTestEmail';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processSendTestEmail(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processSendTestEmail(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class TableIdGeneratorServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 唯一编号
    * @return Success
    */
   getMaxId(): Observable<number> {
      let url_ = this.baseUrl + '/api/services/app/TableIdGenerator/GetMaxId';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetMaxId(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetMaxId(<any>response_);
                  } catch (e) {
                     return <Observable<number>>(<any>_observableThrow(e));
                  }
               } else return <Observable<number>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetMaxId(response: HttpResponseBase): Observable<number> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<number>(<any>null);
   }
}

@Injectable()
export class TenantServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   batchDelete(body: EntityDto[] | null | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/BatchDelete';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processBatchDelete(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processBatchDelete(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processBatchDelete(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   create(body: CreateTenantInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/Create';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   delete(id: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/Delete?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDelete(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDelete(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDelete(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   getForEdit(id: number | undefined): Observable<TenantEditDto> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/GetForEdit?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<TenantEditDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<TenantEditDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = TenantEditDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<TenantEditDto>(<any>null);
   }

   /**
    * @param subscriptionStart (optional)
    * @param subscriptionEnd (optional)
    * @param creationDateStart (optional)
    * @param creationDateEnd (optional)
    * @param editionId (optional)
    * @param filterText (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getPaged(
      subscriptionStart: Date | null | undefined,
      subscriptionEnd: Date | null | undefined,
      creationDateStart: Date | null | undefined,
      creationDateEnd: Date | null | undefined,
      editionId: number | null | undefined,
      filterText: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<TenantListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/GetPaged?';
      if (subscriptionStart !== undefined && subscriptionStart !== null)
         url_ += 'subscriptionStart=' + encodeURIComponent(subscriptionStart ? '' + subscriptionStart.toJSON() : '') + '&';
      if (subscriptionEnd !== undefined && subscriptionEnd !== null)
         url_ += 'subscriptionEnd=' + encodeURIComponent(subscriptionEnd ? '' + subscriptionEnd.toJSON() : '') + '&';
      if (creationDateStart !== undefined && creationDateStart !== null)
         url_ += 'creationDateStart=' + encodeURIComponent(creationDateStart ? '' + creationDateStart.toJSON() : '') + '&';
      if (creationDateEnd !== undefined && creationDateEnd !== null)
         url_ += 'creationDateEnd=' + encodeURIComponent(creationDateEnd ? '' + creationDateEnd.toJSON() : '') + '&';
      if (editionId !== undefined && editionId !== null) url_ += 'editionId=' + encodeURIComponent('' + editionId) + '&';
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetPaged(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetPaged(<any>response_);
                  } catch (e) {
                     return <Observable<TenantListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<TenantListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetPaged(response: HttpResponseBase): Observable<TenantListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = TenantListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<TenantListDtoPagedResultDto>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/GetTenantFeaturesForEdit?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetTenantFeaturesForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetTenantFeaturesForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<GetTenantFeaturesEditOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetTenantFeaturesEditOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/ResetTenantSpecificFeatures';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processResetTenantSpecificFeatures(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processResetTenantSpecificFeatures(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/UnlockTenantAdmin';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUnlockTenantAdmin(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUnlockTenantAdmin(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   update(body: TenantEditDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/Update';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/Tenant/UpdateTenantFeatures';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdateTenantFeatures(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdateTenantFeatures(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class TenantRegistrationServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 注册租户信息
    * @param body (optional)
    * @return Success
    */
   registerTenant(body: CreateTenantDto | undefined): Observable<RegisterTenantResultDto> {
      let url_ = this.baseUrl + '/api/services/app/TenantRegistration/RegisterTenant';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processRegisterTenant(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processRegisterTenant(<any>response_);
                  } catch (e) {
                     return <Observable<RegisterTenantResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<RegisterTenantResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = RegisterTenantResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<RegisterTenantResultDto>(<any>null);
   }
}

@Injectable()
export class TenantSettingsServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @return Success
    */
   clearCustomCss(): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/TenantSettings/ClearCustomCss';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processClearCustomCss(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processClearCustomCss(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @return Success
    */
   clearLogo(): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/TenantSettings/ClearLogo';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processClearLogo(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processClearLogo(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processClearLogo(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 获取所有设置
    * @return Success
    */
   getAllSettings(): Observable<TenantSettingsEditDto> {
      let url_ = this.baseUrl + '/api/services/app/TenantSettings/GetAllSettings';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetAllSettings(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetAllSettings(<any>response_);
                  } catch (e) {
                     return <Observable<TenantSettingsEditDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<TenantSettingsEditDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = TenantSettingsEditDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<TenantSettingsEditDto>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/TenantSettings/SendTestEmail';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processSendTestEmail(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processSendTestEmail(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 更新所有设置
    * @param body (optional)
    * @return Success
    */
   updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/TenantSettings/UpdateAllSettings';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdateAllSettings(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdateAllSettings(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class TimingServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param selectedTimezoneId (optional)
    * @return Success
    */
   getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
      let url_ = this.baseUrl + '/api/services/app/Timing/GetTimezoneComboboxItems?';
      if (selectedTimezoneId !== undefined && selectedTimezoneId !== null)
         url_ += 'selectedTimezoneId=' + encodeURIComponent('' + selectedTimezoneId) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetTimezoneComboboxItems(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetTimezoneComboboxItems(<any>response_);
                  } catch (e) {
                     return <Observable<ComboboxItemDto[]>>(<any>_observableThrow(e));
                  }
               } else return <Observable<ComboboxItemDto[]>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               if (Array.isArray(resultData200)) {
                  result200 = [] as any;
                  for (let item of resultData200) result200.push(ComboboxItemDto.fromJS(item));
               }
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<ComboboxItemDto[]>(<any>null);
   }

   /**
    * @return Success
    */
   getTimezones(defaultTimezoneScope: SettingScopes): Observable<NameValueDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/Timing/GetTimezones?';
      if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
         throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
      else url_ += 'defaultTimezoneScope=' + encodeURIComponent('' + defaultTimezoneScope) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetTimezones(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetTimezones(<any>response_);
                  } catch (e) {
                     return <Observable<NameValueDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<NameValueDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetTimezones(response: HttpResponseBase): Observable<NameValueDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = NameValueDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<NameValueDtoListResultDto>(<any>null);
   }
}

@Injectable()
export class UserServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 批量删除用户
    * @param body (optional) 用户Id列表
    * @return Success
    */
   batchDelete(body: number[] | null | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/User/BatchDelete';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processBatchDelete(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processBatchDelete(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processBatchDelete(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   createOrUpdate(body: CreateOrUpdateUserInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/User/CreateOrUpdate';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processCreateOrUpdate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processCreateOrUpdate(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   delete(id: number | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/User/Delete?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('delete', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDelete(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDelete(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDelete(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 修改用户信息
    * @param id (optional)
    * @return Success
    */
   getForEditTree(id: number | null | undefined): Observable<GetUserForEditTreeOutput> {
      let url_ = this.baseUrl + '/api/services/app/User/GetForEditTree?';
      if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetForEditTree(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetForEditTree(<any>response_);
                  } catch (e) {
                     return <Observable<GetUserForEditTreeOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetUserForEditTreeOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetForEditTree(response: HttpResponseBase): Observable<GetUserForEditTreeOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetUserForEditTreeOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetUserForEditTreeOutput>(<any>null);
   }

   /**
    * 分页获取所有用户
    * @param permission (optional) 权限
    * @param role (optional) 检索角色Id列表
    * @param isEmailConfirmed (optional) 是否已验证邮箱
    * @param isActive (optional) 是否已激活
    * @param onlyLockedUsers (optional) 仅被锁定的用户
    * @param filterText (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getPaged(
      permission: string[] | null | undefined,
      role: number[] | null | undefined,
      isEmailConfirmed: boolean | null | undefined,
      isActive: boolean | null | undefined,
      onlyLockedUsers: boolean | undefined,
      filterText: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<UserListDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/User/GetPaged?';
      if (permission !== undefined && permission !== null)
         permission &&
            permission.forEach((item) => {
               url_ += 'permission=' + encodeURIComponent('' + item) + '&';
            });
      if (role !== undefined && role !== null)
         role &&
            role.forEach((item) => {
               url_ += 'role=' + encodeURIComponent('' + item) + '&';
            });
      if (isEmailConfirmed !== undefined && isEmailConfirmed !== null) url_ += 'isEmailConfirmed=' + encodeURIComponent('' + isEmailConfirmed) + '&';
      if (isActive !== undefined && isActive !== null) url_ += 'isActive=' + encodeURIComponent('' + isActive) + '&';
      if (onlyLockedUsers === null) throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
      else if (onlyLockedUsers !== undefined) url_ += 'onlyLockedUsers=' + encodeURIComponent('' + onlyLockedUsers) + '&';
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetPaged(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetPaged(<any>response_);
                  } catch (e) {
                     return <Observable<UserListDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<UserListDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetPaged(response: HttpResponseBase): Observable<UserListDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = UserListDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<UserListDtoPagedResultDto>(<any>null);
   }

   /**
    * 用户的权限编辑
    * @param id (optional)
    * @return Success
    */
   getPermissionsTreeForEdit(id: number | undefined): Observable<GetUserPermissionsTreeForEditOutput> {
      let url_ = this.baseUrl + '/api/services/app/User/GetPermissionsTreeForEdit?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetPermissionsTreeForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetPermissionsTreeForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<GetUserPermissionsTreeForEditOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetUserPermissionsTreeForEditOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetPermissionsTreeForEdit(response: HttpResponseBase): Observable<GetUserPermissionsTreeForEditOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetUserPermissionsTreeForEditOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetUserPermissionsTreeForEditOutput>(<any>null);
   }

   /**
    * 获取角色列表
    * @return Success
    */
   getRoles(): Observable<RoleListDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/User/GetRoles';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetRoles(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetRoles(<any>response_);
                  } catch (e) {
                     return <Observable<RoleListDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<RoleListDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = RoleListDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<RoleListDtoListResultDto>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
      let url_ = this.baseUrl + '/api/services/app/User/GetUserForEdit?';
      if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetUserForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetUserForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<GetUserForEditOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetUserForEditOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetUserForEditOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetUserForEditOutput>(<any>null);
   }

   /**
    * @param id (optional)
    * @return Success
    */
   getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
      let url_ = this.baseUrl + '/api/services/app/User/GetUserPermissionsForEdit?';
      if (id === null) throw new Error("The parameter 'id' cannot be null.");
      else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetUserPermissionsForEdit(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetUserPermissionsForEdit(<any>response_);
                  } catch (e) {
                     return <Observable<GetUserPermissionsForEditOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetUserPermissionsForEditOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
   }

   /**
    * 获取用户导出信息
    * @param permission (optional) 权限
    * @param role (optional) 检索角色Id列表
    * @param isEmailConfirmed (optional) 是否已验证邮箱
    * @param isActive (optional) 是否已激活
    * @param onlyLockedUsers (optional) 仅被锁定的用户
    * @param filterText (optional)
    * @param sorting (optional)
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @return Success
    */
   getUsersToExcel(
      permission: string[] | null | undefined,
      role: number[] | null | undefined,
      isEmailConfirmed: boolean | null | undefined,
      isActive: boolean | null | undefined,
      onlyLockedUsers: boolean | undefined,
      filterText: string | null | undefined,
      sorting: string | null | undefined,
      maxResultCount: number | undefined,
      skipCount: number | undefined
   ): Observable<FileDto> {
      let url_ = this.baseUrl + '/api/services/app/User/GetUsersToExcel?';
      if (permission !== undefined && permission !== null)
         permission &&
            permission.forEach((item) => {
               url_ += 'permission=' + encodeURIComponent('' + item) + '&';
            });
      if (role !== undefined && role !== null)
         role &&
            role.forEach((item) => {
               url_ += 'role=' + encodeURIComponent('' + item) + '&';
            });
      if (isEmailConfirmed !== undefined && isEmailConfirmed !== null) url_ += 'isEmailConfirmed=' + encodeURIComponent('' + isEmailConfirmed) + '&';
      if (isActive !== undefined && isActive !== null) url_ += 'isActive=' + encodeURIComponent('' + isActive) + '&';
      if (onlyLockedUsers === null) throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
      else if (onlyLockedUsers !== undefined) url_ += 'onlyLockedUsers=' + encodeURIComponent('' + onlyLockedUsers) + '&';
      if (filterText !== undefined && filterText !== null) url_ += 'filterText=' + encodeURIComponent('' + filterText) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetUsersToExcel(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetUsersToExcel(<any>response_);
                  } catch (e) {
                     return <Observable<FileDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<FileDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = FileDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<FileDto>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   resetPassword(body: Int64NullableIdDto | undefined): Observable<string> {
      let url_ = this.baseUrl + '/api/services/app/User/ResetPassword';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processResetPassword(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processResetPassword(<any>response_);
                  } catch (e) {
                     return <Observable<string>>(<any>_observableThrow(e));
                  }
               } else return <Observable<string>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processResetPassword(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = resultData200 !== undefined ? resultData200 : <any>null;
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<string>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   resetSpecificPermissions(body: Int64EntityDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/User/ResetSpecificPermissions';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processResetSpecificPermissions(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processResetSpecificPermissions(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processResetSpecificPermissions(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   unlock(body: Int64EntityDto | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/User/Unlock';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUnlock(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUnlock(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUnlock(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   updatePermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/User/UpdatePermissions';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('put', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUpdatePermissions(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUpdatePermissions(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUpdatePermissions(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class UserLinkServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param maxResultCount (optional)
    * @param skipCount (optional)
    * @param sorting (optional)
    * @return Success
    */
   getLinkedUsers(
      maxResultCount: number | undefined,
      skipCount: number | undefined,
      sorting: string | null | undefined
   ): Observable<LinkedUserDtoPagedResultDto> {
      let url_ = this.baseUrl + '/api/services/app/UserLink/GetLinkedUsers?';
      if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
      else if (maxResultCount !== undefined) url_ += 'maxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
      if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
      else if (skipCount !== undefined) url_ += 'skipCount=' + encodeURIComponent('' + skipCount) + '&';
      if (sorting !== undefined && sorting !== null) url_ += 'sorting=' + encodeURIComponent('' + sorting) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetLinkedUsers(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetLinkedUsers(<any>response_);
                  } catch (e) {
                     return <Observable<LinkedUserDtoPagedResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<LinkedUserDtoPagedResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetLinkedUsers(response: HttpResponseBase): Observable<LinkedUserDtoPagedResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = LinkedUserDtoPagedResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<LinkedUserDtoPagedResultDto>(<any>null);
   }

   /**
    * @return Success
    */
   getRecentlyUsedLinkedUsers(): Observable<LinkedUserDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/UserLink/GetRecentlyUsedLinkedUsers';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetRecentlyUsedLinkedUsers(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                  } catch (e) {
                     return <Observable<LinkedUserDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<LinkedUserDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<LinkedUserDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = LinkedUserDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<LinkedUserDtoListResultDto>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   linkToUser(body: LinkToUserInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/UserLink/LinkToUser';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processLinkToUser(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processLinkToUser(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processLinkToUser(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/UserLink/UnlinkUser';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processUnlinkUser(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processUnlinkUser(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class UserLoginServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @return Success
    */
   getRecentUserLoginAttempts(): Observable<UserLoginAttemptDtoListResultDto> {
      let url_ = this.baseUrl + '/api/services/app/UserLogin/GetRecentUserLoginAttempts';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetRecentUserLoginAttempts(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetRecentUserLoginAttempts(<any>response_);
                  } catch (e) {
                     return <Observable<UserLoginAttemptDtoListResultDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<UserLoginAttemptDtoListResultDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<UserLoginAttemptDtoListResultDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = UserLoginAttemptDtoListResultDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<UserLoginAttemptDtoListResultDto>(<any>null);
   }
}

@Injectable()
export class WebSiteLogServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 下载网站日志信息
    * @return Success
    */
   downloadWebLogs(): Observable<FileDto> {
      let url_ = this.baseUrl + '/api/services/app/WebSiteLog/DownloadWebLogs';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processDownloadWebLogs(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processDownloadWebLogs(<any>response_);
                  } catch (e) {
                     return <Observable<FileDto>>(<any>_observableThrow(e));
                  }
               } else return <Observable<FileDto>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = FileDto.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<FileDto>(<any>null);
   }

   /**
    * 获取最新的网站日志信息
    * @return Success
    */
   getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
      let url_ = this.baseUrl + '/api/services/app/WebSiteLog/GetLatestWebLogs';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetLatestWebLogs(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetLatestWebLogs(<any>response_);
                  } catch (e) {
                     return <Observable<GetLatestWebLogsOutput>>(<any>_observableThrow(e));
                  }
               } else return <Observable<GetLatestWebLogsOutput>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = GetLatestWebLogsOutput.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<GetLatestWebLogsOutput>(<any>null);
   }
}

@Injectable()
export class WeChatWorkServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 通过企业微信发送本文消息
    * @param body (optional)
    * @return Success
    */
   sendTextMessage(body: SendTextInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/WeChatWork/SendTextMessage';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processSendTextMessage(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processSendTextMessage(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processSendTextMessage(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }

   /**
    * 通过企业微信发送测试消息
    * @param body (optional)
    * @return Success
    */
   testSendMessage(body: TestSendTextInput | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/services/app/WeChatWork/TestSendMessage';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processTestSendMessage(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processTestSendMessage(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processTestSendMessage(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

@Injectable()
export class TokenAuthServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * @param body (optional)
    * @return Success
    */
   activateAccount(body: ActivateAccountModel | undefined): Observable<ActivateAccountResultModel> {
      let url_ = this.baseUrl + '/api/TokenAuth/ActivateAccount';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processActivateAccount(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processActivateAccount(<any>response_);
                  } catch (e) {
                     return <Observable<ActivateAccountResultModel>>(<any>_observableThrow(e));
                  }
               } else return <Observable<ActivateAccountResultModel>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processActivateAccount(response: HttpResponseBase): Observable<ActivateAccountResultModel> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = ActivateAccountResultModel.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<ActivateAccountResultModel>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
      let url_ = this.baseUrl + '/api/TokenAuth/Authenticate';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processAuthenticate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processAuthenticate(<any>response_);
                  } catch (e) {
                     return <Observable<AuthenticateResultModel>>(<any>_observableThrow(e));
                  }
               } else return <Observable<AuthenticateResultModel>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = AuthenticateResultModel.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<AuthenticateResultModel>(<any>null);
   }

   /**
    * @param body (optional)
    * @return Success
    */
   externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
      let url_ = this.baseUrl + '/api/TokenAuth/ExternalAuthenticate';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
         body: content_,
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            'Content-Type': 'application/json-patch+json',
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processExternalAuthenticate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processExternalAuthenticate(<any>response_);
                  } catch (e) {
                     return <Observable<ExternalAuthenticateResultModel>>(<any>_observableThrow(e));
                  }
               } else return <Observable<ExternalAuthenticateResultModel>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<ExternalAuthenticateResultModel>(<any>null);
   }

   /**
    * @return Success
    */
   getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
      let url_ = this.baseUrl + '/api/TokenAuth/GetExternalAuthenticationProviders';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGetExternalAuthenticationProviders(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGetExternalAuthenticationProviders(<any>response_);
                  } catch (e) {
                     return <Observable<ExternalLoginProviderInfoModel[]>>(<any>_observableThrow(e));
                  }
               } else return <Observable<ExternalLoginProviderInfoModel[]>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               if (Array.isArray(resultData200)) {
                  result200 = [] as any;
                  for (let item of resultData200) result200.push(ExternalLoginProviderInfoModel.fromJS(item));
               }
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
   }

   /**
    * @param impersonationToken (optional)
    * @return Success
    */
   impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
      let url_ = this.baseUrl + '/api/TokenAuth/ImpersonatedAuthenticate?';
      if (impersonationToken !== undefined && impersonationToken !== null)
         url_ += 'impersonationToken=' + encodeURIComponent('' + impersonationToken) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processImpersonatedAuthenticate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processImpersonatedAuthenticate(<any>response_);
                  } catch (e) {
                     return <Observable<ImpersonatedAuthenticateResultModel>>(<any>_observableThrow(e));
                  }
               } else return <Observable<ImpersonatedAuthenticateResultModel>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
   }

   /**
    * @param switchAccountToken (optional)
    * @return Success
    */
   linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
      let url_ = this.baseUrl + '/api/TokenAuth/LinkedAccountAuthenticate?';
      if (switchAccountToken !== undefined && switchAccountToken !== null)
         url_ += 'switchAccountToken=' + encodeURIComponent('' + switchAccountToken) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({
            Accept: 'text/plain',
         }),
      };

      return this.http
         .request('post', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processLinkedAccountAuthenticate(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processLinkedAccountAuthenticate(<any>response_);
                  } catch (e) {
                     return <Observable<SwitchedAccountAuthenticateResultModel>>(<any>_observableThrow(e));
                  }
               } else return <Observable<SwitchedAccountAuthenticateResultModel>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               let result200: any = null;
               let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
               result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
               return _observableOf(result200);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
   }
}

@Injectable()
export class VerificationServiceProxy {
   private http: HttpClient;
   private baseUrl: string;
   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

   constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
   }

   /**
    * 生成验证码
    * @param name (optional) 验证码key
    * @param t (optional) 验证码类型
    * @param tid (optional) 租户Id(可空)
    * @return Success
    */
   generateCaptcha(name: string | null | undefined, t: CaptchaType | undefined, tid: number | null | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/Verification/GenerateCaptcha?';
      if (name !== undefined && name !== null) url_ += 'name=' + encodeURIComponent('' + name) + '&';
      if (t === null) throw new Error("The parameter 't' cannot be null.");
      else if (t !== undefined) url_ += 't=' + encodeURIComponent('' + t) + '&';
      if (tid !== undefined && tid !== null) url_ += 'tid=' + encodeURIComponent('' + tid) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
         observe: 'response',
         responseType: 'blob',
         headers: new HttpHeaders({}),
      };

      return this.http
         .request('get', url_, options_)
         .pipe(
            _observableMergeMap((response_: any) => {
               return this.processGenerateCaptcha(response_);
            })
         )
         .pipe(
            _observableCatch((response_: any) => {
               if (response_ instanceof HttpResponseBase) {
                  try {
                     return this.processGenerateCaptcha(<any>response_);
                  } catch (e) {
                     return <Observable<void>>(<any>_observableThrow(e));
                  }
               } else return <Observable<void>>(<any>_observableThrow(response_));
            })
         );
   }

   protected processGenerateCaptcha(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
         response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
         for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
         }
      }
      if (status === 200) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return _observableOf<void>(<any>null);
            })
         );
      } else if (status !== 200 && status !== 204) {
         return blobToText(responseBlob).pipe(
            _observableMergeMap((_responseText) => {
               return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            })
         );
      }
      return _observableOf<void>(<any>null);
   }
}

export class ActivateEmailInput implements IActivateEmailInput {
   userId: number;
   confirmationCode: string | undefined;
   /** Encrypted values for {TenantId}, {UserId} and {ConfirmationCode} */
   c: string | undefined;

   constructor(data?: IActivateEmailInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userId = _data['userId'];
         this.confirmationCode = _data['confirmationCode'];
         this.c = _data['c'];
      }
   }

   static fromJS(data: any): ActivateEmailInput {
      data = typeof data === 'object' ? data : {};
      let result = new ActivateEmailInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userId'] = this.userId;
      data['confirmationCode'] = this.confirmationCode;
      data['c'] = this.c;
      return data;
   }

   clone(): ActivateEmailInput {
      const json = this.toJSON();
      let result = new ActivateEmailInput();
      result.init(json);
      return result;
   }
}

export interface IActivateEmailInput {
   userId: number;
   confirmationCode: string | undefined;
   /** Encrypted values for {TenantId}, {UserId} and {ConfirmationCode} */
   c: string | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
   impersonationToken: string | undefined;
   tenancyName: string | undefined;

   constructor(data?: IImpersonateOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.impersonationToken = _data['impersonationToken'];
         this.tenancyName = _data['tenancyName'];
      }
   }

   static fromJS(data: any): ImpersonateOutput {
      data = typeof data === 'object' ? data : {};
      let result = new ImpersonateOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['impersonationToken'] = this.impersonationToken;
      data['tenancyName'] = this.tenancyName;
      return data;
   }

   clone(): ImpersonateOutput {
      const json = this.toJSON();
      let result = new ImpersonateOutput();
      result.init(json);
      return result;
   }
}

export interface IImpersonateOutput {
   impersonationToken: string | undefined;
   tenancyName: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
   tenantId: number | undefined;
   userId: number;

   constructor(data?: IImpersonateInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.userId = _data['userId'];
      }
   }

   static fromJS(data: any): ImpersonateInput {
      data = typeof data === 'object' ? data : {};
      let result = new ImpersonateInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['userId'] = this.userId;
      return data;
   }

   clone(): ImpersonateInput {
      const json = this.toJSON();
      let result = new ImpersonateInput();
      result.init(json);
      return result;
   }
}

export interface IImpersonateInput {
   tenantId: number | undefined;
   userId: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
   tenancyName: string;

   constructor(data?: IIsTenantAvailableInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenancyName = _data['tenancyName'];
      }
   }

   static fromJS(data: any): IsTenantAvailableInput {
      data = typeof data === 'object' ? data : {};
      let result = new IsTenantAvailableInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenancyName'] = this.tenancyName;
      return data;
   }

   clone(): IsTenantAvailableInput {
      const json = this.toJSON();
      let result = new IsTenantAvailableInput();
      result.init(json);
      return result;
   }
}

export interface IIsTenantAvailableInput {
   tenancyName: string;
}

export enum TenantAvailabilityState {
   _1 = 1,
   _2 = 2,
   _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
   state: TenantAvailabilityState;
   tenantId: number | undefined;

   constructor(data?: IIsTenantAvailableOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.state = _data['state'];
         this.tenantId = _data['tenantId'];
      }
   }

   static fromJS(data: any): IsTenantAvailableOutput {
      data = typeof data === 'object' ? data : {};
      let result = new IsTenantAvailableOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['state'] = this.state;
      data['tenantId'] = this.tenantId;
      return data;
   }

   clone(): IsTenantAvailableOutput {
      const json = this.toJSON();
      let result = new IsTenantAvailableOutput();
      result.init(json);
      return result;
   }
}

export interface IIsTenantAvailableOutput {
   state: TenantAvailabilityState;
   tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
   userName: string;
   emailAddress: string;
   password: string;
   verificationCode: string | undefined;

   constructor(data?: IRegisterInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userName = _data['userName'];
         this.emailAddress = _data['emailAddress'];
         this.password = _data['password'];
         this.verificationCode = _data['verificationCode'];
      }
   }

   static fromJS(data: any): RegisterInput {
      data = typeof data === 'object' ? data : {};
      let result = new RegisterInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userName'] = this.userName;
      data['emailAddress'] = this.emailAddress;
      data['password'] = this.password;
      data['verificationCode'] = this.verificationCode;
      return data;
   }

   clone(): RegisterInput {
      const json = this.toJSON();
      let result = new RegisterInput();
      result.init(json);
      return result;
   }
}

export interface IRegisterInput {
   userName: string;
   emailAddress: string;
   password: string;
   verificationCode: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
   canLogin: boolean;

   constructor(data?: IRegisterOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.canLogin = _data['canLogin'];
      }
   }

   static fromJS(data: any): RegisterOutput {
      data = typeof data === 'object' ? data : {};
      let result = new RegisterOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['canLogin'] = this.canLogin;
      return data;
   }

   clone(): RegisterOutput {
      const json = this.toJSON();
      let result = new RegisterOutput();
      result.init(json);
      return result;
   }
}

export interface IRegisterOutput {
   canLogin: boolean;
}

export class ResetPasswordInput implements IResetPasswordInput {
   userId: number;
   resetCode: string;
   password: string;
   returnUrl: string | undefined;
   singleSignIn: string | undefined;

   constructor(data?: IResetPasswordInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userId = _data['userId'];
         this.resetCode = _data['resetCode'];
         this.password = _data['password'];
         this.returnUrl = _data['returnUrl'];
         this.singleSignIn = _data['singleSignIn'];
      }
   }

   static fromJS(data: any): ResetPasswordInput {
      data = typeof data === 'object' ? data : {};
      let result = new ResetPasswordInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userId'] = this.userId;
      data['resetCode'] = this.resetCode;
      data['password'] = this.password;
      data['returnUrl'] = this.returnUrl;
      data['singleSignIn'] = this.singleSignIn;
      return data;
   }

   clone(): ResetPasswordInput {
      const json = this.toJSON();
      let result = new ResetPasswordInput();
      result.init(json);
      return result;
   }
}

export interface IResetPasswordInput {
   userId: number;
   resetCode: string;
   password: string;
   returnUrl: string | undefined;
   singleSignIn: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
   canLogin: boolean;
   userName: string | undefined;

   constructor(data?: IResetPasswordOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.canLogin = _data['canLogin'];
         this.userName = _data['userName'];
      }
   }

   static fromJS(data: any): ResetPasswordOutput {
      data = typeof data === 'object' ? data : {};
      let result = new ResetPasswordOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['canLogin'] = this.canLogin;
      data['userName'] = this.userName;
      return data;
   }

   clone(): ResetPasswordOutput {
      const json = this.toJSON();
      let result = new ResetPasswordOutput();
      result.init(json);
      return result;
   }
}

export interface IResetPasswordOutput {
   canLogin: boolean;
   userName: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
   c: string | undefined;

   constructor(data?: IResolveTenantIdInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.c = _data['c'];
      }
   }

   static fromJS(data: any): ResolveTenantIdInput {
      data = typeof data === 'object' ? data : {};
      let result = new ResolveTenantIdInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['c'] = this.c;
      return data;
   }

   clone(): ResolveTenantIdInput {
      const json = this.toJSON();
      let result = new ResolveTenantIdInput();
      result.init(json);
      return result;
   }
}

export interface IResolveTenantIdInput {
   c: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
   emailAddress: string;

   constructor(data?: ISendEmailActivationLinkInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.emailAddress = _data['emailAddress'];
      }
   }

   static fromJS(data: any): SendEmailActivationLinkInput {
      data = typeof data === 'object' ? data : {};
      let result = new SendEmailActivationLinkInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['emailAddress'] = this.emailAddress;
      return data;
   }

   clone(): SendEmailActivationLinkInput {
      const json = this.toJSON();
      let result = new SendEmailActivationLinkInput();
      result.init(json);
      return result;
   }
}

export interface ISendEmailActivationLinkInput {
   emailAddress: string;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
   emailAddress: string;

   constructor(data?: ISendPasswordResetCodeInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.emailAddress = _data['emailAddress'];
      }
   }

   static fromJS(data: any): SendPasswordResetCodeInput {
      data = typeof data === 'object' ? data : {};
      let result = new SendPasswordResetCodeInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['emailAddress'] = this.emailAddress;
      return data;
   }

   clone(): SendPasswordResetCodeInput {
      const json = this.toJSON();
      let result = new SendPasswordResetCodeInput();
      result.init(json);
      return result;
   }
}

export interface ISendPasswordResetCodeInput {
   emailAddress: string;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
   targetTenantId: number | undefined;
   targetUserId: number;

   constructor(data?: ISwitchToLinkedAccountInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.targetTenantId = _data['targetTenantId'];
         this.targetUserId = _data['targetUserId'];
      }
   }

   static fromJS(data: any): SwitchToLinkedAccountInput {
      data = typeof data === 'object' ? data : {};
      let result = new SwitchToLinkedAccountInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['targetTenantId'] = this.targetTenantId;
      data['targetUserId'] = this.targetUserId;
      return data;
   }

   clone(): SwitchToLinkedAccountInput {
      const json = this.toJSON();
      let result = new SwitchToLinkedAccountInput();
      result.init(json);
      return result;
   }
}

export interface ISwitchToLinkedAccountInput {
   targetTenantId: number | undefined;
   targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
   switchAccountToken: string | undefined;
   tenancyName: string | undefined;

   constructor(data?: ISwitchToLinkedAccountOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.switchAccountToken = _data['switchAccountToken'];
         this.tenancyName = _data['tenancyName'];
      }
   }

   static fromJS(data: any): SwitchToLinkedAccountOutput {
      data = typeof data === 'object' ? data : {};
      let result = new SwitchToLinkedAccountOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['switchAccountToken'] = this.switchAccountToken;
      data['tenancyName'] = this.tenancyName;
      return data;
   }

   clone(): SwitchToLinkedAccountOutput {
      const json = this.toJSON();
      let result = new SwitchToLinkedAccountOutput();
      result.init(json);
      return result;
   }
}

export interface ISwitchToLinkedAccountOutput {
   switchAccountToken: string | undefined;
   tenancyName: string | undefined;
}

export class FileDto implements IFileDto {
   fileName: string;
   fileType: string;
   fileToken: string;

   constructor(data?: IFileDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.fileName = _data['fileName'];
         this.fileType = _data['fileType'];
         this.fileToken = _data['fileToken'];
      }
   }

   static fromJS(data: any): FileDto {
      data = typeof data === 'object' ? data : {};
      let result = new FileDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['fileName'] = this.fileName;
      data['fileType'] = this.fileType;
      data['fileToken'] = this.fileToken;
      return data;
   }

   clone(): FileDto {
      const json = this.toJSON();
      let result = new FileDto();
      result.init(json);
      return result;
   }
}

export interface IFileDto {
   fileName: string;
   fileType: string;
   fileToken: string;
}

export enum EntityChangeType {
   _0 = 0,
   _1 = 1,
   _2 = 2,
}

export class EntityChangeListDto implements IEntityChangeListDto {
   /** 用户Id */
   userId: number | undefined;
   /** 用户名 */
   userName: string | undefined;
   /** 变化时间 */
   changeTime: Date;
   /** 实体完整类名.包含名称空间 */
   entityTypeFullName: string | undefined;
   changeType: EntityChangeType;
   /** 中文名称 */
   readonly changeTypeName: string | undefined;
   /** 所属SetId */
   entityChangeSetId: number;
   id: number;

   constructor(data?: IEntityChangeListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userId = _data['userId'];
         this.userName = _data['userName'];
         this.changeTime = _data['changeTime'] ? new Date(_data['changeTime'].toString()) : <any>undefined;
         this.entityTypeFullName = _data['entityTypeFullName'];
         this.changeType = _data['changeType'];
         (<any>this).changeTypeName = _data['changeTypeName'];
         this.entityChangeSetId = _data['entityChangeSetId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): EntityChangeListDto {
      data = typeof data === 'object' ? data : {};
      let result = new EntityChangeListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userId'] = this.userId;
      data['userName'] = this.userName;
      data['changeTime'] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
      data['entityTypeFullName'] = this.entityTypeFullName;
      data['changeType'] = this.changeType;
      data['changeTypeName'] = this.changeTypeName;
      data['entityChangeSetId'] = this.entityChangeSetId;
      data['id'] = this.id;
      return data;
   }

   clone(): EntityChangeListDto {
      const json = this.toJSON();
      let result = new EntityChangeListDto();
      result.init(json);
      return result;
   }
}

export interface IEntityChangeListDto {
   /** 用户Id */
   userId: number | undefined;
   /** 用户名 */
   userName: string | undefined;
   /** 变化时间 */
   changeTime: Date;
   /** 实体完整类名.包含名称空间 */
   entityTypeFullName: string | undefined;
   changeType: EntityChangeType;
   /** 中文名称 */
   changeTypeName: string | undefined;
   /** 所属SetId */
   entityChangeSetId: number;
   id: number;
}

export class EntityChangeListDtoPagedResultDto implements IEntityChangeListDtoPagedResultDto {
   totalCount: number;
   items: EntityChangeListDto[] | undefined;

   constructor(data?: IEntityChangeListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(EntityChangeListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): EntityChangeListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new EntityChangeListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): EntityChangeListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new EntityChangeListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IEntityChangeListDtoPagedResultDto {
   totalCount: number;
   items: EntityChangeListDto[] | undefined;
}

export class NameValueDto implements INameValueDto {
   name: string | undefined;
   value: string | undefined;

   constructor(data?: INameValueDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.value = _data['value'];
      }
   }

   static fromJS(data: any): NameValueDto {
      data = typeof data === 'object' ? data : {};
      let result = new NameValueDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['value'] = this.value;
      return data;
   }

   clone(): NameValueDto {
      const json = this.toJSON();
      let result = new NameValueDto();
      result.init(json);
      return result;
   }
}

export interface INameValueDto {
   name: string | undefined;
   value: string | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
   /** 用户Id */
   userId: number | undefined;
   /** 用户名 */
   userName: string | undefined;
   /** 模拟租户Id */
   impersonatorTenantId: number | undefined;
   /** 模拟用户Id */
   impersonatorUserId: number | undefined;
   /** 服务名称 */
   serviceName: string | undefined;
   /** 方法名称 */
   methodName: string | undefined;
   /** 参数 */
   parameters: string | undefined;
   /** 执行时间 */
   executionTime: Date;
   /** 持续时间 */
   executionDuration: number;
   /** 客户端ip地址 */
   clientIpAddress: string | undefined;
   /** 客户端 */
   clientName: string | undefined;
   /** 浏览器信息 */
   browserInfo: string | undefined;
   /** 异常 */
   exception: string | undefined;
   /** 自定义信息 */
   customData: string | undefined;
   id: number;

   constructor(data?: IAuditLogListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userId = _data['userId'];
         this.userName = _data['userName'];
         this.impersonatorTenantId = _data['impersonatorTenantId'];
         this.impersonatorUserId = _data['impersonatorUserId'];
         this.serviceName = _data['serviceName'];
         this.methodName = _data['methodName'];
         this.parameters = _data['parameters'];
         this.executionTime = _data['executionTime'] ? new Date(_data['executionTime'].toString()) : <any>undefined;
         this.executionDuration = _data['executionDuration'];
         this.clientIpAddress = _data['clientIpAddress'];
         this.clientName = _data['clientName'];
         this.browserInfo = _data['browserInfo'];
         this.exception = _data['exception'];
         this.customData = _data['customData'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): AuditLogListDto {
      data = typeof data === 'object' ? data : {};
      let result = new AuditLogListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userId'] = this.userId;
      data['userName'] = this.userName;
      data['impersonatorTenantId'] = this.impersonatorTenantId;
      data['impersonatorUserId'] = this.impersonatorUserId;
      data['serviceName'] = this.serviceName;
      data['methodName'] = this.methodName;
      data['parameters'] = this.parameters;
      data['executionTime'] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
      data['executionDuration'] = this.executionDuration;
      data['clientIpAddress'] = this.clientIpAddress;
      data['clientName'] = this.clientName;
      data['browserInfo'] = this.browserInfo;
      data['exception'] = this.exception;
      data['customData'] = this.customData;
      data['id'] = this.id;
      return data;
   }

   clone(): AuditLogListDto {
      const json = this.toJSON();
      let result = new AuditLogListDto();
      result.init(json);
      return result;
   }
}

export interface IAuditLogListDto {
   /** 用户Id */
   userId: number | undefined;
   /** 用户名 */
   userName: string | undefined;
   /** 模拟租户Id */
   impersonatorTenantId: number | undefined;
   /** 模拟用户Id */
   impersonatorUserId: number | undefined;
   /** 服务名称 */
   serviceName: string | undefined;
   /** 方法名称 */
   methodName: string | undefined;
   /** 参数 */
   parameters: string | undefined;
   /** 执行时间 */
   executionTime: Date;
   /** 持续时间 */
   executionDuration: number;
   /** 客户端ip地址 */
   clientIpAddress: string | undefined;
   /** 客户端 */
   clientName: string | undefined;
   /** 浏览器信息 */
   browserInfo: string | undefined;
   /** 异常 */
   exception: string | undefined;
   /** 自定义信息 */
   customData: string | undefined;
   id: number;
}

export class AuditLogListDtoPagedResultDto implements IAuditLogListDtoPagedResultDto {
   totalCount: number;
   items: AuditLogListDto[] | undefined;

   constructor(data?: IAuditLogListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(AuditLogListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): AuditLogListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new AuditLogListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): AuditLogListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new AuditLogListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IAuditLogListDtoPagedResultDto {
   totalCount: number;
   items: AuditLogListDto[] | undefined;
}

export class CommonLookupFindUsersInput implements ICommonLookupFindUsersInput {
   tenantId: number | undefined;
   maxResultCount: number;
   skipCount: number;
   filterText: string | undefined;

   constructor(data?: ICommonLookupFindUsersInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.maxResultCount = _data['maxResultCount'];
         this.skipCount = _data['skipCount'];
         this.filterText = _data['filterText'];
      }
   }

   static fromJS(data: any): CommonLookupFindUsersInput {
      data = typeof data === 'object' ? data : {};
      let result = new CommonLookupFindUsersInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['maxResultCount'] = this.maxResultCount;
      data['skipCount'] = this.skipCount;
      data['filterText'] = this.filterText;
      return data;
   }

   clone(): CommonLookupFindUsersInput {
      const json = this.toJSON();
      let result = new CommonLookupFindUsersInput();
      result.init(json);
      return result;
   }
}

export interface ICommonLookupFindUsersInput {
   tenantId: number | undefined;
   maxResultCount: number;
   skipCount: number;
   filterText: string | undefined;
}

export class NameValueDtoPagedResultDto implements INameValueDtoPagedResultDto {
   totalCount: number;
   items: NameValueDto[] | undefined;

   constructor(data?: INameValueDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(NameValueDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): NameValueDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new NameValueDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): NameValueDtoPagedResultDto {
      const json = this.toJSON();
      let result = new NameValueDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface INameValueDtoPagedResultDto {
   totalCount: number;
   items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
   name: string | undefined;

   constructor(data?: IGetDefaultEditionNameOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
      }
   }

   static fromJS(data: any): GetDefaultEditionNameOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetDefaultEditionNameOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      return data;
   }

   clone(): GetDefaultEditionNameOutput {
      const json = this.toJSON();
      let result = new GetDefaultEditionNameOutput();
      result.init(json);
      return result;
   }
}

export interface IGetDefaultEditionNameOutput {
   name: string | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
   isFree: boolean | undefined;
   value: string | undefined;
   displayText: string | undefined;
   isSelected: boolean;

   constructor(data?: ISubscribableEditionComboboxItemDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.isFree = _data['isFree'];
         this.value = _data['value'];
         this.displayText = _data['displayText'];
         this.isSelected = _data['isSelected'];
      }
   }

   static fromJS(data: any): SubscribableEditionComboboxItemDto {
      data = typeof data === 'object' ? data : {};
      let result = new SubscribableEditionComboboxItemDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['isFree'] = this.isFree;
      data['value'] = this.value;
      data['displayText'] = this.displayText;
      data['isSelected'] = this.isSelected;
      return data;
   }

   clone(): SubscribableEditionComboboxItemDto {
      const json = this.toJSON();
      let result = new SubscribableEditionComboboxItemDto();
      result.init(json);
      return result;
   }
}

export interface ISubscribableEditionComboboxItemDto {
   isFree: boolean | undefined;
   value: string | undefined;
   displayText: string | undefined;
   isSelected: boolean;
}

export class SubscribableEditionComboboxItemDtoListResultDto implements ISubscribableEditionComboboxItemDtoListResultDto {
   items: SubscribableEditionComboboxItemDto[] | undefined;

   constructor(data?: ISubscribableEditionComboboxItemDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): SubscribableEditionComboboxItemDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new SubscribableEditionComboboxItemDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): SubscribableEditionComboboxItemDtoListResultDto {
      const json = this.toJSON();
      let result = new SubscribableEditionComboboxItemDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface ISubscribableEditionComboboxItemDtoListResultDto {
   items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class Int32ComboboxItemDtoT implements IInt32ComboboxItemDtoT {
   value: number;
   displayText: string | undefined;
   isSelected: boolean;

   constructor(data?: IInt32ComboboxItemDtoT) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.value = _data['value'];
         this.displayText = _data['displayText'];
         this.isSelected = _data['isSelected'];
      }
   }

   static fromJS(data: any): Int32ComboboxItemDtoT {
      data = typeof data === 'object' ? data : {};
      let result = new Int32ComboboxItemDtoT();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['value'] = this.value;
      data['displayText'] = this.displayText;
      data['isSelected'] = this.isSelected;
      return data;
   }

   clone(): Int32ComboboxItemDtoT {
      const json = this.toJSON();
      let result = new Int32ComboboxItemDtoT();
      result.init(json);
      return result;
   }
}

export interface IInt32ComboboxItemDtoT {
   value: number;
   displayText: string | undefined;
   isSelected: boolean;
}

export class Int32ComboboxItemDtoTListResultDto implements IInt32ComboboxItemDtoTListResultDto {
   items: Int32ComboboxItemDtoT[] | undefined;

   constructor(data?: IInt32ComboboxItemDtoTListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(Int32ComboboxItemDtoT.fromJS(item));
         }
      }
   }

   static fromJS(data: any): Int32ComboboxItemDtoTListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new Int32ComboboxItemDtoTListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): Int32ComboboxItemDtoTListResultDto {
      const json = this.toJSON();
      let result = new Int32ComboboxItemDtoTListResultDto();
      result.init(json);
      return result;
   }
}

export interface IInt32ComboboxItemDtoTListResultDto {
   items: Int32ComboboxItemDtoT[] | undefined;
}

export class JavaScriptEvaluateInput implements IJavaScriptEvaluateInput {
   /** JavaScript表达式 */
   expression: string | undefined;

   constructor(data?: IJavaScriptEvaluateInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.expression = _data['expression'];
      }
   }

   static fromJS(data: any): JavaScriptEvaluateInput {
      data = typeof data === 'object' ? data : {};
      let result = new JavaScriptEvaluateInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['expression'] = this.expression;
      return data;
   }

   clone(): JavaScriptEvaluateInput {
      const json = this.toJSON();
      let result = new JavaScriptEvaluateInput();
      result.init(json);
      return result;
   }
}

export interface IJavaScriptEvaluateInput {
   /** JavaScript表达式 */
   expression: string | undefined;
}

export class JavaScriptInvokeMethodInput implements IJavaScriptInvokeMethodInput {
   /** JavaScript代码 */
   expression: string | undefined;
   /** 需执行的函数名 */
   methodName: string | undefined;

   constructor(data?: IJavaScriptInvokeMethodInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.expression = _data['expression'];
         this.methodName = _data['methodName'];
      }
   }

   static fromJS(data: any): JavaScriptInvokeMethodInput {
      data = typeof data === 'object' ? data : {};
      let result = new JavaScriptInvokeMethodInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['expression'] = this.expression;
      data['methodName'] = this.methodName;
      return data;
   }

   clone(): JavaScriptInvokeMethodInput {
      const json = this.toJSON();
      let result = new JavaScriptInvokeMethodInput();
      result.init(json);
      return result;
   }
}

export interface IJavaScriptInvokeMethodInput {
   /** JavaScript代码 */
   expression: string | undefined;
   /** 需执行的函数名 */
   methodName: string | undefined;
}

export class JavaScriptInvokeMethodWithGlobalFieldsInput implements IJavaScriptInvokeMethodWithGlobalFieldsInput {
   /** JavaScript代码 */
   expression: string | undefined;
   /** 需执行的函数名 */
   methodName: string | undefined;
   /** 全局字段字典 */
   globalFieldsJson: string | undefined;

   constructor(data?: IJavaScriptInvokeMethodWithGlobalFieldsInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.expression = _data['expression'];
         this.methodName = _data['methodName'];
         this.globalFieldsJson = _data['globalFieldsJson'];
      }
   }

   static fromJS(data: any): JavaScriptInvokeMethodWithGlobalFieldsInput {
      data = typeof data === 'object' ? data : {};
      let result = new JavaScriptInvokeMethodWithGlobalFieldsInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['expression'] = this.expression;
      data['methodName'] = this.methodName;
      data['globalFieldsJson'] = this.globalFieldsJson;
      return data;
   }

   clone(): JavaScriptInvokeMethodWithGlobalFieldsInput {
      const json = this.toJSON();
      let result = new JavaScriptInvokeMethodWithGlobalFieldsInput();
      result.init(json);
      return result;
   }
}

export interface IJavaScriptInvokeMethodWithGlobalFieldsInput {
   /** JavaScript代码 */
   expression: string | undefined;
   /** 需执行的函数名 */
   methodName: string | undefined;
   /** 全局字段字典 */
   globalFieldsJson: string | undefined;
}

export class OrderTest implements IOrderTest {
   /** 名称 */
   code: string | undefined;
   /** 名称 */
   name: string | undefined;
   id: string | undefined;

   constructor(data?: IOrderTest) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.code = _data['code'];
         this.name = _data['name'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): OrderTest {
      data = typeof data === 'object' ? data : {};
      let result = new OrderTest();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['code'] = this.code;
      data['name'] = this.name;
      data['id'] = this.id;
      return data;
   }

   clone(): OrderTest {
      const json = this.toJSON();
      let result = new OrderTest();
      result.init(json);
      return result;
   }
}

export interface IOrderTest {
   /** 名称 */
   code: string | undefined;
   /** 名称 */
   name: string | undefined;
   id: string | undefined;
}

export class EditDicDetailInput implements IEditDicDetailInput {
   /** 字典键 */
   key: string;
   /** 字典值 */
   value: string | undefined;
   /** 名称 */
   name: string | undefined;
   /** 排序用的序号 */
   sequenceNumber: number;

   constructor(data?: IEditDicDetailInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.key = _data['key'];
         this.value = _data['value'];
         this.name = _data['name'];
         this.sequenceNumber = _data['sequenceNumber'];
      }
   }

   static fromJS(data: any): EditDicDetailInput {
      data = typeof data === 'object' ? data : {};
      let result = new EditDicDetailInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['key'] = this.key;
      data['value'] = this.value;
      data['name'] = this.name;
      data['sequenceNumber'] = this.sequenceNumber;
      return data;
   }

   clone(): EditDicDetailInput {
      const json = this.toJSON();
      let result = new EditDicDetailInput();
      result.init(json);
      return result;
   }
}

export interface IEditDicDetailInput {
   /** 字典键 */
   key: string;
   /** 字典值 */
   value: string | undefined;
   /** 名称 */
   name: string | undefined;
   /** 排序用的序号 */
   sequenceNumber: number;
}

export class CreateOrUpdateDicInput implements ICreateOrUpdateDicInput {
   code: string;
   name: string;
   details: EditDicDetailInput[] | undefined;

   constructor(data?: ICreateOrUpdateDicInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.code = _data['code'];
         this.name = _data['name'];
         if (Array.isArray(_data['details'])) {
            this.details = [] as any;
            for (let item of _data['details']) this.details.push(EditDicDetailInput.fromJS(item));
         }
      }
   }

   static fromJS(data: any): CreateOrUpdateDicInput {
      data = typeof data === 'object' ? data : {};
      let result = new CreateOrUpdateDicInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['code'] = this.code;
      data['name'] = this.name;
      if (Array.isArray(this.details)) {
         data['details'] = [];
         for (let item of this.details) data['details'].push(item.toJSON());
      }
      return data;
   }

   clone(): CreateOrUpdateDicInput {
      const json = this.toJSON();
      let result = new CreateOrUpdateDicInput();
      result.init(json);
      return result;
   }
}

export interface ICreateOrUpdateDicInput {
   code: string;
   name: string;
   details: EditDicDetailInput[] | undefined;
}

export class DicDetailCacheItem implements IDicDetailCacheItem {
   /** 字典键 */
   key: string | undefined;
   /** 字典值 */
   value: string | undefined;
   /** 名称 */
   name: string | undefined;
   /** 排序用的序号 */
   sequenceNumber: number;

   constructor(data?: IDicDetailCacheItem) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.key = _data['key'];
         this.value = _data['value'];
         this.name = _data['name'];
         this.sequenceNumber = _data['sequenceNumber'];
      }
   }

   static fromJS(data: any): DicDetailCacheItem {
      data = typeof data === 'object' ? data : {};
      let result = new DicDetailCacheItem();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['key'] = this.key;
      data['value'] = this.value;
      data['name'] = this.name;
      data['sequenceNumber'] = this.sequenceNumber;
      return data;
   }

   clone(): DicDetailCacheItem {
      const json = this.toJSON();
      let result = new DicDetailCacheItem();
      result.init(json);
      return result;
   }
}

export interface IDicDetailCacheItem {
   /** 字典键 */
   key: string | undefined;
   /** 字典值 */
   value: string | undefined;
   /** 名称 */
   name: string | undefined;
   /** 排序用的序号 */
   sequenceNumber: number;
}

export class DicCacheItem implements IDicCacheItem {
   /** 编码(唯一) */
   code: string | undefined;
   /** 名称 */
   name: string | undefined;
   details: DicDetailCacheItem[] | undefined;

   constructor(data?: IDicCacheItem) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.code = _data['code'];
         this.name = _data['name'];
         if (Array.isArray(_data['details'])) {
            this.details = [] as any;
            for (let item of _data['details']) this.details.push(DicDetailCacheItem.fromJS(item));
         }
      }
   }

   static fromJS(data: any): DicCacheItem {
      data = typeof data === 'object' ? data : {};
      let result = new DicCacheItem();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['code'] = this.code;
      data['name'] = this.name;
      if (Array.isArray(this.details)) {
         data['details'] = [];
         for (let item of this.details) data['details'].push(item.toJSON());
      }
      return data;
   }

   clone(): DicCacheItem {
      const json = this.toJSON();
      let result = new DicCacheItem();
      result.init(json);
      return result;
   }
}

export interface IDicCacheItem {
   /** 编码(唯一) */
   code: string | undefined;
   /** 名称 */
   name: string | undefined;
   details: DicDetailCacheItem[] | undefined;
}

export class DicOutput implements IDicOutput {
   /** 编码(唯一) */
   code: string | undefined;
   /** 名称 */
   name: string | undefined;

   constructor(data?: IDicOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.code = _data['code'];
         this.name = _data['name'];
      }
   }

   static fromJS(data: any): DicOutput {
      data = typeof data === 'object' ? data : {};
      let result = new DicOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['code'] = this.code;
      data['name'] = this.name;
      return data;
   }

   clone(): DicOutput {
      const json = this.toJSON();
      let result = new DicOutput();
      result.init(json);
      return result;
   }
}

export interface IDicOutput {
   /** 编码(唯一) */
   code: string | undefined;
   /** 名称 */
   name: string | undefined;
}

export class DicOutputPagedResultDto implements IDicOutputPagedResultDto {
   totalCount: number;
   items: DicOutput[] | undefined;

   constructor(data?: IDicOutputPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(DicOutput.fromJS(item));
         }
      }
   }

   static fromJS(data: any): DicOutputPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new DicOutputPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): DicOutputPagedResultDto {
      const json = this.toJSON();
      let result = new DicOutputPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IDicOutputPagedResultDto {
   totalCount: number;
   items: DicOutput[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
   id: number | undefined;
   displayName: string;
   monthlyPrice: number | undefined;
   annualPrice: number | undefined;
   trialDayCount: number | undefined;
   waitingDayAfterExpire: number | undefined;
   expiringEditionId: number | undefined;

   constructor(data?: IEditionEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
         this.displayName = _data['displayName'];
         this.monthlyPrice = _data['monthlyPrice'];
         this.annualPrice = _data['annualPrice'];
         this.trialDayCount = _data['trialDayCount'];
         this.waitingDayAfterExpire = _data['waitingDayAfterExpire'];
         this.expiringEditionId = _data['expiringEditionId'];
      }
   }

   static fromJS(data: any): EditionEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new EditionEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['displayName'] = this.displayName;
      data['monthlyPrice'] = this.monthlyPrice;
      data['annualPrice'] = this.annualPrice;
      data['trialDayCount'] = this.trialDayCount;
      data['waitingDayAfterExpire'] = this.waitingDayAfterExpire;
      data['expiringEditionId'] = this.expiringEditionId;
      return data;
   }

   clone(): EditionEditDto {
      const json = this.toJSON();
      let result = new EditionEditDto();
      result.init(json);
      return result;
   }
}

export interface IEditionEditDto {
   id: number | undefined;
   displayName: string;
   monthlyPrice: number | undefined;
   annualPrice: number | undefined;
   trialDayCount: number | undefined;
   waitingDayAfterExpire: number | undefined;
   expiringEditionId: number | undefined;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
   edition: EditionEditDto;
   featureValues: NameValueDto[];

   constructor(data?: ICreateOrUpdateEditionDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.edition = new EditionEditDto();
         this.featureValues = [];
      }
   }

   init(_data?: any) {
      if (_data) {
         this.edition = _data['edition'] ? EditionEditDto.fromJS(_data['edition']) : new EditionEditDto();
         if (Array.isArray(_data['featureValues'])) {
            this.featureValues = [] as any;
            for (let item of _data['featureValues']) this.featureValues.push(NameValueDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): CreateOrUpdateEditionDto {
      data = typeof data === 'object' ? data : {};
      let result = new CreateOrUpdateEditionDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['edition'] = this.edition ? this.edition.toJSON() : <any>undefined;
      if (Array.isArray(this.featureValues)) {
         data['featureValues'] = [];
         for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
      }
      return data;
   }

   clone(): CreateOrUpdateEditionDto {
      const json = this.toJSON();
      let result = new CreateOrUpdateEditionDto();
      result.init(json);
      return result;
   }
}

export interface ICreateOrUpdateEditionDto {
   edition: EditionEditDto;
   featureValues: NameValueDto[];
}

export class IValueValidator implements IIValueValidator {
   readonly name: string | undefined;
   readonly attributes: { [key: string]: any } | undefined;

   constructor(data?: IIValueValidator) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         (<any>this).name = _data['name'];
         if (_data['attributes']) {
            (<any>this).attributes = {} as any;
            for (let key in _data['attributes']) {
               if (_data['attributes'].hasOwnProperty(key)) (<any>this).attributes[key] = _data['attributes'][key];
            }
         }
      }
   }

   static fromJS(data: any): IValueValidator {
      data = typeof data === 'object' ? data : {};
      let result = new IValueValidator();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      if (this.attributes) {
         data['attributes'] = {};
         for (let key in this.attributes) {
            if (this.attributes.hasOwnProperty(key)) data['attributes'][key] = this.attributes[key];
         }
      }
      return data;
   }

   clone(): IValueValidator {
      const json = this.toJSON();
      let result = new IValueValidator();
      result.init(json);
      return result;
   }
}

export interface IIValueValidator {
   name: string | undefined;
   attributes: { [key: string]: any } | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
   value: string | undefined;
   displayText: string | undefined;

   constructor(data?: ILocalizableComboboxItemDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.value = _data['value'];
         this.displayText = _data['displayText'];
      }
   }

   static fromJS(data: any): LocalizableComboboxItemDto {
      data = typeof data === 'object' ? data : {};
      let result = new LocalizableComboboxItemDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['value'] = this.value;
      data['displayText'] = this.displayText;
      return data;
   }

   clone(): LocalizableComboboxItemDto {
      const json = this.toJSON();
      let result = new LocalizableComboboxItemDto();
      result.init(json);
      return result;
   }
}

export interface ILocalizableComboboxItemDto {
   value: string | undefined;
   displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
   items: LocalizableComboboxItemDto[] | undefined;

   constructor(data?: ILocalizableComboboxItemSourceDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(LocalizableComboboxItemDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): LocalizableComboboxItemSourceDto {
      data = typeof data === 'object' ? data : {};
      let result = new LocalizableComboboxItemSourceDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): LocalizableComboboxItemSourceDto {
      const json = this.toJSON();
      let result = new LocalizableComboboxItemSourceDto();
      result.init(json);
      return result;
   }
}

export interface ILocalizableComboboxItemSourceDto {
   items: LocalizableComboboxItemDto[] | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
   name: string | undefined;
   attributes: { [key: string]: any } | undefined;
   validator: IValueValidator;
   itemSource: LocalizableComboboxItemSourceDto;

   constructor(data?: IFeatureInputTypeDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         if (_data['attributes']) {
            this.attributes = {} as any;
            for (let key in _data['attributes']) {
               if (_data['attributes'].hasOwnProperty(key)) this.attributes[key] = _data['attributes'][key];
            }
         }
         this.validator = _data['validator'] ? IValueValidator.fromJS(_data['validator']) : <any>undefined;
         this.itemSource = _data['itemSource'] ? LocalizableComboboxItemSourceDto.fromJS(_data['itemSource']) : <any>undefined;
      }
   }

   static fromJS(data: any): FeatureInputTypeDto {
      data = typeof data === 'object' ? data : {};
      let result = new FeatureInputTypeDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      if (this.attributes) {
         data['attributes'] = {};
         for (let key in this.attributes) {
            if (this.attributes.hasOwnProperty(key)) data['attributes'][key] = this.attributes[key];
         }
      }
      data['validator'] = this.validator ? this.validator.toJSON() : <any>undefined;
      data['itemSource'] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
      return data;
   }

   clone(): FeatureInputTypeDto {
      const json = this.toJSON();
      let result = new FeatureInputTypeDto();
      result.init(json);
      return result;
   }
}

export interface IFeatureInputTypeDto {
   name: string | undefined;
   attributes: { [key: string]: any } | undefined;
   validator: IValueValidator;
   itemSource: LocalizableComboboxItemSourceDto;
}

export class FlatFeatureDto implements IFlatFeatureDto {
   parentName: string | undefined;
   name: string | undefined;
   displayName: string | undefined;
   description: string | undefined;
   defaultValue: string | undefined;
   inputType: FeatureInputTypeDto;

   constructor(data?: IFlatFeatureDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.parentName = _data['parentName'];
         this.name = _data['name'];
         this.displayName = _data['displayName'];
         this.description = _data['description'];
         this.defaultValue = _data['defaultValue'];
         this.inputType = _data['inputType'] ? FeatureInputTypeDto.fromJS(_data['inputType']) : <any>undefined;
      }
   }

   static fromJS(data: any): FlatFeatureDto {
      data = typeof data === 'object' ? data : {};
      let result = new FlatFeatureDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['parentName'] = this.parentName;
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      data['description'] = this.description;
      data['defaultValue'] = this.defaultValue;
      data['inputType'] = this.inputType ? this.inputType.toJSON() : <any>undefined;
      return data;
   }

   clone(): FlatFeatureDto {
      const json = this.toJSON();
      let result = new FlatFeatureDto();
      result.init(json);
      return result;
   }
}

export interface IFlatFeatureDto {
   parentName: string | undefined;
   name: string | undefined;
   displayName: string | undefined;
   description: string | undefined;
   defaultValue: string | undefined;
   inputType: FeatureInputTypeDto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
   edition: EditionEditDto;
   featureValues: NameValueDto[] | undefined;
   features: FlatFeatureDto[] | undefined;

   constructor(data?: IGetEditionEditOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.edition = _data['edition'] ? EditionEditDto.fromJS(_data['edition']) : <any>undefined;
         if (Array.isArray(_data['featureValues'])) {
            this.featureValues = [] as any;
            for (let item of _data['featureValues']) this.featureValues.push(NameValueDto.fromJS(item));
         }
         if (Array.isArray(_data['features'])) {
            this.features = [] as any;
            for (let item of _data['features']) this.features.push(FlatFeatureDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): GetEditionEditOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetEditionEditOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['edition'] = this.edition ? this.edition.toJSON() : <any>undefined;
      if (Array.isArray(this.featureValues)) {
         data['featureValues'] = [];
         for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
      }
      if (Array.isArray(this.features)) {
         data['features'] = [];
         for (let item of this.features) data['features'].push(item.toJSON());
      }
      return data;
   }

   clone(): GetEditionEditOutput {
      const json = this.toJSON();
      let result = new GetEditionEditOutput();
      result.init(json);
      return result;
   }
}

export interface IGetEditionEditOutput {
   edition: EditionEditDto;
   featureValues: NameValueDto[] | undefined;
   features: FlatFeatureDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
   name: string | undefined;
   displayName: string | undefined;
   creationTime: Date;
   id: number;

   constructor(data?: IEditionListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.displayName = _data['displayName'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): EditionListDto {
      data = typeof data === 'object' ? data : {};
      let result = new EditionListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['id'] = this.id;
      return data;
   }

   clone(): EditionListDto {
      const json = this.toJSON();
      let result = new EditionListDto();
      result.init(json);
      return result;
   }
}

export interface IEditionListDto {
   name: string | undefined;
   displayName: string | undefined;
   creationTime: Date;
   id: number;
}

export class EditionListDtoListResultDto implements IEditionListDtoListResultDto {
   items: EditionListDto[] | undefined;

   constructor(data?: IEditionListDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(EditionListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): EditionListDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new EditionListDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): EditionListDtoListResultDto {
      const json = this.toJSON();
      let result = new EditionListDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface IEditionListDtoListResultDto {
   items: EditionListDto[] | undefined;
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
   sourceEditionId: number;
   targetEditionId: number;

   constructor(data?: IMoveTenantsToAnotherEditionDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.sourceEditionId = _data['sourceEditionId'];
         this.targetEditionId = _data['targetEditionId'];
      }
   }

   static fromJS(data: any): MoveTenantsToAnotherEditionDto {
      data = typeof data === 'object' ? data : {};
      let result = new MoveTenantsToAnotherEditionDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['sourceEditionId'] = this.sourceEditionId;
      data['targetEditionId'] = this.targetEditionId;
      return data;
   }

   clone(): MoveTenantsToAnotherEditionDto {
      const json = this.toJSON();
      let result = new MoveTenantsToAnotherEditionDto();
      result.init(json);
      return result;
   }
}

export interface IMoveTenantsToAnotherEditionDto {
   sourceEditionId: number;
   targetEditionId: number;
}

export class RecurringJobInput implements IRecurringJobInput {
   jobId: string[] | undefined;

   constructor(data?: IRecurringJobInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['jobId'])) {
            this.jobId = [] as any;
            for (let item of _data['jobId']) this.jobId.push(item);
         }
      }
   }

   static fromJS(data: any): RecurringJobInput {
      data = typeof data === 'object' ? data : {};
      let result = new RecurringJobInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.jobId)) {
         data['jobId'] = [];
         for (let item of this.jobId) data['jobId'].push(item);
      }
      return data;
   }

   clone(): RecurringJobInput {
      const json = this.toJSON();
      let result = new RecurringJobInput();
      result.init(json);
      return result;
   }
}

export interface IRecurringJobInput {
   jobId: string[] | undefined;
}

export enum JobState {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
   _5 = 5,
   _6 = 6,
   _7 = 7,
   _8 = 8,
}

export class EnqueuedJobListDto implements IEnqueuedJobListDto {
   key: string | undefined;
   createAt: Date | undefined;
   jobName: string | undefined;
   resultState: string | undefined;

   constructor(data?: IEnqueuedJobListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.key = _data['key'];
         this.createAt = _data['createAt'] ? new Date(_data['createAt'].toString()) : <any>undefined;
         this.jobName = _data['jobName'];
         this.resultState = _data['resultState'];
      }
   }

   static fromJS(data: any): EnqueuedJobListDto {
      data = typeof data === 'object' ? data : {};
      let result = new EnqueuedJobListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['key'] = this.key;
      data['createAt'] = this.createAt ? this.createAt.toISOString() : <any>undefined;
      data['jobName'] = this.jobName;
      data['resultState'] = this.resultState;
      return data;
   }

   clone(): EnqueuedJobListDto {
      const json = this.toJSON();
      let result = new EnqueuedJobListDto();
      result.init(json);
      return result;
   }
}

export interface IEnqueuedJobListDto {
   key: string | undefined;
   createAt: Date | undefined;
   jobName: string | undefined;
   resultState: string | undefined;
}

export class HangFireStorageJob implements IHangFireStorageJob {
   key: string | undefined;
   state: boolean;
   createAt: Date | undefined;
   totalDuration: number | undefined;
   jobName: string | undefined;
   exceptionMessage: string | undefined;
   exceptionType: string | undefined;
   exceptionDetails: string | undefined;
   reson: string | undefined;
   serverId: string | undefined;
   resultState: string | undefined;
   retryAt: Date | undefined;
   enqueueAt: Date | undefined;
   options: string | undefined;
   parentName: string | undefined;
   parentId: string | undefined;
   queueName: string | undefined;
   length: number;
   fetched: number | undefined;
   firstJobs: EnqueuedJobListDto[] | undefined;

   constructor(data?: IHangFireStorageJob) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.key = _data['key'];
         this.state = _data['state'];
         this.createAt = _data['createAt'] ? new Date(_data['createAt'].toString()) : <any>undefined;
         this.totalDuration = _data['totalDuration'];
         this.jobName = _data['jobName'];
         this.exceptionMessage = _data['exceptionMessage'];
         this.exceptionType = _data['exceptionType'];
         this.exceptionDetails = _data['exceptionDetails'];
         this.reson = _data['reson'];
         this.serverId = _data['serverId'];
         this.resultState = _data['resultState'];
         this.retryAt = _data['retryAt'] ? new Date(_data['retryAt'].toString()) : <any>undefined;
         this.enqueueAt = _data['enqueueAt'] ? new Date(_data['enqueueAt'].toString()) : <any>undefined;
         this.options = _data['options'];
         this.parentName = _data['parentName'];
         this.parentId = _data['parentId'];
         this.queueName = _data['queueName'];
         this.length = _data['length'];
         this.fetched = _data['fetched'];
         if (Array.isArray(_data['firstJobs'])) {
            this.firstJobs = [] as any;
            for (let item of _data['firstJobs']) this.firstJobs.push(EnqueuedJobListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): HangFireStorageJob {
      data = typeof data === 'object' ? data : {};
      let result = new HangFireStorageJob();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['key'] = this.key;
      data['state'] = this.state;
      data['createAt'] = this.createAt ? this.createAt.toISOString() : <any>undefined;
      data['totalDuration'] = this.totalDuration;
      data['jobName'] = this.jobName;
      data['exceptionMessage'] = this.exceptionMessage;
      data['exceptionType'] = this.exceptionType;
      data['exceptionDetails'] = this.exceptionDetails;
      data['reson'] = this.reson;
      data['serverId'] = this.serverId;
      data['resultState'] = this.resultState;
      data['retryAt'] = this.retryAt ? this.retryAt.toISOString() : <any>undefined;
      data['enqueueAt'] = this.enqueueAt ? this.enqueueAt.toISOString() : <any>undefined;
      data['options'] = this.options;
      data['parentName'] = this.parentName;
      data['parentId'] = this.parentId;
      data['queueName'] = this.queueName;
      data['length'] = this.length;
      data['fetched'] = this.fetched;
      if (Array.isArray(this.firstJobs)) {
         data['firstJobs'] = [];
         for (let item of this.firstJobs) data['firstJobs'].push(item.toJSON());
      }
      return data;
   }

   clone(): HangFireStorageJob {
      const json = this.toJSON();
      let result = new HangFireStorageJob();
      result.init(json);
      return result;
   }
}

export interface IHangFireStorageJob {
   key: string | undefined;
   state: boolean;
   createAt: Date | undefined;
   totalDuration: number | undefined;
   jobName: string | undefined;
   exceptionMessage: string | undefined;
   exceptionType: string | undefined;
   exceptionDetails: string | undefined;
   reson: string | undefined;
   serverId: string | undefined;
   resultState: string | undefined;
   retryAt: Date | undefined;
   enqueueAt: Date | undefined;
   options: string | undefined;
   parentName: string | undefined;
   parentId: string | undefined;
   queueName: string | undefined;
   length: number;
   fetched: number | undefined;
   firstJobs: EnqueuedJobListDto[] | undefined;
}

export class HangFireStorageJobPagedResultDto implements IHangFireStorageJobPagedResultDto {
   totalCount: number;
   items: HangFireStorageJob[] | undefined;

   constructor(data?: IHangFireStorageJobPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(HangFireStorageJob.fromJS(item));
         }
      }
   }

   static fromJS(data: any): HangFireStorageJobPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new HangFireStorageJobPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): HangFireStorageJobPagedResultDto {
      const json = this.toJSON();
      let result = new HangFireStorageJobPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IHangFireStorageJobPagedResultDto {
   totalCount: number;
   items: HangFireStorageJob[] | undefined;
}

export enum ColumnType {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
}

export class ColumnHeader implements IColumnHeader {
   propertyName: string | undefined;
   columnType: ColumnType;

   constructor(data?: IColumnHeader) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.propertyName = _data['propertyName'];
         this.columnType = _data['columnType'];
      }
   }

   static fromJS(data: any): ColumnHeader {
      data = typeof data === 'object' ? data : {};
      let result = new ColumnHeader();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['propertyName'] = this.propertyName;
      data['columnType'] = this.columnType;
      return data;
   }

   clone(): ColumnHeader {
      const json = this.toJSON();
      let result = new ColumnHeader();
      result.init(json);
      return result;
   }
}

export interface IColumnHeader {
   propertyName: string | undefined;
   columnType: ColumnType;
}

export class RecurringListJobDto implements IRecurringListJobDto {
   recurringJobId: string | undefined;
   cron: string | undefined;
   timeZoneId: string | undefined;
   queue: string | undefined;
   name: string | undefined;
   jobName: string | undefined;
   enable: boolean;
   createdAt: Date | undefined;
   nextExecution: Date | undefined;
   lastJobId: string | undefined;
   lastJobState: string | undefined;
   lastExecution: Date | undefined;

   constructor(data?: IRecurringListJobDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.recurringJobId = _data['recurringJobId'];
         this.cron = _data['cron'];
         this.timeZoneId = _data['timeZoneId'];
         this.queue = _data['queue'];
         this.name = _data['name'];
         this.jobName = _data['jobName'];
         this.enable = _data['enable'];
         this.createdAt = _data['createdAt'] ? new Date(_data['createdAt'].toString()) : <any>undefined;
         this.nextExecution = _data['nextExecution'] ? new Date(_data['nextExecution'].toString()) : <any>undefined;
         this.lastJobId = _data['lastJobId'];
         this.lastJobState = _data['lastJobState'];
         this.lastExecution = _data['lastExecution'] ? new Date(_data['lastExecution'].toString()) : <any>undefined;
      }
   }

   static fromJS(data: any): RecurringListJobDto {
      data = typeof data === 'object' ? data : {};
      let result = new RecurringListJobDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['recurringJobId'] = this.recurringJobId;
      data['cron'] = this.cron;
      data['timeZoneId'] = this.timeZoneId;
      data['queue'] = this.queue;
      data['name'] = this.name;
      data['jobName'] = this.jobName;
      data['enable'] = this.enable;
      data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
      data['nextExecution'] = this.nextExecution ? this.nextExecution.toISOString() : <any>undefined;
      data['lastJobId'] = this.lastJobId;
      data['lastJobState'] = this.lastJobState;
      data['lastExecution'] = this.lastExecution ? this.lastExecution.toISOString() : <any>undefined;
      return data;
   }

   clone(): RecurringListJobDto {
      const json = this.toJSON();
      let result = new RecurringListJobDto();
      result.init(json);
      return result;
   }
}

export interface IRecurringListJobDto {
   recurringJobId: string | undefined;
   cron: string | undefined;
   timeZoneId: string | undefined;
   queue: string | undefined;
   name: string | undefined;
   jobName: string | undefined;
   enable: boolean;
   createdAt: Date | undefined;
   nextExecution: Date | undefined;
   lastJobId: string | undefined;
   lastJobState: string | undefined;
   lastExecution: Date | undefined;
}

export class RecurringListJobDtoPagedResultDto implements IRecurringListJobDtoPagedResultDto {
   totalCount: number;
   items: RecurringListJobDto[] | undefined;

   constructor(data?: IRecurringListJobDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(RecurringListJobDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): RecurringListJobDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new RecurringListJobDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): RecurringListJobDtoPagedResultDto {
      const json = this.toJSON();
      let result = new RecurringListJobDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IRecurringListJobDtoPagedResultDto {
   totalCount: number;
   items: RecurringListJobDto[] | undefined;
}

export class RecurringResultList implements IRecurringResultList {
   columnHeaders: ColumnHeader[] | undefined;
   recurringListJobDtos: RecurringListJobDtoPagedResultDto;

   constructor(data?: IRecurringResultList) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['columnHeaders'])) {
            this.columnHeaders = [] as any;
            for (let item of _data['columnHeaders']) this.columnHeaders.push(ColumnHeader.fromJS(item));
         }
         this.recurringListJobDtos = _data['recurringListJobDtos']
            ? RecurringListJobDtoPagedResultDto.fromJS(_data['recurringListJobDtos'])
            : <any>undefined;
      }
   }

   static fromJS(data: any): RecurringResultList {
      data = typeof data === 'object' ? data : {};
      let result = new RecurringResultList();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.columnHeaders)) {
         data['columnHeaders'] = [];
         for (let item of this.columnHeaders) data['columnHeaders'].push(item.toJSON());
      }
      data['recurringListJobDtos'] = this.recurringListJobDtos ? this.recurringListJobDtos.toJSON() : <any>undefined;
      return data;
   }

   clone(): RecurringResultList {
      const json = this.toJSON();
      let result = new RecurringResultList();
      result.init(json);
      return result;
   }
}

export interface IRecurringResultList {
   columnHeaders: ColumnHeader[] | undefined;
   recurringListJobDtos: RecurringListJobDtoPagedResultDto;
}

export enum SearchTimeType {
   _0 = 0,
   _1 = 1,
   _2 = 2,
}

export class DashboardDataDto implements IDashboardDataDto {
   key: Date;
   value: string | undefined;
   type: string | undefined;

   constructor(data?: IDashboardDataDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.key = _data['key'] ? new Date(_data['key'].toString()) : <any>undefined;
         this.value = _data['value'];
         this.type = _data['type'];
      }
   }

   static fromJS(data: any): DashboardDataDto {
      data = typeof data === 'object' ? data : {};
      let result = new DashboardDataDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['key'] = this.key ? this.key.toISOString() : <any>undefined;
      data['value'] = this.value;
      data['type'] = this.type;
      return data;
   }

   clone(): DashboardDataDto {
      const json = this.toJSON();
      let result = new DashboardDataDto();
      result.init(json);
      return result;
   }
}

export interface IDashboardDataDto {
   key: Date;
   value: string | undefined;
   type: string | undefined;
}

export class DashboardIndexDetailDto implements IDashboardIndexDetailDto {
   dashboardDataDtos: DashboardDataDto[] | undefined;

   constructor(data?: IDashboardIndexDetailDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['dashboardDataDtos'])) {
            this.dashboardDataDtos = [] as any;
            for (let item of _data['dashboardDataDtos']) this.dashboardDataDtos.push(DashboardDataDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): DashboardIndexDetailDto {
      data = typeof data === 'object' ? data : {};
      let result = new DashboardIndexDetailDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.dashboardDataDtos)) {
         data['dashboardDataDtos'] = [];
         for (let item of this.dashboardDataDtos) data['dashboardDataDtos'].push(item.toJSON());
      }
      return data;
   }

   clone(): DashboardIndexDetailDto {
      const json = this.toJSON();
      let result = new DashboardIndexDetailDto();
      result.init(json);
      return result;
   }
}

export interface IDashboardIndexDetailDto {
   dashboardDataDtos: DashboardDataDto[] | undefined;
}

export class StatisticsInfoDto implements IStatisticsInfoDto {
   servers: number;
   recurring: number;
   enqueued: number;
   queues: number;
   scheduled: number;
   processing: number;
   succeeded: number;
   failed: number;
   deleted: number;
   retries: number;
   waiting: number;
   dateValue: string | undefined;

   constructor(data?: IStatisticsInfoDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.servers = _data['servers'];
         this.recurring = _data['recurring'];
         this.enqueued = _data['enqueued'];
         this.queues = _data['queues'];
         this.scheduled = _data['scheduled'];
         this.processing = _data['processing'];
         this.succeeded = _data['succeeded'];
         this.failed = _data['failed'];
         this.deleted = _data['deleted'];
         this.retries = _data['retries'];
         this.waiting = _data['waiting'];
         this.dateValue = _data['dateValue'];
      }
   }

   static fromJS(data: any): StatisticsInfoDto {
      data = typeof data === 'object' ? data : {};
      let result = new StatisticsInfoDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['servers'] = this.servers;
      data['recurring'] = this.recurring;
      data['enqueued'] = this.enqueued;
      data['queues'] = this.queues;
      data['scheduled'] = this.scheduled;
      data['processing'] = this.processing;
      data['succeeded'] = this.succeeded;
      data['failed'] = this.failed;
      data['deleted'] = this.deleted;
      data['retries'] = this.retries;
      data['waiting'] = this.waiting;
      data['dateValue'] = this.dateValue;
      return data;
   }

   clone(): StatisticsInfoDto {
      const json = this.toJSON();
      let result = new StatisticsInfoDto();
      result.init(json);
      return result;
   }
}

export interface IStatisticsInfoDto {
   servers: number;
   recurring: number;
   enqueued: number;
   queues: number;
   scheduled: number;
   processing: number;
   succeeded: number;
   failed: number;
   deleted: number;
   retries: number;
   waiting: number;
   dateValue: string | undefined;
}

export class StateHistoryDto implements IStateHistoryDto {
   stateName: string | undefined;
   reason: string | undefined;
   createdAt: Date;
   data: { [key: string]: string } | undefined;

   constructor(data?: IStateHistoryDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.stateName = _data['stateName'];
         this.reason = _data['reason'];
         this.createdAt = _data['createdAt'] ? new Date(_data['createdAt'].toString()) : <any>undefined;
         if (_data['data']) {
            this.data = {} as any;
            for (let key in _data['data']) {
               if (_data['data'].hasOwnProperty(key)) this.data[key] = _data['data'][key];
            }
         }
      }
   }

   static fromJS(data: any): StateHistoryDto {
      data = typeof data === 'object' ? data : {};
      let result = new StateHistoryDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['stateName'] = this.stateName;
      data['reason'] = this.reason;
      data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
      if (this.data) {
         data['data'] = {};
         for (let key in this.data) {
            if (this.data.hasOwnProperty(key)) data['data'][key] = this.data[key];
         }
      }
      return data;
   }

   clone(): StateHistoryDto {
      const json = this.toJSON();
      let result = new StateHistoryDto();
      result.init(json);
      return result;
   }
}

export interface IStateHistoryDto {
   stateName: string | undefined;
   reason: string | undefined;
   createdAt: Date;
   data: { [key: string]: string } | undefined;
}

export class HangfireJobDetailDto implements IHangfireJobDetailDto {
   createdAt: Date | undefined;
   properties: { [key: string]: string } | undefined;
   history: StateHistoryDto[] | undefined;
   expireAt: Date | undefined;
   jobName: string | undefined;
   namespace: string | undefined;
   className: string | undefined;
   methodName: string | undefined;

   constructor(data?: IHangfireJobDetailDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.createdAt = _data['createdAt'] ? new Date(_data['createdAt'].toString()) : <any>undefined;
         if (_data['properties']) {
            this.properties = {} as any;
            for (let key in _data['properties']) {
               if (_data['properties'].hasOwnProperty(key)) this.properties[key] = _data['properties'][key];
            }
         }
         if (Array.isArray(_data['history'])) {
            this.history = [] as any;
            for (let item of _data['history']) this.history.push(StateHistoryDto.fromJS(item));
         }
         this.expireAt = _data['expireAt'] ? new Date(_data['expireAt'].toString()) : <any>undefined;
         this.jobName = _data['jobName'];
         this.namespace = _data['namespace'];
         this.className = _data['className'];
         this.methodName = _data['methodName'];
      }
   }

   static fromJS(data: any): HangfireJobDetailDto {
      data = typeof data === 'object' ? data : {};
      let result = new HangfireJobDetailDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
      if (this.properties) {
         data['properties'] = {};
         for (let key in this.properties) {
            if (this.properties.hasOwnProperty(key)) data['properties'][key] = this.properties[key];
         }
      }
      if (Array.isArray(this.history)) {
         data['history'] = [];
         for (let item of this.history) data['history'].push(item.toJSON());
      }
      data['expireAt'] = this.expireAt ? this.expireAt.toISOString() : <any>undefined;
      data['jobName'] = this.jobName;
      data['namespace'] = this.namespace;
      data['className'] = this.className;
      data['methodName'] = this.methodName;
      return data;
   }

   clone(): HangfireJobDetailDto {
      const json = this.toJSON();
      let result = new HangfireJobDetailDto();
      result.init(json);
      return result;
   }
}

export interface IHangfireJobDetailDto {
   createdAt: Date | undefined;
   properties: { [key: string]: string } | undefined;
   history: StateHistoryDto[] | undefined;
   expireAt: Date | undefined;
   jobName: string | undefined;
   namespace: string | undefined;
   className: string | undefined;
   methodName: string | undefined;
}

export class RetriesJobListDto implements IRetriesJobListDto {
   jobId: string | undefined;
   state: string | undefined;
   jobName: string | undefined;
   reason: string | undefined;
   retryTime: Date | undefined;
   createdTime: Date | undefined;

   constructor(data?: IRetriesJobListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.jobId = _data['jobId'];
         this.state = _data['state'];
         this.jobName = _data['jobName'];
         this.reason = _data['reason'];
         this.retryTime = _data['retryTime'] ? new Date(_data['retryTime'].toString()) : <any>undefined;
         this.createdTime = _data['createdTime'] ? new Date(_data['createdTime'].toString()) : <any>undefined;
      }
   }

   static fromJS(data: any): RetriesJobListDto {
      data = typeof data === 'object' ? data : {};
      let result = new RetriesJobListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['jobId'] = this.jobId;
      data['state'] = this.state;
      data['jobName'] = this.jobName;
      data['reason'] = this.reason;
      data['retryTime'] = this.retryTime ? this.retryTime.toISOString() : <any>undefined;
      data['createdTime'] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
      return data;
   }

   clone(): RetriesJobListDto {
      const json = this.toJSON();
      let result = new RetriesJobListDto();
      result.init(json);
      return result;
   }
}

export interface IRetriesJobListDto {
   jobId: string | undefined;
   state: string | undefined;
   jobName: string | undefined;
   reason: string | undefined;
   retryTime: Date | undefined;
   createdTime: Date | undefined;
}

export class RetriesJobListDtoPagedResultDto implements IRetriesJobListDtoPagedResultDto {
   totalCount: number;
   items: RetriesJobListDto[] | undefined;

   constructor(data?: IRetriesJobListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(RetriesJobListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): RetriesJobListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new RetriesJobListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): RetriesJobListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new RetriesJobListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IRetriesJobListDtoPagedResultDto {
   totalCount: number;
   items: RetriesJobListDto[] | undefined;
}

export class RetriesResultList implements IRetriesResultList {
   columnHeaders: ColumnHeader[] | undefined;
   retriesJobListDtos: RetriesJobListDtoPagedResultDto;

   constructor(data?: IRetriesResultList) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['columnHeaders'])) {
            this.columnHeaders = [] as any;
            for (let item of _data['columnHeaders']) this.columnHeaders.push(ColumnHeader.fromJS(item));
         }
         this.retriesJobListDtos = _data['retriesJobListDtos'] ? RetriesJobListDtoPagedResultDto.fromJS(_data['retriesJobListDtos']) : <any>undefined;
      }
   }

   static fromJS(data: any): RetriesResultList {
      data = typeof data === 'object' ? data : {};
      let result = new RetriesResultList();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.columnHeaders)) {
         data['columnHeaders'] = [];
         for (let item of this.columnHeaders) data['columnHeaders'].push(item.toJSON());
      }
      data['retriesJobListDtos'] = this.retriesJobListDtos ? this.retriesJobListDtos.toJSON() : <any>undefined;
      return data;
   }

   clone(): RetriesResultList {
      const json = this.toJSON();
      let result = new RetriesResultList();
      result.init(json);
      return result;
   }
}

export interface IRetriesResultList {
   columnHeaders: ColumnHeader[] | undefined;
   retriesJobListDtos: RetriesJobListDtoPagedResultDto;
}

export class HangfireServerListDto implements IHangfireServerListDto {
   name: string | undefined;
   workersCount: number;
   startedAt: Date;
   queues: string[] | undefined;
   heartbeat: Date | undefined;

   constructor(data?: IHangfireServerListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.workersCount = _data['workersCount'];
         this.startedAt = _data['startedAt'] ? new Date(_data['startedAt'].toString()) : <any>undefined;
         if (Array.isArray(_data['queues'])) {
            this.queues = [] as any;
            for (let item of _data['queues']) this.queues.push(item);
         }
         this.heartbeat = _data['heartbeat'] ? new Date(_data['heartbeat'].toString()) : <any>undefined;
      }
   }

   static fromJS(data: any): HangfireServerListDto {
      data = typeof data === 'object' ? data : {};
      let result = new HangfireServerListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['workersCount'] = this.workersCount;
      data['startedAt'] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
      if (Array.isArray(this.queues)) {
         data['queues'] = [];
         for (let item of this.queues) data['queues'].push(item);
      }
      data['heartbeat'] = this.heartbeat ? this.heartbeat.toISOString() : <any>undefined;
      return data;
   }

   clone(): HangfireServerListDto {
      const json = this.toJSON();
      let result = new HangfireServerListDto();
      result.init(json);
      return result;
   }
}

export interface IHangfireServerListDto {
   name: string | undefined;
   workersCount: number;
   startedAt: Date;
   queues: string[] | undefined;
   heartbeat: Date | undefined;
}

export class ServerResultList implements IServerResultList {
   columnHeaders: ColumnHeader[] | undefined;
   hangfireServerListDtos: HangfireServerListDto[] | undefined;

   constructor(data?: IServerResultList) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['columnHeaders'])) {
            this.columnHeaders = [] as any;
            for (let item of _data['columnHeaders']) this.columnHeaders.push(ColumnHeader.fromJS(item));
         }
         if (Array.isArray(_data['hangfireServerListDtos'])) {
            this.hangfireServerListDtos = [] as any;
            for (let item of _data['hangfireServerListDtos']) this.hangfireServerListDtos.push(HangfireServerListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): ServerResultList {
      data = typeof data === 'object' ? data : {};
      let result = new ServerResultList();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.columnHeaders)) {
         data['columnHeaders'] = [];
         for (let item of this.columnHeaders) data['columnHeaders'].push(item.toJSON());
      }
      if (Array.isArray(this.hangfireServerListDtos)) {
         data['hangfireServerListDtos'] = [];
         for (let item of this.hangfireServerListDtos) data['hangfireServerListDtos'].push(item.toJSON());
      }
      return data;
   }

   clone(): ServerResultList {
      const json = this.toJSON();
      let result = new ServerResultList();
      result.init(json);
      return result;
   }
}

export interface IServerResultList {
   columnHeaders: ColumnHeader[] | undefined;
   hangfireServerListDtos: HangfireServerListDto[] | undefined;
}

export class StringEntityDto implements IStringEntityDto {
   id: string | undefined;

   constructor(data?: IStringEntityDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): StringEntityDto {
      data = typeof data === 'object' ? data : {};
      let result = new StringEntityDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      return data;
   }

   clone(): StringEntityDto {
      const json = this.toJSON();
      let result = new StringEntityDto();
      result.init(json);
      return result;
   }
}

export interface IStringEntityDto {
   id: string | undefined;
}

export class HostCacheDto implements IHostCacheDto {
   name: string | undefined;

   constructor(data?: IHostCacheDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
      }
   }

   static fromJS(data: any): HostCacheDto {
      data = typeof data === 'object' ? data : {};
      let result = new HostCacheDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      return data;
   }

   clone(): HostCacheDto {
      const json = this.toJSON();
      let result = new HostCacheDto();
      result.init(json);
      return result;
   }
}

export interface IHostCacheDto {
   name: string | undefined;
}

export class HostCacheDtoListResultDto implements IHostCacheDtoListResultDto {
   items: HostCacheDto[] | undefined;

   constructor(data?: IHostCacheDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(HostCacheDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): HostCacheDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new HostCacheDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): HostCacheDtoListResultDto {
      const json = this.toJSON();
      let result = new HostCacheDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface IHostCacheDtoListResultDto {
   items: HostCacheDto[] | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
   /** 时区 */
   timezone: string | undefined;
   /** 这个字段只用于比较用户的时区与默认时区 */
   timezoneForComparison: string | undefined;

   constructor(data?: IGeneralSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.timezone = _data['timezone'];
         this.timezoneForComparison = _data['timezoneForComparison'];
      }
   }

   static fromJS(data: any): GeneralSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new GeneralSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['timezone'] = this.timezone;
      data['timezoneForComparison'] = this.timezoneForComparison;
      return data;
   }

   clone(): GeneralSettingsEditDto {
      const json = this.toJSON();
      let result = new GeneralSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface IGeneralSettingsEditDto {
   /** 时区 */
   timezone: string | undefined;
   /** 这个字段只用于比较用户的时区与默认时区 */
   timezoneForComparison: string | undefined;
}

export enum ValidateCodeType {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
}

/** 网站全局管理设置 */
export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
   /** 是否必须验证邮箱才能登陆 */
   isEmailConfirmationRequiredForLogin: boolean;
   /** 是否启用短信验证 */
   smsVerificationEnabled: boolean;
   /** 是否启用Cookie内容 */
   isCookieConsentEnabled: boolean;
   /** 宿主用户登陆使用验证码 */
   useCaptchaOnUserLogin: boolean;
   captchaOnUserLoginType: ValidateCodeType;
   /** 宿主用户登陆验证码长度 */
   captchaOnUserLoginLength: number;
   isQuickThemeSelectEnabled: boolean;
   externalLoginProviders: string[] | undefined;

   constructor(data?: IHostUserManagementSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.isEmailConfirmationRequiredForLogin = _data['isEmailConfirmationRequiredForLogin'];
         this.smsVerificationEnabled = _data['smsVerificationEnabled'];
         this.isCookieConsentEnabled = _data['isCookieConsentEnabled'];
         this.useCaptchaOnUserLogin = _data['useCaptchaOnUserLogin'];
         this.captchaOnUserLoginType = _data['captchaOnUserLoginType'];
         this.captchaOnUserLoginLength = _data['captchaOnUserLoginLength'];
         this.isQuickThemeSelectEnabled = _data['isQuickThemeSelectEnabled'];
         if (Array.isArray(_data['externalLoginProviders'])) {
            this.externalLoginProviders = [] as any;
            for (let item of _data['externalLoginProviders']) this.externalLoginProviders.push(item);
         }
      }
   }

   static fromJS(data: any): HostUserManagementSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new HostUserManagementSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['isEmailConfirmationRequiredForLogin'] = this.isEmailConfirmationRequiredForLogin;
      data['smsVerificationEnabled'] = this.smsVerificationEnabled;
      data['isCookieConsentEnabled'] = this.isCookieConsentEnabled;
      data['useCaptchaOnUserLogin'] = this.useCaptchaOnUserLogin;
      data['captchaOnUserLoginType'] = this.captchaOnUserLoginType;
      data['captchaOnUserLoginLength'] = this.captchaOnUserLoginLength;
      data['isQuickThemeSelectEnabled'] = this.isQuickThemeSelectEnabled;
      if (Array.isArray(this.externalLoginProviders)) {
         data['externalLoginProviders'] = [];
         for (let item of this.externalLoginProviders) data['externalLoginProviders'].push(item);
      }
      return data;
   }

   clone(): HostUserManagementSettingsEditDto {
      const json = this.toJSON();
      let result = new HostUserManagementSettingsEditDto();
      result.init(json);
      return result;
   }
}

/** 网站全局管理设置 */
export interface IHostUserManagementSettingsEditDto {
   /** 是否必须验证邮箱才能登陆 */
   isEmailConfirmationRequiredForLogin: boolean;
   /** 是否启用短信验证 */
   smsVerificationEnabled: boolean;
   /** 是否启用Cookie内容 */
   isCookieConsentEnabled: boolean;
   /** 宿主用户登陆使用验证码 */
   useCaptchaOnUserLogin: boolean;
   captchaOnUserLoginType: ValidateCodeType;
   /** 宿主用户登陆验证码长度 */
   captchaOnUserLoginLength: number;
   isQuickThemeSelectEnabled: boolean;
   externalLoginProviders: string[] | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
   /** 默认发件人邮箱地址 */
   defaultFromAddress: string | undefined;
   /** 邮箱显示名称 */
   defaultFromDisplayName: string | undefined;
   /** 发件人邮箱SMTP服务器Host */
   smtpHost: string | undefined;
   /** 发件人邮箱SMTP服务器端口 */
   smtpPort: number;
   /** 发件人校验名称 */
   smtpUserName: string | undefined;
   /** 发件人校验密码 */
   smtpPassword: string | undefined;
   /** 发件人 */
   smtpDomain: string | undefined;
   /** 使用ssl */
   smtpEnableSsl: boolean;
   /** 使用默认凭据 */
   smtpUseDefaultCredentials: boolean;

   constructor(data?: IEmailSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.defaultFromAddress = _data['defaultFromAddress'];
         this.defaultFromDisplayName = _data['defaultFromDisplayName'];
         this.smtpHost = _data['smtpHost'];
         this.smtpPort = _data['smtpPort'];
         this.smtpUserName = _data['smtpUserName'];
         this.smtpPassword = _data['smtpPassword'];
         this.smtpDomain = _data['smtpDomain'];
         this.smtpEnableSsl = _data['smtpEnableSsl'];
         this.smtpUseDefaultCredentials = _data['smtpUseDefaultCredentials'];
      }
   }

   static fromJS(data: any): EmailSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new EmailSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['defaultFromAddress'] = this.defaultFromAddress;
      data['defaultFromDisplayName'] = this.defaultFromDisplayName;
      data['smtpHost'] = this.smtpHost;
      data['smtpPort'] = this.smtpPort;
      data['smtpUserName'] = this.smtpUserName;
      data['smtpPassword'] = this.smtpPassword;
      data['smtpDomain'] = this.smtpDomain;
      data['smtpEnableSsl'] = this.smtpEnableSsl;
      data['smtpUseDefaultCredentials'] = this.smtpUseDefaultCredentials;
      return data;
   }

   clone(): EmailSettingsEditDto {
      const json = this.toJSON();
      let result = new EmailSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface IEmailSettingsEditDto {
   /** 默认发件人邮箱地址 */
   defaultFromAddress: string | undefined;
   /** 邮箱显示名称 */
   defaultFromDisplayName: string | undefined;
   /** 发件人邮箱SMTP服务器Host */
   smtpHost: string | undefined;
   /** 发件人邮箱SMTP服务器端口 */
   smtpPort: number;
   /** 发件人校验名称 */
   smtpUserName: string | undefined;
   /** 发件人校验密码 */
   smtpPassword: string | undefined;
   /** 发件人 */
   smtpDomain: string | undefined;
   /** 使用ssl */
   smtpEnableSsl: boolean;
   /** 使用默认凭据 */
   smtpUseDefaultCredentials: boolean;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
   /** 允许注册 */
   allowSelfRegistration: boolean;
   /** 注册租户默认激活 */
   isNewRegisteredTenantActiveByDefault: boolean;
   /** 宿主租户注册使用验证码 */
   useCaptchaOnTenantRegistration: boolean;
   captchaOnTenantRegistrationType: ValidateCodeType;
   /** 宿主租户注册验证码长度 */
   captchaOnTenantRegistrationLength: number;
   /** 默认版本id */
   defaultEditionId: number | undefined;

   constructor(data?: ITenantManagementSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.allowSelfRegistration = _data['allowSelfRegistration'];
         this.isNewRegisteredTenantActiveByDefault = _data['isNewRegisteredTenantActiveByDefault'];
         this.useCaptchaOnTenantRegistration = _data['useCaptchaOnTenantRegistration'];
         this.captchaOnTenantRegistrationType = _data['captchaOnTenantRegistrationType'];
         this.captchaOnTenantRegistrationLength = _data['captchaOnTenantRegistrationLength'];
         this.defaultEditionId = _data['defaultEditionId'];
      }
   }

   static fromJS(data: any): TenantManagementSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new TenantManagementSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['allowSelfRegistration'] = this.allowSelfRegistration;
      data['isNewRegisteredTenantActiveByDefault'] = this.isNewRegisteredTenantActiveByDefault;
      data['useCaptchaOnTenantRegistration'] = this.useCaptchaOnTenantRegistration;
      data['captchaOnTenantRegistrationType'] = this.captchaOnTenantRegistrationType;
      data['captchaOnTenantRegistrationLength'] = this.captchaOnTenantRegistrationLength;
      data['defaultEditionId'] = this.defaultEditionId;
      return data;
   }

   clone(): TenantManagementSettingsEditDto {
      const json = this.toJSON();
      let result = new TenantManagementSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface ITenantManagementSettingsEditDto {
   /** 允许注册 */
   allowSelfRegistration: boolean;
   /** 注册租户默认激活 */
   isNewRegisteredTenantActiveByDefault: boolean;
   /** 宿主租户注册使用验证码 */
   useCaptchaOnTenantRegistration: boolean;
   captchaOnTenantRegistrationType: ValidateCodeType;
   /** 宿主租户注册验证码长度 */
   captchaOnTenantRegistrationLength: number;
   /** 默认版本id */
   defaultEditionId: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
   /** 必须有数字 */
   requireDigit: boolean;
   /** 必须有小写字母 */
   requireLowercase: boolean;
   /** 需要非字母数字 */
   requireNonAlphanumeric: boolean;
   /** 必须有大写字母 */
   requireUppercase: boolean;
   /** 长度必须大于 */
   requiredLength: number;

   constructor(data?: IPasswordComplexitySetting) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.requireDigit = _data['requireDigit'];
         this.requireLowercase = _data['requireLowercase'];
         this.requireNonAlphanumeric = _data['requireNonAlphanumeric'];
         this.requireUppercase = _data['requireUppercase'];
         this.requiredLength = _data['requiredLength'];
      }
   }

   static fromJS(data: any): PasswordComplexitySetting {
      data = typeof data === 'object' ? data : {};
      let result = new PasswordComplexitySetting();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['requireDigit'] = this.requireDigit;
      data['requireLowercase'] = this.requireLowercase;
      data['requireNonAlphanumeric'] = this.requireNonAlphanumeric;
      data['requireUppercase'] = this.requireUppercase;
      data['requiredLength'] = this.requiredLength;
      return data;
   }

   clone(): PasswordComplexitySetting {
      const json = this.toJSON();
      let result = new PasswordComplexitySetting();
      result.init(json);
      return result;
   }
}

export interface IPasswordComplexitySetting {
   /** 必须有数字 */
   requireDigit: boolean;
   /** 必须有小写字母 */
   requireLowercase: boolean;
   /** 需要非字母数字 */
   requireNonAlphanumeric: boolean;
   /** 必须有大写字母 */
   requireUppercase: boolean;
   /** 长度必须大于 */
   requiredLength: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
   /** 是否启用 */
   isEnabled: boolean;
   /** 登陆校验错误锁定账户最大次数 */
   maxFailedAccessAttemptsBeforeLockout: number;
   /** 默认锁定时间 */
   defaultAccountLockoutSeconds: number;

   constructor(data?: IUserLockOutSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.isEnabled = _data['isEnabled'];
         this.maxFailedAccessAttemptsBeforeLockout = _data['maxFailedAccessAttemptsBeforeLockout'];
         this.defaultAccountLockoutSeconds = _data['defaultAccountLockoutSeconds'];
      }
   }

   static fromJS(data: any): UserLockOutSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserLockOutSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['isEnabled'] = this.isEnabled;
      data['maxFailedAccessAttemptsBeforeLockout'] = this.maxFailedAccessAttemptsBeforeLockout;
      data['defaultAccountLockoutSeconds'] = this.defaultAccountLockoutSeconds;
      return data;
   }

   clone(): UserLockOutSettingsEditDto {
      const json = this.toJSON();
      let result = new UserLockOutSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface IUserLockOutSettingsEditDto {
   /** 是否启用 */
   isEnabled: boolean;
   /** 登陆校验错误锁定账户最大次数 */
   maxFailedAccessAttemptsBeforeLockout: number;
   /** 默认锁定时间 */
   defaultAccountLockoutSeconds: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
   isEnabledForApplication: boolean;
   /** 是否启用 */
   isEnabled: boolean;
   /** 邮箱启用 */
   isEmailProviderEnabled: boolean;
   /** 短信启用 */
   isSmsProviderEnabled: boolean;
   /** 浏览器‘记住我’启用 */
   isRememberBrowserEnabled: boolean;
   /** google校验启用 */
   isGoogleAuthenticatorEnabled: boolean;

   constructor(data?: ITwoFactorLoginSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.isEnabledForApplication = _data['isEnabledForApplication'];
         this.isEnabled = _data['isEnabled'];
         this.isEmailProviderEnabled = _data['isEmailProviderEnabled'];
         this.isSmsProviderEnabled = _data['isSmsProviderEnabled'];
         this.isRememberBrowserEnabled = _data['isRememberBrowserEnabled'];
         this.isGoogleAuthenticatorEnabled = _data['isGoogleAuthenticatorEnabled'];
      }
   }

   static fromJS(data: any): TwoFactorLoginSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new TwoFactorLoginSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['isEnabledForApplication'] = this.isEnabledForApplication;
      data['isEnabled'] = this.isEnabled;
      data['isEmailProviderEnabled'] = this.isEmailProviderEnabled;
      data['isSmsProviderEnabled'] = this.isSmsProviderEnabled;
      data['isRememberBrowserEnabled'] = this.isRememberBrowserEnabled;
      data['isGoogleAuthenticatorEnabled'] = this.isGoogleAuthenticatorEnabled;
      return data;
   }

   clone(): TwoFactorLoginSettingsEditDto {
      const json = this.toJSON();
      let result = new TwoFactorLoginSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface ITwoFactorLoginSettingsEditDto {
   isEnabledForApplication: boolean;
   /** 是否启用 */
   isEnabled: boolean;
   /** 邮箱启用 */
   isEmailProviderEnabled: boolean;
   /** 短信启用 */
   isSmsProviderEnabled: boolean;
   /** 浏览器‘记住我’启用 */
   isRememberBrowserEnabled: boolean;
   /** google校验启用 */
   isGoogleAuthenticatorEnabled: boolean;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
   /** 使用默认密码校验设置 */
   useDefaultPasswordComplexitySettings: boolean;
   passwordComplexity: PasswordComplexitySetting;
   defaultPasswordComplexity: PasswordComplexitySetting;
   userLockOut: UserLockOutSettingsEditDto;
   twoFactorLogin: TwoFactorLoginSettingsEditDto;

   constructor(data?: ISecuritySettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.useDefaultPasswordComplexitySettings = _data['useDefaultPasswordComplexitySettings'];
         this.passwordComplexity = _data['passwordComplexity'] ? PasswordComplexitySetting.fromJS(_data['passwordComplexity']) : <any>undefined;
         this.defaultPasswordComplexity = _data['defaultPasswordComplexity']
            ? PasswordComplexitySetting.fromJS(_data['defaultPasswordComplexity'])
            : <any>undefined;
         this.userLockOut = _data['userLockOut'] ? UserLockOutSettingsEditDto.fromJS(_data['userLockOut']) : <any>undefined;
         this.twoFactorLogin = _data['twoFactorLogin'] ? TwoFactorLoginSettingsEditDto.fromJS(_data['twoFactorLogin']) : <any>undefined;
      }
   }

   static fromJS(data: any): SecuritySettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new SecuritySettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['useDefaultPasswordComplexitySettings'] = this.useDefaultPasswordComplexitySettings;
      data['passwordComplexity'] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
      data['defaultPasswordComplexity'] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
      data['userLockOut'] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
      data['twoFactorLogin'] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
      return data;
   }

   clone(): SecuritySettingsEditDto {
      const json = this.toJSON();
      let result = new SecuritySettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface ISecuritySettingsEditDto {
   /** 使用默认密码校验设置 */
   useDefaultPasswordComplexitySettings: boolean;
   passwordComplexity: PasswordComplexitySetting;
   defaultPasswordComplexity: PasswordComplexitySetting;
   userLockOut: UserLockOutSettingsEditDto;
   twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
   legalName: string | undefined;
   address: string | undefined;

   constructor(data?: IHostBillingSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.legalName = _data['legalName'];
         this.address = _data['address'];
      }
   }

   static fromJS(data: any): HostBillingSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new HostBillingSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['legalName'] = this.legalName;
      data['address'] = this.address;
      return data;
   }

   clone(): HostBillingSettingsEditDto {
      const json = this.toJSON();
      let result = new HostBillingSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface IHostBillingSettingsEditDto {
   legalName: string | undefined;
   address: string | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
   general: GeneralSettingsEditDto;
   userManagement: HostUserManagementSettingsEditDto;
   email: EmailSettingsEditDto;
   tenantManagement: TenantManagementSettingsEditDto;
   security: SecuritySettingsEditDto;
   billing: HostBillingSettingsEditDto;

   constructor(data?: IHostSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.general = new GeneralSettingsEditDto();
         this.userManagement = new HostUserManagementSettingsEditDto();
         this.email = new EmailSettingsEditDto();
         this.tenantManagement = new TenantManagementSettingsEditDto();
         this.security = new SecuritySettingsEditDto();
      }
   }

   init(_data?: any) {
      if (_data) {
         this.general = _data['general'] ? GeneralSettingsEditDto.fromJS(_data['general']) : new GeneralSettingsEditDto();
         this.userManagement = _data['userManagement']
            ? HostUserManagementSettingsEditDto.fromJS(_data['userManagement'])
            : new HostUserManagementSettingsEditDto();
         this.email = _data['email'] ? EmailSettingsEditDto.fromJS(_data['email']) : new EmailSettingsEditDto();
         this.tenantManagement = _data['tenantManagement']
            ? TenantManagementSettingsEditDto.fromJS(_data['tenantManagement'])
            : new TenantManagementSettingsEditDto();
         this.security = _data['security'] ? SecuritySettingsEditDto.fromJS(_data['security']) : new SecuritySettingsEditDto();
         this.billing = _data['billing'] ? HostBillingSettingsEditDto.fromJS(_data['billing']) : <any>undefined;
      }
   }

   static fromJS(data: any): HostSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new HostSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['general'] = this.general ? this.general.toJSON() : <any>undefined;
      data['userManagement'] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
      data['email'] = this.email ? this.email.toJSON() : <any>undefined;
      data['tenantManagement'] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
      data['security'] = this.security ? this.security.toJSON() : <any>undefined;
      data['billing'] = this.billing ? this.billing.toJSON() : <any>undefined;
      return data;
   }

   clone(): HostSettingsEditDto {
      const json = this.toJSON();
      let result = new HostSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface IHostSettingsEditDto {
   general: GeneralSettingsEditDto;
   userManagement: HostUserManagementSettingsEditDto;
   email: EmailSettingsEditDto;
   tenantManagement: TenantManagementSettingsEditDto;
   security: SecuritySettingsEditDto;
   billing: HostBillingSettingsEditDto;
}

export class SendTestEmailInput implements ISendTestEmailInput {
   /** 邮箱地址 */
   emailAddress: string;

   constructor(data?: ISendTestEmailInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.emailAddress = _data['emailAddress'];
      }
   }

   static fromJS(data: any): SendTestEmailInput {
      data = typeof data === 'object' ? data : {};
      let result = new SendTestEmailInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['emailAddress'] = this.emailAddress;
      return data;
   }

   clone(): SendTestEmailInput {
      const json = this.toJSON();
      let result = new SendTestEmailInput();
      result.init(json);
      return result;
   }
}

export interface ISendTestEmailInput {
   /** 邮箱地址 */
   emailAddress: string;
}

export class ImportUserDto implements IImportUserDto {
   name: string | undefined;
   surname: string | undefined;
   userName: string | undefined;
   emailAddress: string | undefined;
   phoneNumber: string | undefined;
   password: string | undefined;
   /** comma separated list */
   assignedRoleNames: string[] | undefined;
   /** Can be set when reading data from excel or when importing user */
   exception: string | undefined;

   constructor(data?: IImportUserDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.surname = _data['surname'];
         this.userName = _data['userName'];
         this.emailAddress = _data['emailAddress'];
         this.phoneNumber = _data['phoneNumber'];
         this.password = _data['password'];
         if (Array.isArray(_data['assignedRoleNames'])) {
            this.assignedRoleNames = [] as any;
            for (let item of _data['assignedRoleNames']) this.assignedRoleNames.push(item);
         }
         this.exception = _data['exception'];
      }
   }

   static fromJS(data: any): ImportUserDto {
      data = typeof data === 'object' ? data : {};
      let result = new ImportUserDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['surname'] = this.surname;
      data['userName'] = this.userName;
      data['emailAddress'] = this.emailAddress;
      data['phoneNumber'] = this.phoneNumber;
      data['password'] = this.password;
      if (Array.isArray(this.assignedRoleNames)) {
         data['assignedRoleNames'] = [];
         for (let item of this.assignedRoleNames) data['assignedRoleNames'].push(item);
      }
      data['exception'] = this.exception;
      return data;
   }

   clone(): ImportUserDto {
      const json = this.toJSON();
      let result = new ImportUserDto();
      result.init(json);
      return result;
   }
}

export interface IImportUserDto {
   name: string | undefined;
   surname: string | undefined;
   userName: string | undefined;
   emailAddress: string | undefined;
   phoneNumber: string | undefined;
   password: string | undefined;
   /** comma separated list */
   assignedRoleNames: string[] | undefined;
   /** Can be set when reading data from excel or when importing user */
   exception: string | undefined;
}

export class LanguageEditDto implements ILanguageEditDto {
   id: number | undefined;
   name: string;
   icon: string | undefined;
   isEnabled: boolean;

   constructor(data?: ILanguageEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
         this.name = _data['name'];
         this.icon = _data['icon'];
         this.isEnabled = _data['isEnabled'];
      }
   }

   static fromJS(data: any): LanguageEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new LanguageEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['name'] = this.name;
      data['icon'] = this.icon;
      data['isEnabled'] = this.isEnabled;
      return data;
   }

   clone(): LanguageEditDto {
      const json = this.toJSON();
      let result = new LanguageEditDto();
      result.init(json);
      return result;
   }
}

export interface ILanguageEditDto {
   id: number | undefined;
   name: string;
   icon: string | undefined;
   isEnabled: boolean;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
   language: LanguageEditDto;

   constructor(data?: ICreateOrUpdateLanguageInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.language = new LanguageEditDto();
      }
   }

   init(_data?: any) {
      if (_data) {
         this.language = _data['language'] ? LanguageEditDto.fromJS(_data['language']) : new LanguageEditDto();
      }
   }

   static fromJS(data: any): CreateOrUpdateLanguageInput {
      data = typeof data === 'object' ? data : {};
      let result = new CreateOrUpdateLanguageInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['language'] = this.language ? this.language.toJSON() : <any>undefined;
      return data;
   }

   clone(): CreateOrUpdateLanguageInput {
      const json = this.toJSON();
      let result = new CreateOrUpdateLanguageInput();
      result.init(json);
      return result;
   }
}

export interface ICreateOrUpdateLanguageInput {
   language: LanguageEditDto;
}

export class ComboboxItemDto implements IComboboxItemDto {
   value: string | undefined;
   displayText: string | undefined;
   isSelected: boolean;

   constructor(data?: IComboboxItemDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.value = _data['value'];
         this.displayText = _data['displayText'];
         this.isSelected = _data['isSelected'];
      }
   }

   static fromJS(data: any): ComboboxItemDto {
      data = typeof data === 'object' ? data : {};
      let result = new ComboboxItemDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['value'] = this.value;
      data['displayText'] = this.displayText;
      data['isSelected'] = this.isSelected;
      return data;
   }

   clone(): ComboboxItemDto {
      const json = this.toJSON();
      let result = new ComboboxItemDto();
      result.init(json);
      return result;
   }
}

export interface IComboboxItemDto {
   value: string | undefined;
   displayText: string | undefined;
   isSelected: boolean;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
   language: LanguageEditDto;
   /** 所有的语言名称 */
   languageNames: ComboboxItemDto[] | undefined;
   /** 所有的国旗 */
   flags: ComboboxItemDto[] | undefined;

   constructor(data?: IGetLanguageForEditOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.language = _data['language'] ? LanguageEditDto.fromJS(_data['language']) : <any>undefined;
         if (Array.isArray(_data['languageNames'])) {
            this.languageNames = [] as any;
            for (let item of _data['languageNames']) this.languageNames.push(ComboboxItemDto.fromJS(item));
         }
         if (Array.isArray(_data['flags'])) {
            this.flags = [] as any;
            for (let item of _data['flags']) this.flags.push(ComboboxItemDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): GetLanguageForEditOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetLanguageForEditOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['language'] = this.language ? this.language.toJSON() : <any>undefined;
      if (Array.isArray(this.languageNames)) {
         data['languageNames'] = [];
         for (let item of this.languageNames) data['languageNames'].push(item.toJSON());
      }
      if (Array.isArray(this.flags)) {
         data['flags'] = [];
         for (let item of this.flags) data['flags'].push(item.toJSON());
      }
      return data;
   }

   clone(): GetLanguageForEditOutput {
      const json = this.toJSON();
      let result = new GetLanguageForEditOutput();
      result.init(json);
      return result;
   }
}

export interface IGetLanguageForEditOutput {
   language: LanguageEditDto;
   /** 所有的语言名称 */
   languageNames: ComboboxItemDto[] | undefined;
   /** 所有的国旗 */
   flags: ComboboxItemDto[] | undefined;
}

export class LanguageListDto implements ILanguageListDto {
   tenantId: number | undefined;
   /** 名称 */
   name: string | undefined;
   /** 显示名称 */
   displayName: string | undefined;
   /** 图标 */
   icon: string | undefined;
   /** 是否禁用 */
   isDisabled: boolean;
   isDeleted: boolean;
   deleterUserId: number | undefined;
   deletionTime: Date | undefined;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;

   constructor(data?: ILanguageListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.name = _data['name'];
         this.displayName = _data['displayName'];
         this.icon = _data['icon'];
         this.isDisabled = _data['isDisabled'];
         this.isDeleted = _data['isDeleted'];
         this.deleterUserId = _data['deleterUserId'];
         this.deletionTime = _data['deletionTime'] ? new Date(_data['deletionTime'].toString()) : <any>undefined;
         this.lastModificationTime = _data['lastModificationTime'] ? new Date(_data['lastModificationTime'].toString()) : <any>undefined;
         this.lastModifierUserId = _data['lastModifierUserId'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.creatorUserId = _data['creatorUserId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): LanguageListDto {
      data = typeof data === 'object' ? data : {};
      let result = new LanguageListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      data['icon'] = this.icon;
      data['isDisabled'] = this.isDisabled;
      data['isDeleted'] = this.isDeleted;
      data['deleterUserId'] = this.deleterUserId;
      data['deletionTime'] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
      data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
      data['lastModifierUserId'] = this.lastModifierUserId;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['creatorUserId'] = this.creatorUserId;
      data['id'] = this.id;
      return data;
   }

   clone(): LanguageListDto {
      const json = this.toJSON();
      let result = new LanguageListDto();
      result.init(json);
      return result;
   }
}

export interface ILanguageListDto {
   tenantId: number | undefined;
   /** 名称 */
   name: string | undefined;
   /** 显示名称 */
   displayName: string | undefined;
   /** 图标 */
   icon: string | undefined;
   /** 是否禁用 */
   isDisabled: boolean;
   isDeleted: boolean;
   deleterUserId: number | undefined;
   deletionTime: Date | undefined;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
   /** 默认语言名称 */
   defaultLanguageName: string | undefined;
   items: LanguageListDto[] | undefined;

   constructor(data?: IGetLanguagesOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.defaultLanguageName = _data['defaultLanguageName'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(LanguageListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): GetLanguagesOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetLanguagesOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['defaultLanguageName'] = this.defaultLanguageName;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): GetLanguagesOutput {
      const json = this.toJSON();
      let result = new GetLanguagesOutput();
      result.init(json);
      return result;
   }
}

export interface IGetLanguagesOutput {
   /** 默认语言名称 */
   defaultLanguageName: string | undefined;
   items: LanguageListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
   /** 键 */
   key: string | undefined;
   /** 原始值 */
   baseValue: string | undefined;
   /** 目标值 */
   targetValue: string | undefined;

   constructor(data?: ILanguageTextListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.key = _data['key'];
         this.baseValue = _data['baseValue'];
         this.targetValue = _data['targetValue'];
      }
   }

   static fromJS(data: any): LanguageTextListDto {
      data = typeof data === 'object' ? data : {};
      let result = new LanguageTextListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['key'] = this.key;
      data['baseValue'] = this.baseValue;
      data['targetValue'] = this.targetValue;
      return data;
   }

   clone(): LanguageTextListDto {
      const json = this.toJSON();
      let result = new LanguageTextListDto();
      result.init(json);
      return result;
   }
}

export interface ILanguageTextListDto {
   /** 键 */
   key: string | undefined;
   /** 原始值 */
   baseValue: string | undefined;
   /** 目标值 */
   targetValue: string | undefined;
}

export class LanguageTextListDtoPagedResultDto implements ILanguageTextListDtoPagedResultDto {
   totalCount: number;
   items: LanguageTextListDto[] | undefined;

   constructor(data?: ILanguageTextListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(LanguageTextListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): LanguageTextListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new LanguageTextListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): LanguageTextListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new LanguageTextListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface ILanguageTextListDtoPagedResultDto {
   totalCount: number;
   items: LanguageTextListDto[] | undefined;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
   name: string;

   constructor(data?: ISetDefaultLanguageInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
      }
   }

   static fromJS(data: any): SetDefaultLanguageInput {
      data = typeof data === 'object' ? data : {};
      let result = new SetDefaultLanguageInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      return data;
   }

   clone(): SetDefaultLanguageInput {
      const json = this.toJSON();
      let result = new SetDefaultLanguageInput();
      result.init(json);
      return result;
   }
}

export interface ISetDefaultLanguageInput {
   name: string;
}

/** 更新语言输入信息 */
export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
   languageName: string;
   sourceName: string;
   /** 键 */
   key: string;
   /** 值 */
   value: string;

   constructor(data?: IUpdateLanguageTextInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.languageName = _data['languageName'];
         this.sourceName = _data['sourceName'];
         this.key = _data['key'];
         this.value = _data['value'];
      }
   }

   static fromJS(data: any): UpdateLanguageTextInput {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateLanguageTextInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['languageName'] = this.languageName;
      data['sourceName'] = this.sourceName;
      data['key'] = this.key;
      data['value'] = this.value;
      return data;
   }

   clone(): UpdateLanguageTextInput {
      const json = this.toJSON();
      let result = new UpdateLanguageTextInput();
      result.init(json);
      return result;
   }
}

/** 更新语言输入信息 */
export interface IUpdateLanguageTextInput {
   languageName: string;
   sourceName: string;
   /** 键 */
   key: string;
   /** 值 */
   value: string;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
   displayName: string | undefined;
   description: string | undefined;
   name: string;
   isSubscribed: boolean;

   constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.displayName = _data['displayName'];
         this.description = _data['description'];
         this.name = _data['name'];
         this.isSubscribed = _data['isSubscribed'];
      }
   }

   static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
      data = typeof data === 'object' ? data : {};
      let result = new NotificationSubscriptionWithDisplayNameDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['displayName'] = this.displayName;
      data['description'] = this.description;
      data['name'] = this.name;
      data['isSubscribed'] = this.isSubscribed;
      return data;
   }

   clone(): NotificationSubscriptionWithDisplayNameDto {
      const json = this.toJSON();
      let result = new NotificationSubscriptionWithDisplayNameDto();
      result.init(json);
      return result;
   }
}

export interface INotificationSubscriptionWithDisplayNameDto {
   displayName: string | undefined;
   description: string | undefined;
   name: string;
   isSubscribed: boolean;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
   receiveNotifications: boolean;
   notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;

   constructor(data?: IGetNotificationSettingsOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.receiveNotifications = _data['receiveNotifications'];
         if (Array.isArray(_data['notifications'])) {
            this.notifications = [] as any;
            for (let item of _data['notifications']) this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): GetNotificationSettingsOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetNotificationSettingsOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['receiveNotifications'] = this.receiveNotifications;
      if (Array.isArray(this.notifications)) {
         data['notifications'] = [];
         for (let item of this.notifications) data['notifications'].push(item.toJSON());
      }
      return data;
   }

   clone(): GetNotificationSettingsOutput {
      const json = this.toJSON();
      let result = new GetNotificationSettingsOutput();
      result.init(json);
      return result;
   }
}

export interface IGetNotificationSettingsOutput {
   receiveNotifications: boolean;
   notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export enum UserNotificationState {
   _0 = 0,
   _1 = 1,
}

export class NotificationData implements INotificationData {
   readonly type: string | undefined;
   properties: { [key: string]: any } | undefined;

   constructor(data?: INotificationData) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         (<any>this).type = _data['type'];
         if (_data['properties']) {
            this.properties = {} as any;
            for (let key in _data['properties']) {
               if (_data['properties'].hasOwnProperty(key)) this.properties[key] = _data['properties'][key];
            }
         }
      }
   }

   static fromJS(data: any): NotificationData {
      data = typeof data === 'object' ? data : {};
      let result = new NotificationData();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['type'] = this.type;
      if (this.properties) {
         data['properties'] = {};
         for (let key in this.properties) {
            if (this.properties.hasOwnProperty(key)) data['properties'][key] = this.properties[key];
         }
      }
      return data;
   }

   clone(): NotificationData {
      const json = this.toJSON();
      let result = new NotificationData();
      result.init(json);
      return result;
   }
}

export interface INotificationData {
   type: string | undefined;
   properties: { [key: string]: any } | undefined;
}

export enum MemberTypes {
   _1 = 1,
   _2 = 2,
   _4 = 4,
   _8 = 8,
   _16 = 16,
   _32 = 32,
   _64 = 64,
   _128 = 128,
   _191 = 191,
}

export enum MethodAttributes {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
   _5 = 5,
   _6 = 6,
   _7 = 7,
   _8 = 8,
   _16 = 16,
   _32 = 32,
   _64 = 64,
   _128 = 128,
   _256 = 256,
   _512 = 512,
   _1024 = 1024,
   _2048 = 2048,
   _4096 = 4096,
   _8192 = 8192,
   _16384 = 16384,
   _32768 = 32768,
   _53248 = 53248,
}

export enum MethodImplAttributes {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
   _8 = 8,
   _16 = 16,
   _32 = 32,
   _64 = 64,
   _128 = 128,
   _256 = 256,
   _512 = 512,
   _4096 = 4096,
   _65535 = 65535,
}

export enum CallingConventions {
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _32 = 32,
   _64 = 64,
}

export class IntPtr implements IIntPtr {
   constructor(data?: IIntPtr) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {}

   static fromJS(data: any): IntPtr {
      data = typeof data === 'object' ? data : {};
      let result = new IntPtr();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      return data;
   }

   clone(): IntPtr {
      const json = this.toJSON();
      let result = new IntPtr();
      result.init(json);
      return result;
   }
}

export interface IIntPtr {}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
   value: IntPtr;

   constructor(data?: IRuntimeMethodHandle) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.value = _data['value'] ? IntPtr.fromJS(_data['value']) : <any>undefined;
      }
   }

   static fromJS(data: any): RuntimeMethodHandle {
      data = typeof data === 'object' ? data : {};
      let result = new RuntimeMethodHandle();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['value'] = this.value ? this.value.toJSON() : <any>undefined;
      return data;
   }

   clone(): RuntimeMethodHandle {
      const json = this.toJSON();
      let result = new RuntimeMethodHandle();
      result.init(json);
      return result;
   }
}

export interface IRuntimeMethodHandle {
   value: IntPtr;
}

export class ModuleHandle implements IModuleHandle {
   readonly mdStreamVersion: number;

   constructor(data?: IModuleHandle) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         (<any>this).mdStreamVersion = _data['mdStreamVersion'];
      }
   }

   static fromJS(data: any): ModuleHandle {
      data = typeof data === 'object' ? data : {};
      let result = new ModuleHandle();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['mdStreamVersion'] = this.mdStreamVersion;
      return data;
   }

   clone(): ModuleHandle {
      const json = this.toJSON();
      let result = new ModuleHandle();
      result.init(json);
      return result;
   }
}

export interface IModuleHandle {
   mdStreamVersion: number;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
   argumentType: Type;
   readonly value: any | undefined;

   constructor(data?: ICustomAttributeTypedArgument) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.argumentType = _data['argumentType'] ? Type.fromJS(_data['argumentType']) : <any>undefined;
         (<any>this).value = _data['value'];
      }
   }

   static fromJS(data: any): CustomAttributeTypedArgument {
      data = typeof data === 'object' ? data : {};
      let result = new CustomAttributeTypedArgument();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['argumentType'] = this.argumentType ? this.argumentType.toJSON() : <any>undefined;
      data['value'] = this.value;
      return data;
   }

   clone(): CustomAttributeTypedArgument {
      const json = this.toJSON();
      let result = new CustomAttributeTypedArgument();
      result.init(json);
      return result;
   }
}

export interface ICustomAttributeTypedArgument {
   argumentType: Type;
   value: any | undefined;
}

export class MemberInfo implements IMemberInfo {
   memberType: MemberTypes;
   declaringType: Type;
   reflectedType: Type;
   readonly name: string | undefined;
   module: Module;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly isCollectible: boolean;
   readonly metadataToken: number;

   constructor(data?: IMemberInfo) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.memberType = _data['memberType'];
         this.declaringType = _data['declaringType'] ? Type.fromJS(_data['declaringType']) : <any>undefined;
         this.reflectedType = _data['reflectedType'] ? Type.fromJS(_data['reflectedType']) : <any>undefined;
         (<any>this).name = _data['name'];
         this.module = _data['module'] ? Module.fromJS(_data['module']) : <any>undefined;
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): MemberInfo {
      data = typeof data === 'object' ? data : {};
      let result = new MemberInfo();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['memberType'] = this.memberType;
      data['declaringType'] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
      data['reflectedType'] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
      data['name'] = this.name;
      data['module'] = this.module ? this.module.toJSON() : <any>undefined;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['isCollectible'] = this.isCollectible;
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): MemberInfo {
      const json = this.toJSON();
      let result = new MemberInfo();
      result.init(json);
      return result;
   }
}

export interface IMemberInfo {
   memberType: MemberTypes;
   declaringType: Type;
   reflectedType: Type;
   name: string | undefined;
   module: Module;
   customAttributes: CustomAttributeData[] | undefined;
   isCollectible: boolean;
   metadataToken: number;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
   memberInfo: MemberInfo;
   typedValue: CustomAttributeTypedArgument;
   readonly memberName: string | undefined;
   readonly isField: boolean;

   constructor(data?: ICustomAttributeNamedArgument) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.memberInfo = _data['memberInfo'] ? MemberInfo.fromJS(_data['memberInfo']) : <any>undefined;
         this.typedValue = _data['typedValue'] ? CustomAttributeTypedArgument.fromJS(_data['typedValue']) : <any>undefined;
         (<any>this).memberName = _data['memberName'];
         (<any>this).isField = _data['isField'];
      }
   }

   static fromJS(data: any): CustomAttributeNamedArgument {
      data = typeof data === 'object' ? data : {};
      let result = new CustomAttributeNamedArgument();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['memberInfo'] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
      data['typedValue'] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
      data['memberName'] = this.memberName;
      data['isField'] = this.isField;
      return data;
   }

   clone(): CustomAttributeNamedArgument {
      const json = this.toJSON();
      let result = new CustomAttributeNamedArgument();
      result.init(json);
      return result;
   }
}

export interface ICustomAttributeNamedArgument {
   memberInfo: MemberInfo;
   typedValue: CustomAttributeTypedArgument;
   memberName: string | undefined;
   isField: boolean;
}

export class CustomAttributeData implements ICustomAttributeData {
   attributeType: Type;
   constructor_: ConstructorInfo;
   readonly constructorArguments: CustomAttributeTypedArgument[] | undefined;
   readonly namedArguments: CustomAttributeNamedArgument[] | undefined;

   constructor(data?: ICustomAttributeData) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.attributeType = _data['attributeType'] ? Type.fromJS(_data['attributeType']) : <any>undefined;
         this.constructor_ = _data['constructor'] ? ConstructorInfo.fromJS(_data['constructor']) : <any>undefined;
         if (Array.isArray(_data['constructorArguments'])) {
            (<any>this).constructorArguments = [] as any;
            for (let item of _data['constructorArguments']) (<any>this).constructorArguments.push(CustomAttributeTypedArgument.fromJS(item));
         }
         if (Array.isArray(_data['namedArguments'])) {
            (<any>this).namedArguments = [] as any;
            for (let item of _data['namedArguments']) (<any>this).namedArguments.push(CustomAttributeNamedArgument.fromJS(item));
         }
      }
   }

   static fromJS(data: any): CustomAttributeData {
      data = typeof data === 'object' ? data : {};
      let result = new CustomAttributeData();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['attributeType'] = this.attributeType ? this.attributeType.toJSON() : <any>undefined;
      data['constructor'] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
      if (Array.isArray(this.constructorArguments)) {
         data['constructorArguments'] = [];
         for (let item of this.constructorArguments) data['constructorArguments'].push(item.toJSON());
      }
      if (Array.isArray(this.namedArguments)) {
         data['namedArguments'] = [];
         for (let item of this.namedArguments) data['namedArguments'].push(item.toJSON());
      }
      return data;
   }

   clone(): CustomAttributeData {
      const json = this.toJSON();
      let result = new CustomAttributeData();
      result.init(json);
      return result;
   }
}

export interface ICustomAttributeData {
   attributeType: Type;
   constructor_: ConstructorInfo;
   constructorArguments: CustomAttributeTypedArgument[] | undefined;
   namedArguments: CustomAttributeNamedArgument[] | undefined;
}

export class Module implements IModule {
   assembly: Assembly;
   readonly fullyQualifiedName: string | undefined;
   readonly name: string | undefined;
   readonly mdStreamVersion: number;
   readonly moduleVersionId: string;
   readonly scopeName: string | undefined;
   moduleHandle: ModuleHandle;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly metadataToken: number;

   constructor(data?: IModule) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.assembly = _data['assembly'] ? Assembly.fromJS(_data['assembly']) : <any>undefined;
         (<any>this).fullyQualifiedName = _data['fullyQualifiedName'];
         (<any>this).name = _data['name'];
         (<any>this).mdStreamVersion = _data['mdStreamVersion'];
         (<any>this).moduleVersionId = _data['moduleVersionId'];
         (<any>this).scopeName = _data['scopeName'];
         this.moduleHandle = _data['moduleHandle'] ? ModuleHandle.fromJS(_data['moduleHandle']) : <any>undefined;
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): Module {
      data = typeof data === 'object' ? data : {};
      let result = new Module();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['assembly'] = this.assembly ? this.assembly.toJSON() : <any>undefined;
      data['fullyQualifiedName'] = this.fullyQualifiedName;
      data['name'] = this.name;
      data['mdStreamVersion'] = this.mdStreamVersion;
      data['moduleVersionId'] = this.moduleVersionId;
      data['scopeName'] = this.scopeName;
      data['moduleHandle'] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): Module {
      const json = this.toJSON();
      let result = new Module();
      result.init(json);
      return result;
   }
}

export interface IModule {
   assembly: Assembly;
   fullyQualifiedName: string | undefined;
   name: string | undefined;
   mdStreamVersion: number;
   moduleVersionId: string;
   scopeName: string | undefined;
   moduleHandle: ModuleHandle;
   customAttributes: CustomAttributeData[] | undefined;
   metadataToken: number;
}

export class ConstructorInfo implements IConstructorInfo {
   memberType: MemberTypes;
   attributes: MethodAttributes;
   methodImplementationFlags: MethodImplAttributes;
   callingConvention: CallingConventions;
   readonly isAbstract: boolean;
   readonly isConstructor: boolean;
   readonly isFinal: boolean;
   readonly isHideBySig: boolean;
   readonly isSpecialName: boolean;
   readonly isStatic: boolean;
   readonly isVirtual: boolean;
   readonly isAssembly: boolean;
   readonly isFamily: boolean;
   readonly isFamilyAndAssembly: boolean;
   readonly isFamilyOrAssembly: boolean;
   readonly isPrivate: boolean;
   readonly isPublic: boolean;
   readonly isConstructedGenericMethod: boolean;
   readonly isGenericMethod: boolean;
   readonly isGenericMethodDefinition: boolean;
   readonly containsGenericParameters: boolean;
   methodHandle: RuntimeMethodHandle;
   readonly isSecurityCritical: boolean;
   readonly isSecuritySafeCritical: boolean;
   readonly isSecurityTransparent: boolean;
   readonly name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly isCollectible: boolean;
   readonly metadataToken: number;

   constructor(data?: IConstructorInfo) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.memberType = _data['memberType'];
         this.attributes = _data['attributes'];
         this.methodImplementationFlags = _data['methodImplementationFlags'];
         this.callingConvention = _data['callingConvention'];
         (<any>this).isAbstract = _data['isAbstract'];
         (<any>this).isConstructor = _data['isConstructor'];
         (<any>this).isFinal = _data['isFinal'];
         (<any>this).isHideBySig = _data['isHideBySig'];
         (<any>this).isSpecialName = _data['isSpecialName'];
         (<any>this).isStatic = _data['isStatic'];
         (<any>this).isVirtual = _data['isVirtual'];
         (<any>this).isAssembly = _data['isAssembly'];
         (<any>this).isFamily = _data['isFamily'];
         (<any>this).isFamilyAndAssembly = _data['isFamilyAndAssembly'];
         (<any>this).isFamilyOrAssembly = _data['isFamilyOrAssembly'];
         (<any>this).isPrivate = _data['isPrivate'];
         (<any>this).isPublic = _data['isPublic'];
         (<any>this).isConstructedGenericMethod = _data['isConstructedGenericMethod'];
         (<any>this).isGenericMethod = _data['isGenericMethod'];
         (<any>this).isGenericMethodDefinition = _data['isGenericMethodDefinition'];
         (<any>this).containsGenericParameters = _data['containsGenericParameters'];
         this.methodHandle = _data['methodHandle'] ? RuntimeMethodHandle.fromJS(_data['methodHandle']) : <any>undefined;
         (<any>this).isSecurityCritical = _data['isSecurityCritical'];
         (<any>this).isSecuritySafeCritical = _data['isSecuritySafeCritical'];
         (<any>this).isSecurityTransparent = _data['isSecurityTransparent'];
         (<any>this).name = _data['name'];
         this.declaringType = _data['declaringType'] ? Type.fromJS(_data['declaringType']) : <any>undefined;
         this.reflectedType = _data['reflectedType'] ? Type.fromJS(_data['reflectedType']) : <any>undefined;
         this.module = _data['module'] ? Module.fromJS(_data['module']) : <any>undefined;
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): ConstructorInfo {
      data = typeof data === 'object' ? data : {};
      let result = new ConstructorInfo();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['memberType'] = this.memberType;
      data['attributes'] = this.attributes;
      data['methodImplementationFlags'] = this.methodImplementationFlags;
      data['callingConvention'] = this.callingConvention;
      data['isAbstract'] = this.isAbstract;
      data['isConstructor'] = this.isConstructor;
      data['isFinal'] = this.isFinal;
      data['isHideBySig'] = this.isHideBySig;
      data['isSpecialName'] = this.isSpecialName;
      data['isStatic'] = this.isStatic;
      data['isVirtual'] = this.isVirtual;
      data['isAssembly'] = this.isAssembly;
      data['isFamily'] = this.isFamily;
      data['isFamilyAndAssembly'] = this.isFamilyAndAssembly;
      data['isFamilyOrAssembly'] = this.isFamilyOrAssembly;
      data['isPrivate'] = this.isPrivate;
      data['isPublic'] = this.isPublic;
      data['isConstructedGenericMethod'] = this.isConstructedGenericMethod;
      data['isGenericMethod'] = this.isGenericMethod;
      data['isGenericMethodDefinition'] = this.isGenericMethodDefinition;
      data['containsGenericParameters'] = this.containsGenericParameters;
      data['methodHandle'] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
      data['isSecurityCritical'] = this.isSecurityCritical;
      data['isSecuritySafeCritical'] = this.isSecuritySafeCritical;
      data['isSecurityTransparent'] = this.isSecurityTransparent;
      data['name'] = this.name;
      data['declaringType'] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
      data['reflectedType'] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
      data['module'] = this.module ? this.module.toJSON() : <any>undefined;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['isCollectible'] = this.isCollectible;
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): ConstructorInfo {
      const json = this.toJSON();
      let result = new ConstructorInfo();
      result.init(json);
      return result;
   }
}

export interface IConstructorInfo {
   memberType: MemberTypes;
   attributes: MethodAttributes;
   methodImplementationFlags: MethodImplAttributes;
   callingConvention: CallingConventions;
   isAbstract: boolean;
   isConstructor: boolean;
   isFinal: boolean;
   isHideBySig: boolean;
   isSpecialName: boolean;
   isStatic: boolean;
   isVirtual: boolean;
   isAssembly: boolean;
   isFamily: boolean;
   isFamilyAndAssembly: boolean;
   isFamilyOrAssembly: boolean;
   isPrivate: boolean;
   isPublic: boolean;
   isConstructedGenericMethod: boolean;
   isGenericMethod: boolean;
   isGenericMethodDefinition: boolean;
   containsGenericParameters: boolean;
   methodHandle: RuntimeMethodHandle;
   isSecurityCritical: boolean;
   isSecuritySafeCritical: boolean;
   isSecurityTransparent: boolean;
   name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   customAttributes: CustomAttributeData[] | undefined;
   isCollectible: boolean;
   metadataToken: number;
}

export enum EventAttributes {
   _0 = 0,
   _512 = 512,
   _1024 = 1024,
}

export enum ParameterAttributes {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _4 = 4,
   _8 = 8,
   _16 = 16,
   _4096 = 4096,
   _8192 = 8192,
   _16384 = 16384,
   _32768 = 32768,
   _61440 = 61440,
}

export class ParameterInfo implements IParameterInfo {
   attributes: ParameterAttributes;
   member: MemberInfo;
   readonly name: string | undefined;
   parameterType: Type;
   readonly position: number;
   readonly isIn: boolean;
   readonly isLcid: boolean;
   readonly isOptional: boolean;
   readonly isOut: boolean;
   readonly isRetval: boolean;
   readonly defaultValue: any | undefined;
   readonly rawDefaultValue: any | undefined;
   readonly hasDefaultValue: boolean;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly metadataToken: number;

   constructor(data?: IParameterInfo) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.attributes = _data['attributes'];
         this.member = _data['member'] ? MemberInfo.fromJS(_data['member']) : <any>undefined;
         (<any>this).name = _data['name'];
         this.parameterType = _data['parameterType'] ? Type.fromJS(_data['parameterType']) : <any>undefined;
         (<any>this).position = _data['position'];
         (<any>this).isIn = _data['isIn'];
         (<any>this).isLcid = _data['isLcid'];
         (<any>this).isOptional = _data['isOptional'];
         (<any>this).isOut = _data['isOut'];
         (<any>this).isRetval = _data['isRetval'];
         (<any>this).defaultValue = _data['defaultValue'];
         (<any>this).rawDefaultValue = _data['rawDefaultValue'];
         (<any>this).hasDefaultValue = _data['hasDefaultValue'];
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): ParameterInfo {
      data = typeof data === 'object' ? data : {};
      let result = new ParameterInfo();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['attributes'] = this.attributes;
      data['member'] = this.member ? this.member.toJSON() : <any>undefined;
      data['name'] = this.name;
      data['parameterType'] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
      data['position'] = this.position;
      data['isIn'] = this.isIn;
      data['isLcid'] = this.isLcid;
      data['isOptional'] = this.isOptional;
      data['isOut'] = this.isOut;
      data['isRetval'] = this.isRetval;
      data['defaultValue'] = this.defaultValue;
      data['rawDefaultValue'] = this.rawDefaultValue;
      data['hasDefaultValue'] = this.hasDefaultValue;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): ParameterInfo {
      const json = this.toJSON();
      let result = new ParameterInfo();
      result.init(json);
      return result;
   }
}

export interface IParameterInfo {
   attributes: ParameterAttributes;
   member: MemberInfo;
   name: string | undefined;
   parameterType: Type;
   position: number;
   isIn: boolean;
   isLcid: boolean;
   isOptional: boolean;
   isOut: boolean;
   isRetval: boolean;
   defaultValue: any | undefined;
   rawDefaultValue: any | undefined;
   hasDefaultValue: boolean;
   customAttributes: CustomAttributeData[] | undefined;
   metadataToken: number;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {
   constructor(data?: IICustomAttributeProvider) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {}

   static fromJS(data: any): ICustomAttributeProvider {
      data = typeof data === 'object' ? data : {};
      let result = new ICustomAttributeProvider();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      return data;
   }

   clone(): ICustomAttributeProvider {
      const json = this.toJSON();
      let result = new ICustomAttributeProvider();
      result.init(json);
      return result;
   }
}

export interface IICustomAttributeProvider {}

export class MethodInfo implements IMethodInfo {
   memberType: MemberTypes;
   returnParameter: ParameterInfo;
   returnType: Type;
   returnTypeCustomAttributes: ICustomAttributeProvider;
   attributes: MethodAttributes;
   methodImplementationFlags: MethodImplAttributes;
   callingConvention: CallingConventions;
   readonly isAbstract: boolean;
   readonly isConstructor: boolean;
   readonly isFinal: boolean;
   readonly isHideBySig: boolean;
   readonly isSpecialName: boolean;
   readonly isStatic: boolean;
   readonly isVirtual: boolean;
   readonly isAssembly: boolean;
   readonly isFamily: boolean;
   readonly isFamilyAndAssembly: boolean;
   readonly isFamilyOrAssembly: boolean;
   readonly isPrivate: boolean;
   readonly isPublic: boolean;
   readonly isConstructedGenericMethod: boolean;
   readonly isGenericMethod: boolean;
   readonly isGenericMethodDefinition: boolean;
   readonly containsGenericParameters: boolean;
   methodHandle: RuntimeMethodHandle;
   readonly isSecurityCritical: boolean;
   readonly isSecuritySafeCritical: boolean;
   readonly isSecurityTransparent: boolean;
   readonly name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly isCollectible: boolean;
   readonly metadataToken: number;

   constructor(data?: IMethodInfo) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.memberType = _data['memberType'];
         this.returnParameter = _data['returnParameter'] ? ParameterInfo.fromJS(_data['returnParameter']) : <any>undefined;
         this.returnType = _data['returnType'] ? Type.fromJS(_data['returnType']) : <any>undefined;
         this.returnTypeCustomAttributes = _data['returnTypeCustomAttributes']
            ? ICustomAttributeProvider.fromJS(_data['returnTypeCustomAttributes'])
            : <any>undefined;
         this.attributes = _data['attributes'];
         this.methodImplementationFlags = _data['methodImplementationFlags'];
         this.callingConvention = _data['callingConvention'];
         (<any>this).isAbstract = _data['isAbstract'];
         (<any>this).isConstructor = _data['isConstructor'];
         (<any>this).isFinal = _data['isFinal'];
         (<any>this).isHideBySig = _data['isHideBySig'];
         (<any>this).isSpecialName = _data['isSpecialName'];
         (<any>this).isStatic = _data['isStatic'];
         (<any>this).isVirtual = _data['isVirtual'];
         (<any>this).isAssembly = _data['isAssembly'];
         (<any>this).isFamily = _data['isFamily'];
         (<any>this).isFamilyAndAssembly = _data['isFamilyAndAssembly'];
         (<any>this).isFamilyOrAssembly = _data['isFamilyOrAssembly'];
         (<any>this).isPrivate = _data['isPrivate'];
         (<any>this).isPublic = _data['isPublic'];
         (<any>this).isConstructedGenericMethod = _data['isConstructedGenericMethod'];
         (<any>this).isGenericMethod = _data['isGenericMethod'];
         (<any>this).isGenericMethodDefinition = _data['isGenericMethodDefinition'];
         (<any>this).containsGenericParameters = _data['containsGenericParameters'];
         this.methodHandle = _data['methodHandle'] ? RuntimeMethodHandle.fromJS(_data['methodHandle']) : <any>undefined;
         (<any>this).isSecurityCritical = _data['isSecurityCritical'];
         (<any>this).isSecuritySafeCritical = _data['isSecuritySafeCritical'];
         (<any>this).isSecurityTransparent = _data['isSecurityTransparent'];
         (<any>this).name = _data['name'];
         this.declaringType = _data['declaringType'] ? Type.fromJS(_data['declaringType']) : <any>undefined;
         this.reflectedType = _data['reflectedType'] ? Type.fromJS(_data['reflectedType']) : <any>undefined;
         this.module = _data['module'] ? Module.fromJS(_data['module']) : <any>undefined;
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): MethodInfo {
      data = typeof data === 'object' ? data : {};
      let result = new MethodInfo();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['memberType'] = this.memberType;
      data['returnParameter'] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
      data['returnType'] = this.returnType ? this.returnType.toJSON() : <any>undefined;
      data['returnTypeCustomAttributes'] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
      data['attributes'] = this.attributes;
      data['methodImplementationFlags'] = this.methodImplementationFlags;
      data['callingConvention'] = this.callingConvention;
      data['isAbstract'] = this.isAbstract;
      data['isConstructor'] = this.isConstructor;
      data['isFinal'] = this.isFinal;
      data['isHideBySig'] = this.isHideBySig;
      data['isSpecialName'] = this.isSpecialName;
      data['isStatic'] = this.isStatic;
      data['isVirtual'] = this.isVirtual;
      data['isAssembly'] = this.isAssembly;
      data['isFamily'] = this.isFamily;
      data['isFamilyAndAssembly'] = this.isFamilyAndAssembly;
      data['isFamilyOrAssembly'] = this.isFamilyOrAssembly;
      data['isPrivate'] = this.isPrivate;
      data['isPublic'] = this.isPublic;
      data['isConstructedGenericMethod'] = this.isConstructedGenericMethod;
      data['isGenericMethod'] = this.isGenericMethod;
      data['isGenericMethodDefinition'] = this.isGenericMethodDefinition;
      data['containsGenericParameters'] = this.containsGenericParameters;
      data['methodHandle'] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
      data['isSecurityCritical'] = this.isSecurityCritical;
      data['isSecuritySafeCritical'] = this.isSecuritySafeCritical;
      data['isSecurityTransparent'] = this.isSecurityTransparent;
      data['name'] = this.name;
      data['declaringType'] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
      data['reflectedType'] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
      data['module'] = this.module ? this.module.toJSON() : <any>undefined;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['isCollectible'] = this.isCollectible;
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): MethodInfo {
      const json = this.toJSON();
      let result = new MethodInfo();
      result.init(json);
      return result;
   }
}

export interface IMethodInfo {
   memberType: MemberTypes;
   returnParameter: ParameterInfo;
   returnType: Type;
   returnTypeCustomAttributes: ICustomAttributeProvider;
   attributes: MethodAttributes;
   methodImplementationFlags: MethodImplAttributes;
   callingConvention: CallingConventions;
   isAbstract: boolean;
   isConstructor: boolean;
   isFinal: boolean;
   isHideBySig: boolean;
   isSpecialName: boolean;
   isStatic: boolean;
   isVirtual: boolean;
   isAssembly: boolean;
   isFamily: boolean;
   isFamilyAndAssembly: boolean;
   isFamilyOrAssembly: boolean;
   isPrivate: boolean;
   isPublic: boolean;
   isConstructedGenericMethod: boolean;
   isGenericMethod: boolean;
   isGenericMethodDefinition: boolean;
   containsGenericParameters: boolean;
   methodHandle: RuntimeMethodHandle;
   isSecurityCritical: boolean;
   isSecuritySafeCritical: boolean;
   isSecurityTransparent: boolean;
   name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   customAttributes: CustomAttributeData[] | undefined;
   isCollectible: boolean;
   metadataToken: number;
}

export class EventInfo implements IEventInfo {
   memberType: MemberTypes;
   attributes: EventAttributes;
   readonly isSpecialName: boolean;
   addMethod: MethodInfo;
   removeMethod: MethodInfo;
   raiseMethod: MethodInfo;
   readonly isMulticast: boolean;
   eventHandlerType: Type;
   readonly name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly isCollectible: boolean;
   readonly metadataToken: number;

   constructor(data?: IEventInfo) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.memberType = _data['memberType'];
         this.attributes = _data['attributes'];
         (<any>this).isSpecialName = _data['isSpecialName'];
         this.addMethod = _data['addMethod'] ? MethodInfo.fromJS(_data['addMethod']) : <any>undefined;
         this.removeMethod = _data['removeMethod'] ? MethodInfo.fromJS(_data['removeMethod']) : <any>undefined;
         this.raiseMethod = _data['raiseMethod'] ? MethodInfo.fromJS(_data['raiseMethod']) : <any>undefined;
         (<any>this).isMulticast = _data['isMulticast'];
         this.eventHandlerType = _data['eventHandlerType'] ? Type.fromJS(_data['eventHandlerType']) : <any>undefined;
         (<any>this).name = _data['name'];
         this.declaringType = _data['declaringType'] ? Type.fromJS(_data['declaringType']) : <any>undefined;
         this.reflectedType = _data['reflectedType'] ? Type.fromJS(_data['reflectedType']) : <any>undefined;
         this.module = _data['module'] ? Module.fromJS(_data['module']) : <any>undefined;
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): EventInfo {
      data = typeof data === 'object' ? data : {};
      let result = new EventInfo();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['memberType'] = this.memberType;
      data['attributes'] = this.attributes;
      data['isSpecialName'] = this.isSpecialName;
      data['addMethod'] = this.addMethod ? this.addMethod.toJSON() : <any>undefined;
      data['removeMethod'] = this.removeMethod ? this.removeMethod.toJSON() : <any>undefined;
      data['raiseMethod'] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>undefined;
      data['isMulticast'] = this.isMulticast;
      data['eventHandlerType'] = this.eventHandlerType ? this.eventHandlerType.toJSON() : <any>undefined;
      data['name'] = this.name;
      data['declaringType'] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
      data['reflectedType'] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
      data['module'] = this.module ? this.module.toJSON() : <any>undefined;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['isCollectible'] = this.isCollectible;
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): EventInfo {
      const json = this.toJSON();
      let result = new EventInfo();
      result.init(json);
      return result;
   }
}

export interface IEventInfo {
   memberType: MemberTypes;
   attributes: EventAttributes;
   isSpecialName: boolean;
   addMethod: MethodInfo;
   removeMethod: MethodInfo;
   raiseMethod: MethodInfo;
   isMulticast: boolean;
   eventHandlerType: Type;
   name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   customAttributes: CustomAttributeData[] | undefined;
   isCollectible: boolean;
   metadataToken: number;
}

export enum FieldAttributes {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
   _5 = 5,
   _6 = 6,
   _7 = 7,
   _16 = 16,
   _32 = 32,
   _64 = 64,
   _128 = 128,
   _256 = 256,
   _512 = 512,
   _1024 = 1024,
   _4096 = 4096,
   _8192 = 8192,
   _32768 = 32768,
   _38144 = 38144,
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
   value: IntPtr;

   constructor(data?: IRuntimeFieldHandle) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.value = _data['value'] ? IntPtr.fromJS(_data['value']) : <any>undefined;
      }
   }

   static fromJS(data: any): RuntimeFieldHandle {
      data = typeof data === 'object' ? data : {};
      let result = new RuntimeFieldHandle();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['value'] = this.value ? this.value.toJSON() : <any>undefined;
      return data;
   }

   clone(): RuntimeFieldHandle {
      const json = this.toJSON();
      let result = new RuntimeFieldHandle();
      result.init(json);
      return result;
   }
}

export interface IRuntimeFieldHandle {
   value: IntPtr;
}

export class FieldInfo implements IFieldInfo {
   memberType: MemberTypes;
   attributes: FieldAttributes;
   fieldType: Type;
   readonly isInitOnly: boolean;
   readonly isLiteral: boolean;
   readonly isNotSerialized: boolean;
   readonly isPinvokeImpl: boolean;
   readonly isSpecialName: boolean;
   readonly isStatic: boolean;
   readonly isAssembly: boolean;
   readonly isFamily: boolean;
   readonly isFamilyAndAssembly: boolean;
   readonly isFamilyOrAssembly: boolean;
   readonly isPrivate: boolean;
   readonly isPublic: boolean;
   readonly isSecurityCritical: boolean;
   readonly isSecuritySafeCritical: boolean;
   readonly isSecurityTransparent: boolean;
   fieldHandle: RuntimeFieldHandle;
   readonly name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly isCollectible: boolean;
   readonly metadataToken: number;

   constructor(data?: IFieldInfo) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.memberType = _data['memberType'];
         this.attributes = _data['attributes'];
         this.fieldType = _data['fieldType'] ? Type.fromJS(_data['fieldType']) : <any>undefined;
         (<any>this).isInitOnly = _data['isInitOnly'];
         (<any>this).isLiteral = _data['isLiteral'];
         (<any>this).isNotSerialized = _data['isNotSerialized'];
         (<any>this).isPinvokeImpl = _data['isPinvokeImpl'];
         (<any>this).isSpecialName = _data['isSpecialName'];
         (<any>this).isStatic = _data['isStatic'];
         (<any>this).isAssembly = _data['isAssembly'];
         (<any>this).isFamily = _data['isFamily'];
         (<any>this).isFamilyAndAssembly = _data['isFamilyAndAssembly'];
         (<any>this).isFamilyOrAssembly = _data['isFamilyOrAssembly'];
         (<any>this).isPrivate = _data['isPrivate'];
         (<any>this).isPublic = _data['isPublic'];
         (<any>this).isSecurityCritical = _data['isSecurityCritical'];
         (<any>this).isSecuritySafeCritical = _data['isSecuritySafeCritical'];
         (<any>this).isSecurityTransparent = _data['isSecurityTransparent'];
         this.fieldHandle = _data['fieldHandle'] ? RuntimeFieldHandle.fromJS(_data['fieldHandle']) : <any>undefined;
         (<any>this).name = _data['name'];
         this.declaringType = _data['declaringType'] ? Type.fromJS(_data['declaringType']) : <any>undefined;
         this.reflectedType = _data['reflectedType'] ? Type.fromJS(_data['reflectedType']) : <any>undefined;
         this.module = _data['module'] ? Module.fromJS(_data['module']) : <any>undefined;
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): FieldInfo {
      data = typeof data === 'object' ? data : {};
      let result = new FieldInfo();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['memberType'] = this.memberType;
      data['attributes'] = this.attributes;
      data['fieldType'] = this.fieldType ? this.fieldType.toJSON() : <any>undefined;
      data['isInitOnly'] = this.isInitOnly;
      data['isLiteral'] = this.isLiteral;
      data['isNotSerialized'] = this.isNotSerialized;
      data['isPinvokeImpl'] = this.isPinvokeImpl;
      data['isSpecialName'] = this.isSpecialName;
      data['isStatic'] = this.isStatic;
      data['isAssembly'] = this.isAssembly;
      data['isFamily'] = this.isFamily;
      data['isFamilyAndAssembly'] = this.isFamilyAndAssembly;
      data['isFamilyOrAssembly'] = this.isFamilyOrAssembly;
      data['isPrivate'] = this.isPrivate;
      data['isPublic'] = this.isPublic;
      data['isSecurityCritical'] = this.isSecurityCritical;
      data['isSecuritySafeCritical'] = this.isSecuritySafeCritical;
      data['isSecurityTransparent'] = this.isSecurityTransparent;
      data['fieldHandle'] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>undefined;
      data['name'] = this.name;
      data['declaringType'] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
      data['reflectedType'] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
      data['module'] = this.module ? this.module.toJSON() : <any>undefined;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['isCollectible'] = this.isCollectible;
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): FieldInfo {
      const json = this.toJSON();
      let result = new FieldInfo();
      result.init(json);
      return result;
   }
}

export interface IFieldInfo {
   memberType: MemberTypes;
   attributes: FieldAttributes;
   fieldType: Type;
   isInitOnly: boolean;
   isLiteral: boolean;
   isNotSerialized: boolean;
   isPinvokeImpl: boolean;
   isSpecialName: boolean;
   isStatic: boolean;
   isAssembly: boolean;
   isFamily: boolean;
   isFamilyAndAssembly: boolean;
   isFamilyOrAssembly: boolean;
   isPrivate: boolean;
   isPublic: boolean;
   isSecurityCritical: boolean;
   isSecuritySafeCritical: boolean;
   isSecurityTransparent: boolean;
   fieldHandle: RuntimeFieldHandle;
   name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   customAttributes: CustomAttributeData[] | undefined;
   isCollectible: boolean;
   metadataToken: number;
}

export enum PropertyAttributes {
   _0 = 0,
   _512 = 512,
   _1024 = 1024,
   _4096 = 4096,
   _8192 = 8192,
   _16384 = 16384,
   _32768 = 32768,
   _62464 = 62464,
}

export class PropertyInfo implements IPropertyInfo {
   memberType: MemberTypes;
   propertyType: Type;
   attributes: PropertyAttributes;
   readonly isSpecialName: boolean;
   readonly canRead: boolean;
   readonly canWrite: boolean;
   getMethod: MethodInfo;
   setMethod: MethodInfo;
   readonly name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly isCollectible: boolean;
   readonly metadataToken: number;

   constructor(data?: IPropertyInfo) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.memberType = _data['memberType'];
         this.propertyType = _data['propertyType'] ? Type.fromJS(_data['propertyType']) : <any>undefined;
         this.attributes = _data['attributes'];
         (<any>this).isSpecialName = _data['isSpecialName'];
         (<any>this).canRead = _data['canRead'];
         (<any>this).canWrite = _data['canWrite'];
         this.getMethod = _data['getMethod'] ? MethodInfo.fromJS(_data['getMethod']) : <any>undefined;
         this.setMethod = _data['setMethod'] ? MethodInfo.fromJS(_data['setMethod']) : <any>undefined;
         (<any>this).name = _data['name'];
         this.declaringType = _data['declaringType'] ? Type.fromJS(_data['declaringType']) : <any>undefined;
         this.reflectedType = _data['reflectedType'] ? Type.fromJS(_data['reflectedType']) : <any>undefined;
         this.module = _data['module'] ? Module.fromJS(_data['module']) : <any>undefined;
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): PropertyInfo {
      data = typeof data === 'object' ? data : {};
      let result = new PropertyInfo();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['memberType'] = this.memberType;
      data['propertyType'] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
      data['attributes'] = this.attributes;
      data['isSpecialName'] = this.isSpecialName;
      data['canRead'] = this.canRead;
      data['canWrite'] = this.canWrite;
      data['getMethod'] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
      data['setMethod'] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
      data['name'] = this.name;
      data['declaringType'] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
      data['reflectedType'] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
      data['module'] = this.module ? this.module.toJSON() : <any>undefined;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['isCollectible'] = this.isCollectible;
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): PropertyInfo {
      const json = this.toJSON();
      let result = new PropertyInfo();
      result.init(json);
      return result;
   }
}

export interface IPropertyInfo {
   memberType: MemberTypes;
   propertyType: Type;
   attributes: PropertyAttributes;
   isSpecialName: boolean;
   canRead: boolean;
   canWrite: boolean;
   getMethod: MethodInfo;
   setMethod: MethodInfo;
   name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   customAttributes: CustomAttributeData[] | undefined;
   isCollectible: boolean;
   metadataToken: number;
}

export class MethodBase implements IMethodBase {
   attributes: MethodAttributes;
   methodImplementationFlags: MethodImplAttributes;
   callingConvention: CallingConventions;
   readonly isAbstract: boolean;
   readonly isConstructor: boolean;
   readonly isFinal: boolean;
   readonly isHideBySig: boolean;
   readonly isSpecialName: boolean;
   readonly isStatic: boolean;
   readonly isVirtual: boolean;
   readonly isAssembly: boolean;
   readonly isFamily: boolean;
   readonly isFamilyAndAssembly: boolean;
   readonly isFamilyOrAssembly: boolean;
   readonly isPrivate: boolean;
   readonly isPublic: boolean;
   readonly isConstructedGenericMethod: boolean;
   readonly isGenericMethod: boolean;
   readonly isGenericMethodDefinition: boolean;
   readonly containsGenericParameters: boolean;
   methodHandle: RuntimeMethodHandle;
   readonly isSecurityCritical: boolean;
   readonly isSecuritySafeCritical: boolean;
   readonly isSecurityTransparent: boolean;
   memberType: MemberTypes;
   readonly name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly isCollectible: boolean;
   readonly metadataToken: number;

   constructor(data?: IMethodBase) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.attributes = _data['attributes'];
         this.methodImplementationFlags = _data['methodImplementationFlags'];
         this.callingConvention = _data['callingConvention'];
         (<any>this).isAbstract = _data['isAbstract'];
         (<any>this).isConstructor = _data['isConstructor'];
         (<any>this).isFinal = _data['isFinal'];
         (<any>this).isHideBySig = _data['isHideBySig'];
         (<any>this).isSpecialName = _data['isSpecialName'];
         (<any>this).isStatic = _data['isStatic'];
         (<any>this).isVirtual = _data['isVirtual'];
         (<any>this).isAssembly = _data['isAssembly'];
         (<any>this).isFamily = _data['isFamily'];
         (<any>this).isFamilyAndAssembly = _data['isFamilyAndAssembly'];
         (<any>this).isFamilyOrAssembly = _data['isFamilyOrAssembly'];
         (<any>this).isPrivate = _data['isPrivate'];
         (<any>this).isPublic = _data['isPublic'];
         (<any>this).isConstructedGenericMethod = _data['isConstructedGenericMethod'];
         (<any>this).isGenericMethod = _data['isGenericMethod'];
         (<any>this).isGenericMethodDefinition = _data['isGenericMethodDefinition'];
         (<any>this).containsGenericParameters = _data['containsGenericParameters'];
         this.methodHandle = _data['methodHandle'] ? RuntimeMethodHandle.fromJS(_data['methodHandle']) : <any>undefined;
         (<any>this).isSecurityCritical = _data['isSecurityCritical'];
         (<any>this).isSecuritySafeCritical = _data['isSecuritySafeCritical'];
         (<any>this).isSecurityTransparent = _data['isSecurityTransparent'];
         this.memberType = _data['memberType'];
         (<any>this).name = _data['name'];
         this.declaringType = _data['declaringType'] ? Type.fromJS(_data['declaringType']) : <any>undefined;
         this.reflectedType = _data['reflectedType'] ? Type.fromJS(_data['reflectedType']) : <any>undefined;
         this.module = _data['module'] ? Module.fromJS(_data['module']) : <any>undefined;
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): MethodBase {
      data = typeof data === 'object' ? data : {};
      let result = new MethodBase();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['attributes'] = this.attributes;
      data['methodImplementationFlags'] = this.methodImplementationFlags;
      data['callingConvention'] = this.callingConvention;
      data['isAbstract'] = this.isAbstract;
      data['isConstructor'] = this.isConstructor;
      data['isFinal'] = this.isFinal;
      data['isHideBySig'] = this.isHideBySig;
      data['isSpecialName'] = this.isSpecialName;
      data['isStatic'] = this.isStatic;
      data['isVirtual'] = this.isVirtual;
      data['isAssembly'] = this.isAssembly;
      data['isFamily'] = this.isFamily;
      data['isFamilyAndAssembly'] = this.isFamilyAndAssembly;
      data['isFamilyOrAssembly'] = this.isFamilyOrAssembly;
      data['isPrivate'] = this.isPrivate;
      data['isPublic'] = this.isPublic;
      data['isConstructedGenericMethod'] = this.isConstructedGenericMethod;
      data['isGenericMethod'] = this.isGenericMethod;
      data['isGenericMethodDefinition'] = this.isGenericMethodDefinition;
      data['containsGenericParameters'] = this.containsGenericParameters;
      data['methodHandle'] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
      data['isSecurityCritical'] = this.isSecurityCritical;
      data['isSecuritySafeCritical'] = this.isSecuritySafeCritical;
      data['isSecurityTransparent'] = this.isSecurityTransparent;
      data['memberType'] = this.memberType;
      data['name'] = this.name;
      data['declaringType'] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
      data['reflectedType'] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
      data['module'] = this.module ? this.module.toJSON() : <any>undefined;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['isCollectible'] = this.isCollectible;
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): MethodBase {
      const json = this.toJSON();
      let result = new MethodBase();
      result.init(json);
      return result;
   }
}

export interface IMethodBase {
   attributes: MethodAttributes;
   methodImplementationFlags: MethodImplAttributes;
   callingConvention: CallingConventions;
   isAbstract: boolean;
   isConstructor: boolean;
   isFinal: boolean;
   isHideBySig: boolean;
   isSpecialName: boolean;
   isStatic: boolean;
   isVirtual: boolean;
   isAssembly: boolean;
   isFamily: boolean;
   isFamilyAndAssembly: boolean;
   isFamilyOrAssembly: boolean;
   isPrivate: boolean;
   isPublic: boolean;
   isConstructedGenericMethod: boolean;
   isGenericMethod: boolean;
   isGenericMethodDefinition: boolean;
   containsGenericParameters: boolean;
   methodHandle: RuntimeMethodHandle;
   isSecurityCritical: boolean;
   isSecuritySafeCritical: boolean;
   isSecurityTransparent: boolean;
   memberType: MemberTypes;
   name: string | undefined;
   declaringType: Type;
   reflectedType: Type;
   module: Module;
   customAttributes: CustomAttributeData[] | undefined;
   isCollectible: boolean;
   metadataToken: number;
}

export enum GenericParameterAttributes {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
   _8 = 8,
   _16 = 16,
   _28 = 28,
}

export enum TypeAttributes {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
   _5 = 5,
   _6 = 6,
   _7 = 7,
   _8 = 8,
   _16 = 16,
   _24 = 24,
   _32 = 32,
   _128 = 128,
   _256 = 256,
   _1024 = 1024,
   _2048 = 2048,
   _4096 = 4096,
   _8192 = 8192,
   _16384 = 16384,
   _65536 = 65536,
   _131072 = 131072,
   _196608 = 196608,
   _262144 = 262144,
   _264192 = 264192,
   _1048576 = 1048576,
   _12582912 = 12582912,
}

export enum LayoutKind {
   _0 = 0,
   _2 = 2,
   _3 = 3,
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
   value: LayoutKind;
   readonly typeId: any | undefined;

   constructor(data?: IStructLayoutAttribute) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.value = _data['value'];
         (<any>this).typeId = _data['typeId'];
      }
   }

   static fromJS(data: any): StructLayoutAttribute {
      data = typeof data === 'object' ? data : {};
      let result = new StructLayoutAttribute();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['value'] = this.value;
      data['typeId'] = this.typeId;
      return data;
   }

   clone(): StructLayoutAttribute {
      const json = this.toJSON();
      let result = new StructLayoutAttribute();
      result.init(json);
      return result;
   }
}

export interface IStructLayoutAttribute {
   value: LayoutKind;
   typeId: any | undefined;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
   value: IntPtr;

   constructor(data?: IRuntimeTypeHandle) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.value = _data['value'] ? IntPtr.fromJS(_data['value']) : <any>undefined;
      }
   }

   static fromJS(data: any): RuntimeTypeHandle {
      data = typeof data === 'object' ? data : {};
      let result = new RuntimeTypeHandle();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['value'] = this.value ? this.value.toJSON() : <any>undefined;
      return data;
   }

   clone(): RuntimeTypeHandle {
      const json = this.toJSON();
      let result = new RuntimeTypeHandle();
      result.init(json);
      return result;
   }
}

export interface IRuntimeTypeHandle {
   value: IntPtr;
}

export class TypeInfo implements ITypeInfo {
   readonly genericTypeParameters: Type[] | undefined;
   readonly declaredConstructors: ConstructorInfo[] | undefined;
   readonly declaredEvents: EventInfo[] | undefined;
   readonly declaredFields: FieldInfo[] | undefined;
   readonly declaredMembers: MemberInfo[] | undefined;
   readonly declaredMethods: MethodInfo[] | undefined;
   readonly declaredNestedTypes: TypeInfo[] | undefined;
   readonly declaredProperties: PropertyInfo[] | undefined;
   readonly implementedInterfaces: Type[] | undefined;
   readonly isInterface: boolean;
   memberType: MemberTypes;
   readonly namespace: string | undefined;
   readonly assemblyQualifiedName: string | undefined;
   readonly fullName: string | undefined;
   assembly: Assembly;
   module: Module;
   readonly isNested: boolean;
   declaringType: Type;
   declaringMethod: MethodBase;
   reflectedType: Type;
   underlyingSystemType: Type;
   readonly isTypeDefinition: boolean;
   readonly isArray: boolean;
   readonly isByRef: boolean;
   readonly isPointer: boolean;
   readonly isConstructedGenericType: boolean;
   readonly isGenericParameter: boolean;
   readonly isGenericTypeParameter: boolean;
   readonly isGenericMethodParameter: boolean;
   readonly isGenericType: boolean;
   readonly isGenericTypeDefinition: boolean;
   readonly isSZArray: boolean;
   readonly isVariableBoundArray: boolean;
   readonly isByRefLike: boolean;
   readonly hasElementType: boolean;
   readonly genericTypeArguments: Type[] | undefined;
   readonly genericParameterPosition: number;
   genericParameterAttributes: GenericParameterAttributes;
   attributes: TypeAttributes;
   readonly isAbstract: boolean;
   readonly isImport: boolean;
   readonly isSealed: boolean;
   readonly isSpecialName: boolean;
   readonly isClass: boolean;
   readonly isNestedAssembly: boolean;
   readonly isNestedFamANDAssem: boolean;
   readonly isNestedFamily: boolean;
   readonly isNestedFamORAssem: boolean;
   readonly isNestedPrivate: boolean;
   readonly isNestedPublic: boolean;
   readonly isNotPublic: boolean;
   readonly isPublic: boolean;
   readonly isAutoLayout: boolean;
   readonly isExplicitLayout: boolean;
   readonly isLayoutSequential: boolean;
   readonly isAnsiClass: boolean;
   readonly isAutoClass: boolean;
   readonly isUnicodeClass: boolean;
   readonly isCOMObject: boolean;
   readonly isContextful: boolean;
   readonly isEnum: boolean;
   readonly isMarshalByRef: boolean;
   readonly isPrimitive: boolean;
   readonly isValueType: boolean;
   readonly isSignatureType: boolean;
   readonly isSecurityCritical: boolean;
   readonly isSecuritySafeCritical: boolean;
   readonly isSecurityTransparent: boolean;
   structLayoutAttribute: StructLayoutAttribute;
   typeInitializer: ConstructorInfo;
   typeHandle: RuntimeTypeHandle;
   readonly guid: string;
   baseType: Type;
   readonly isSerializable: boolean;
   readonly containsGenericParameters: boolean;
   readonly isVisible: boolean;
   readonly name: string | undefined;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly isCollectible: boolean;
   readonly metadataToken: number;

   constructor(data?: ITypeInfo) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['genericTypeParameters'])) {
            (<any>this).genericTypeParameters = [] as any;
            for (let item of _data['genericTypeParameters']) (<any>this).genericTypeParameters.push(Type.fromJS(item));
         }
         if (Array.isArray(_data['declaredConstructors'])) {
            (<any>this).declaredConstructors = [] as any;
            for (let item of _data['declaredConstructors']) (<any>this).declaredConstructors.push(ConstructorInfo.fromJS(item));
         }
         if (Array.isArray(_data['declaredEvents'])) {
            (<any>this).declaredEvents = [] as any;
            for (let item of _data['declaredEvents']) (<any>this).declaredEvents.push(EventInfo.fromJS(item));
         }
         if (Array.isArray(_data['declaredFields'])) {
            (<any>this).declaredFields = [] as any;
            for (let item of _data['declaredFields']) (<any>this).declaredFields.push(FieldInfo.fromJS(item));
         }
         if (Array.isArray(_data['declaredMembers'])) {
            (<any>this).declaredMembers = [] as any;
            for (let item of _data['declaredMembers']) (<any>this).declaredMembers.push(MemberInfo.fromJS(item));
         }
         if (Array.isArray(_data['declaredMethods'])) {
            (<any>this).declaredMethods = [] as any;
            for (let item of _data['declaredMethods']) (<any>this).declaredMethods.push(MethodInfo.fromJS(item));
         }
         if (Array.isArray(_data['declaredNestedTypes'])) {
            (<any>this).declaredNestedTypes = [] as any;
            for (let item of _data['declaredNestedTypes']) (<any>this).declaredNestedTypes.push(TypeInfo.fromJS(item));
         }
         if (Array.isArray(_data['declaredProperties'])) {
            (<any>this).declaredProperties = [] as any;
            for (let item of _data['declaredProperties']) (<any>this).declaredProperties.push(PropertyInfo.fromJS(item));
         }
         if (Array.isArray(_data['implementedInterfaces'])) {
            (<any>this).implementedInterfaces = [] as any;
            for (let item of _data['implementedInterfaces']) (<any>this).implementedInterfaces.push(Type.fromJS(item));
         }
         (<any>this).isInterface = _data['isInterface'];
         this.memberType = _data['memberType'];
         (<any>this).namespace = _data['namespace'];
         (<any>this).assemblyQualifiedName = _data['assemblyQualifiedName'];
         (<any>this).fullName = _data['fullName'];
         this.assembly = _data['assembly'] ? Assembly.fromJS(_data['assembly']) : <any>undefined;
         this.module = _data['module'] ? Module.fromJS(_data['module']) : <any>undefined;
         (<any>this).isNested = _data['isNested'];
         this.declaringType = _data['declaringType'] ? Type.fromJS(_data['declaringType']) : <any>undefined;
         this.declaringMethod = _data['declaringMethod'] ? MethodBase.fromJS(_data['declaringMethod']) : <any>undefined;
         this.reflectedType = _data['reflectedType'] ? Type.fromJS(_data['reflectedType']) : <any>undefined;
         this.underlyingSystemType = _data['underlyingSystemType'] ? Type.fromJS(_data['underlyingSystemType']) : <any>undefined;
         (<any>this).isTypeDefinition = _data['isTypeDefinition'];
         (<any>this).isArray = _data['isArray'];
         (<any>this).isByRef = _data['isByRef'];
         (<any>this).isPointer = _data['isPointer'];
         (<any>this).isConstructedGenericType = _data['isConstructedGenericType'];
         (<any>this).isGenericParameter = _data['isGenericParameter'];
         (<any>this).isGenericTypeParameter = _data['isGenericTypeParameter'];
         (<any>this).isGenericMethodParameter = _data['isGenericMethodParameter'];
         (<any>this).isGenericType = _data['isGenericType'];
         (<any>this).isGenericTypeDefinition = _data['isGenericTypeDefinition'];
         (<any>this).isSZArray = _data['isSZArray'];
         (<any>this).isVariableBoundArray = _data['isVariableBoundArray'];
         (<any>this).isByRefLike = _data['isByRefLike'];
         (<any>this).hasElementType = _data['hasElementType'];
         if (Array.isArray(_data['genericTypeArguments'])) {
            (<any>this).genericTypeArguments = [] as any;
            for (let item of _data['genericTypeArguments']) (<any>this).genericTypeArguments.push(Type.fromJS(item));
         }
         (<any>this).genericParameterPosition = _data['genericParameterPosition'];
         this.genericParameterAttributes = _data['genericParameterAttributes'];
         this.attributes = _data['attributes'];
         (<any>this).isAbstract = _data['isAbstract'];
         (<any>this).isImport = _data['isImport'];
         (<any>this).isSealed = _data['isSealed'];
         (<any>this).isSpecialName = _data['isSpecialName'];
         (<any>this).isClass = _data['isClass'];
         (<any>this).isNestedAssembly = _data['isNestedAssembly'];
         (<any>this).isNestedFamANDAssem = _data['isNestedFamANDAssem'];
         (<any>this).isNestedFamily = _data['isNestedFamily'];
         (<any>this).isNestedFamORAssem = _data['isNestedFamORAssem'];
         (<any>this).isNestedPrivate = _data['isNestedPrivate'];
         (<any>this).isNestedPublic = _data['isNestedPublic'];
         (<any>this).isNotPublic = _data['isNotPublic'];
         (<any>this).isPublic = _data['isPublic'];
         (<any>this).isAutoLayout = _data['isAutoLayout'];
         (<any>this).isExplicitLayout = _data['isExplicitLayout'];
         (<any>this).isLayoutSequential = _data['isLayoutSequential'];
         (<any>this).isAnsiClass = _data['isAnsiClass'];
         (<any>this).isAutoClass = _data['isAutoClass'];
         (<any>this).isUnicodeClass = _data['isUnicodeClass'];
         (<any>this).isCOMObject = _data['isCOMObject'];
         (<any>this).isContextful = _data['isContextful'];
         (<any>this).isEnum = _data['isEnum'];
         (<any>this).isMarshalByRef = _data['isMarshalByRef'];
         (<any>this).isPrimitive = _data['isPrimitive'];
         (<any>this).isValueType = _data['isValueType'];
         (<any>this).isSignatureType = _data['isSignatureType'];
         (<any>this).isSecurityCritical = _data['isSecurityCritical'];
         (<any>this).isSecuritySafeCritical = _data['isSecuritySafeCritical'];
         (<any>this).isSecurityTransparent = _data['isSecurityTransparent'];
         this.structLayoutAttribute = _data['structLayoutAttribute'] ? StructLayoutAttribute.fromJS(_data['structLayoutAttribute']) : <any>undefined;
         this.typeInitializer = _data['typeInitializer'] ? ConstructorInfo.fromJS(_data['typeInitializer']) : <any>undefined;
         this.typeHandle = _data['typeHandle'] ? RuntimeTypeHandle.fromJS(_data['typeHandle']) : <any>undefined;
         (<any>this).guid = _data['guid'];
         this.baseType = _data['baseType'] ? Type.fromJS(_data['baseType']) : <any>undefined;
         (<any>this).isSerializable = _data['isSerializable'];
         (<any>this).containsGenericParameters = _data['containsGenericParameters'];
         (<any>this).isVisible = _data['isVisible'];
         (<any>this).name = _data['name'];
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): TypeInfo {
      data = typeof data === 'object' ? data : {};
      let result = new TypeInfo();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.genericTypeParameters)) {
         data['genericTypeParameters'] = [];
         for (let item of this.genericTypeParameters) data['genericTypeParameters'].push(item.toJSON());
      }
      if (Array.isArray(this.declaredConstructors)) {
         data['declaredConstructors'] = [];
         for (let item of this.declaredConstructors) data['declaredConstructors'].push(item.toJSON());
      }
      if (Array.isArray(this.declaredEvents)) {
         data['declaredEvents'] = [];
         for (let item of this.declaredEvents) data['declaredEvents'].push(item.toJSON());
      }
      if (Array.isArray(this.declaredFields)) {
         data['declaredFields'] = [];
         for (let item of this.declaredFields) data['declaredFields'].push(item.toJSON());
      }
      if (Array.isArray(this.declaredMembers)) {
         data['declaredMembers'] = [];
         for (let item of this.declaredMembers) data['declaredMembers'].push(item.toJSON());
      }
      if (Array.isArray(this.declaredMethods)) {
         data['declaredMethods'] = [];
         for (let item of this.declaredMethods) data['declaredMethods'].push(item.toJSON());
      }
      if (Array.isArray(this.declaredNestedTypes)) {
         data['declaredNestedTypes'] = [];
         for (let item of this.declaredNestedTypes) data['declaredNestedTypes'].push(item.toJSON());
      }
      if (Array.isArray(this.declaredProperties)) {
         data['declaredProperties'] = [];
         for (let item of this.declaredProperties) data['declaredProperties'].push(item.toJSON());
      }
      if (Array.isArray(this.implementedInterfaces)) {
         data['implementedInterfaces'] = [];
         for (let item of this.implementedInterfaces) data['implementedInterfaces'].push(item.toJSON());
      }
      data['isInterface'] = this.isInterface;
      data['memberType'] = this.memberType;
      data['namespace'] = this.namespace;
      data['assemblyQualifiedName'] = this.assemblyQualifiedName;
      data['fullName'] = this.fullName;
      data['assembly'] = this.assembly ? this.assembly.toJSON() : <any>undefined;
      data['module'] = this.module ? this.module.toJSON() : <any>undefined;
      data['isNested'] = this.isNested;
      data['declaringType'] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
      data['declaringMethod'] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
      data['reflectedType'] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
      data['underlyingSystemType'] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
      data['isTypeDefinition'] = this.isTypeDefinition;
      data['isArray'] = this.isArray;
      data['isByRef'] = this.isByRef;
      data['isPointer'] = this.isPointer;
      data['isConstructedGenericType'] = this.isConstructedGenericType;
      data['isGenericParameter'] = this.isGenericParameter;
      data['isGenericTypeParameter'] = this.isGenericTypeParameter;
      data['isGenericMethodParameter'] = this.isGenericMethodParameter;
      data['isGenericType'] = this.isGenericType;
      data['isGenericTypeDefinition'] = this.isGenericTypeDefinition;
      data['isSZArray'] = this.isSZArray;
      data['isVariableBoundArray'] = this.isVariableBoundArray;
      data['isByRefLike'] = this.isByRefLike;
      data['hasElementType'] = this.hasElementType;
      if (Array.isArray(this.genericTypeArguments)) {
         data['genericTypeArguments'] = [];
         for (let item of this.genericTypeArguments) data['genericTypeArguments'].push(item.toJSON());
      }
      data['genericParameterPosition'] = this.genericParameterPosition;
      data['genericParameterAttributes'] = this.genericParameterAttributes;
      data['attributes'] = this.attributes;
      data['isAbstract'] = this.isAbstract;
      data['isImport'] = this.isImport;
      data['isSealed'] = this.isSealed;
      data['isSpecialName'] = this.isSpecialName;
      data['isClass'] = this.isClass;
      data['isNestedAssembly'] = this.isNestedAssembly;
      data['isNestedFamANDAssem'] = this.isNestedFamANDAssem;
      data['isNestedFamily'] = this.isNestedFamily;
      data['isNestedFamORAssem'] = this.isNestedFamORAssem;
      data['isNestedPrivate'] = this.isNestedPrivate;
      data['isNestedPublic'] = this.isNestedPublic;
      data['isNotPublic'] = this.isNotPublic;
      data['isPublic'] = this.isPublic;
      data['isAutoLayout'] = this.isAutoLayout;
      data['isExplicitLayout'] = this.isExplicitLayout;
      data['isLayoutSequential'] = this.isLayoutSequential;
      data['isAnsiClass'] = this.isAnsiClass;
      data['isAutoClass'] = this.isAutoClass;
      data['isUnicodeClass'] = this.isUnicodeClass;
      data['isCOMObject'] = this.isCOMObject;
      data['isContextful'] = this.isContextful;
      data['isEnum'] = this.isEnum;
      data['isMarshalByRef'] = this.isMarshalByRef;
      data['isPrimitive'] = this.isPrimitive;
      data['isValueType'] = this.isValueType;
      data['isSignatureType'] = this.isSignatureType;
      data['isSecurityCritical'] = this.isSecurityCritical;
      data['isSecuritySafeCritical'] = this.isSecuritySafeCritical;
      data['isSecurityTransparent'] = this.isSecurityTransparent;
      data['structLayoutAttribute'] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
      data['typeInitializer'] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
      data['typeHandle'] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
      data['guid'] = this.guid;
      data['baseType'] = this.baseType ? this.baseType.toJSON() : <any>undefined;
      data['isSerializable'] = this.isSerializable;
      data['containsGenericParameters'] = this.containsGenericParameters;
      data['isVisible'] = this.isVisible;
      data['name'] = this.name;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['isCollectible'] = this.isCollectible;
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): TypeInfo {
      const json = this.toJSON();
      let result = new TypeInfo();
      result.init(json);
      return result;
   }
}

export interface ITypeInfo {
   genericTypeParameters: Type[] | undefined;
   declaredConstructors: ConstructorInfo[] | undefined;
   declaredEvents: EventInfo[] | undefined;
   declaredFields: FieldInfo[] | undefined;
   declaredMembers: MemberInfo[] | undefined;
   declaredMethods: MethodInfo[] | undefined;
   declaredNestedTypes: TypeInfo[] | undefined;
   declaredProperties: PropertyInfo[] | undefined;
   implementedInterfaces: Type[] | undefined;
   isInterface: boolean;
   memberType: MemberTypes;
   namespace: string | undefined;
   assemblyQualifiedName: string | undefined;
   fullName: string | undefined;
   assembly: Assembly;
   module: Module;
   isNested: boolean;
   declaringType: Type;
   declaringMethod: MethodBase;
   reflectedType: Type;
   underlyingSystemType: Type;
   isTypeDefinition: boolean;
   isArray: boolean;
   isByRef: boolean;
   isPointer: boolean;
   isConstructedGenericType: boolean;
   isGenericParameter: boolean;
   isGenericTypeParameter: boolean;
   isGenericMethodParameter: boolean;
   isGenericType: boolean;
   isGenericTypeDefinition: boolean;
   isSZArray: boolean;
   isVariableBoundArray: boolean;
   isByRefLike: boolean;
   hasElementType: boolean;
   genericTypeArguments: Type[] | undefined;
   genericParameterPosition: number;
   genericParameterAttributes: GenericParameterAttributes;
   attributes: TypeAttributes;
   isAbstract: boolean;
   isImport: boolean;
   isSealed: boolean;
   isSpecialName: boolean;
   isClass: boolean;
   isNestedAssembly: boolean;
   isNestedFamANDAssem: boolean;
   isNestedFamily: boolean;
   isNestedFamORAssem: boolean;
   isNestedPrivate: boolean;
   isNestedPublic: boolean;
   isNotPublic: boolean;
   isPublic: boolean;
   isAutoLayout: boolean;
   isExplicitLayout: boolean;
   isLayoutSequential: boolean;
   isAnsiClass: boolean;
   isAutoClass: boolean;
   isUnicodeClass: boolean;
   isCOMObject: boolean;
   isContextful: boolean;
   isEnum: boolean;
   isMarshalByRef: boolean;
   isPrimitive: boolean;
   isValueType: boolean;
   isSignatureType: boolean;
   isSecurityCritical: boolean;
   isSecuritySafeCritical: boolean;
   isSecurityTransparent: boolean;
   structLayoutAttribute: StructLayoutAttribute;
   typeInitializer: ConstructorInfo;
   typeHandle: RuntimeTypeHandle;
   guid: string;
   baseType: Type;
   isSerializable: boolean;
   containsGenericParameters: boolean;
   isVisible: boolean;
   name: string | undefined;
   customAttributes: CustomAttributeData[] | undefined;
   isCollectible: boolean;
   metadataToken: number;
}

export enum SecurityRuleSet {
   _0 = 0,
   _1 = 1,
   _2 = 2,
}

export class Assembly implements IAssembly {
   readonly definedTypes: TypeInfo[] | undefined;
   readonly exportedTypes: Type[] | undefined;
   readonly codeBase: string | undefined;
   entryPoint: MethodInfo;
   readonly fullName: string | undefined;
   readonly imageRuntimeVersion: string | undefined;
   readonly isDynamic: boolean;
   readonly location: string | undefined;
   readonly reflectionOnly: boolean;
   readonly isCollectible: boolean;
   readonly isFullyTrusted: boolean;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly escapedCodeBase: string | undefined;
   manifestModule: Module;
   readonly modules: Module[] | undefined;
   readonly globalAssemblyCache: boolean;
   readonly hostContext: number;
   securityRuleSet: SecurityRuleSet;

   constructor(data?: IAssembly) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['definedTypes'])) {
            (<any>this).definedTypes = [] as any;
            for (let item of _data['definedTypes']) (<any>this).definedTypes.push(TypeInfo.fromJS(item));
         }
         if (Array.isArray(_data['exportedTypes'])) {
            (<any>this).exportedTypes = [] as any;
            for (let item of _data['exportedTypes']) (<any>this).exportedTypes.push(Type.fromJS(item));
         }
         (<any>this).codeBase = _data['codeBase'];
         this.entryPoint = _data['entryPoint'] ? MethodInfo.fromJS(_data['entryPoint']) : <any>undefined;
         (<any>this).fullName = _data['fullName'];
         (<any>this).imageRuntimeVersion = _data['imageRuntimeVersion'];
         (<any>this).isDynamic = _data['isDynamic'];
         (<any>this).location = _data['location'];
         (<any>this).reflectionOnly = _data['reflectionOnly'];
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).isFullyTrusted = _data['isFullyTrusted'];
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).escapedCodeBase = _data['escapedCodeBase'];
         this.manifestModule = _data['manifestModule'] ? Module.fromJS(_data['manifestModule']) : <any>undefined;
         if (Array.isArray(_data['modules'])) {
            (<any>this).modules = [] as any;
            for (let item of _data['modules']) (<any>this).modules.push(Module.fromJS(item));
         }
         (<any>this).globalAssemblyCache = _data['globalAssemblyCache'];
         (<any>this).hostContext = _data['hostContext'];
         this.securityRuleSet = _data['securityRuleSet'];
      }
   }

   static fromJS(data: any): Assembly {
      data = typeof data === 'object' ? data : {};
      let result = new Assembly();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.definedTypes)) {
         data['definedTypes'] = [];
         for (let item of this.definedTypes) data['definedTypes'].push(item.toJSON());
      }
      if (Array.isArray(this.exportedTypes)) {
         data['exportedTypes'] = [];
         for (let item of this.exportedTypes) data['exportedTypes'].push(item.toJSON());
      }
      data['codeBase'] = this.codeBase;
      data['entryPoint'] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
      data['fullName'] = this.fullName;
      data['imageRuntimeVersion'] = this.imageRuntimeVersion;
      data['isDynamic'] = this.isDynamic;
      data['location'] = this.location;
      data['reflectionOnly'] = this.reflectionOnly;
      data['isCollectible'] = this.isCollectible;
      data['isFullyTrusted'] = this.isFullyTrusted;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['escapedCodeBase'] = this.escapedCodeBase;
      data['manifestModule'] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
      if (Array.isArray(this.modules)) {
         data['modules'] = [];
         for (let item of this.modules) data['modules'].push(item.toJSON());
      }
      data['globalAssemblyCache'] = this.globalAssemblyCache;
      data['hostContext'] = this.hostContext;
      data['securityRuleSet'] = this.securityRuleSet;
      return data;
   }

   clone(): Assembly {
      const json = this.toJSON();
      let result = new Assembly();
      result.init(json);
      return result;
   }
}

export interface IAssembly {
   definedTypes: TypeInfo[] | undefined;
   exportedTypes: Type[] | undefined;
   codeBase: string | undefined;
   entryPoint: MethodInfo;
   fullName: string | undefined;
   imageRuntimeVersion: string | undefined;
   isDynamic: boolean;
   location: string | undefined;
   reflectionOnly: boolean;
   isCollectible: boolean;
   isFullyTrusted: boolean;
   customAttributes: CustomAttributeData[] | undefined;
   escapedCodeBase: string | undefined;
   manifestModule: Module;
   modules: Module[] | undefined;
   globalAssemblyCache: boolean;
   hostContext: number;
   securityRuleSet: SecurityRuleSet;
}

export class Type implements IType {
   readonly isInterface: boolean;
   memberType: MemberTypes;
   readonly namespace: string | undefined;
   readonly assemblyQualifiedName: string | undefined;
   readonly fullName: string | undefined;
   assembly: Assembly;
   module: Module;
   readonly isNested: boolean;
   declaringType: Type;
   declaringMethod: MethodBase;
   reflectedType: Type;
   underlyingSystemType: Type;
   readonly isTypeDefinition: boolean;
   readonly isArray: boolean;
   readonly isByRef: boolean;
   readonly isPointer: boolean;
   readonly isConstructedGenericType: boolean;
   readonly isGenericParameter: boolean;
   readonly isGenericTypeParameter: boolean;
   readonly isGenericMethodParameter: boolean;
   readonly isGenericType: boolean;
   readonly isGenericTypeDefinition: boolean;
   readonly isSZArray: boolean;
   readonly isVariableBoundArray: boolean;
   readonly isByRefLike: boolean;
   readonly hasElementType: boolean;
   readonly genericTypeArguments: Type[] | undefined;
   readonly genericParameterPosition: number;
   genericParameterAttributes: GenericParameterAttributes;
   attributes: TypeAttributes;
   readonly isAbstract: boolean;
   readonly isImport: boolean;
   readonly isSealed: boolean;
   readonly isSpecialName: boolean;
   readonly isClass: boolean;
   readonly isNestedAssembly: boolean;
   readonly isNestedFamANDAssem: boolean;
   readonly isNestedFamily: boolean;
   readonly isNestedFamORAssem: boolean;
   readonly isNestedPrivate: boolean;
   readonly isNestedPublic: boolean;
   readonly isNotPublic: boolean;
   readonly isPublic: boolean;
   readonly isAutoLayout: boolean;
   readonly isExplicitLayout: boolean;
   readonly isLayoutSequential: boolean;
   readonly isAnsiClass: boolean;
   readonly isAutoClass: boolean;
   readonly isUnicodeClass: boolean;
   readonly isCOMObject: boolean;
   readonly isContextful: boolean;
   readonly isEnum: boolean;
   readonly isMarshalByRef: boolean;
   readonly isPrimitive: boolean;
   readonly isValueType: boolean;
   readonly isSignatureType: boolean;
   readonly isSecurityCritical: boolean;
   readonly isSecuritySafeCritical: boolean;
   readonly isSecurityTransparent: boolean;
   structLayoutAttribute: StructLayoutAttribute;
   typeInitializer: ConstructorInfo;
   typeHandle: RuntimeTypeHandle;
   readonly guid: string;
   baseType: Type;
   readonly isSerializable: boolean;
   readonly containsGenericParameters: boolean;
   readonly isVisible: boolean;
   readonly name: string | undefined;
   readonly customAttributes: CustomAttributeData[] | undefined;
   readonly isCollectible: boolean;
   readonly metadataToken: number;

   constructor(data?: IType) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         (<any>this).isInterface = _data['isInterface'];
         this.memberType = _data['memberType'];
         (<any>this).namespace = _data['namespace'];
         (<any>this).assemblyQualifiedName = _data['assemblyQualifiedName'];
         (<any>this).fullName = _data['fullName'];
         this.assembly = _data['assembly'] ? Assembly.fromJS(_data['assembly']) : <any>undefined;
         this.module = _data['module'] ? Module.fromJS(_data['module']) : <any>undefined;
         (<any>this).isNested = _data['isNested'];
         this.declaringType = _data['declaringType'] ? Type.fromJS(_data['declaringType']) : <any>undefined;
         this.declaringMethod = _data['declaringMethod'] ? MethodBase.fromJS(_data['declaringMethod']) : <any>undefined;
         this.reflectedType = _data['reflectedType'] ? Type.fromJS(_data['reflectedType']) : <any>undefined;
         this.underlyingSystemType = _data['underlyingSystemType'] ? Type.fromJS(_data['underlyingSystemType']) : <any>undefined;
         (<any>this).isTypeDefinition = _data['isTypeDefinition'];
         (<any>this).isArray = _data['isArray'];
         (<any>this).isByRef = _data['isByRef'];
         (<any>this).isPointer = _data['isPointer'];
         (<any>this).isConstructedGenericType = _data['isConstructedGenericType'];
         (<any>this).isGenericParameter = _data['isGenericParameter'];
         (<any>this).isGenericTypeParameter = _data['isGenericTypeParameter'];
         (<any>this).isGenericMethodParameter = _data['isGenericMethodParameter'];
         (<any>this).isGenericType = _data['isGenericType'];
         (<any>this).isGenericTypeDefinition = _data['isGenericTypeDefinition'];
         (<any>this).isSZArray = _data['isSZArray'];
         (<any>this).isVariableBoundArray = _data['isVariableBoundArray'];
         (<any>this).isByRefLike = _data['isByRefLike'];
         (<any>this).hasElementType = _data['hasElementType'];
         if (Array.isArray(_data['genericTypeArguments'])) {
            (<any>this).genericTypeArguments = [] as any;
            for (let item of _data['genericTypeArguments']) (<any>this).genericTypeArguments.push(Type.fromJS(item));
         }
         (<any>this).genericParameterPosition = _data['genericParameterPosition'];
         this.genericParameterAttributes = _data['genericParameterAttributes'];
         this.attributes = _data['attributes'];
         (<any>this).isAbstract = _data['isAbstract'];
         (<any>this).isImport = _data['isImport'];
         (<any>this).isSealed = _data['isSealed'];
         (<any>this).isSpecialName = _data['isSpecialName'];
         (<any>this).isClass = _data['isClass'];
         (<any>this).isNestedAssembly = _data['isNestedAssembly'];
         (<any>this).isNestedFamANDAssem = _data['isNestedFamANDAssem'];
         (<any>this).isNestedFamily = _data['isNestedFamily'];
         (<any>this).isNestedFamORAssem = _data['isNestedFamORAssem'];
         (<any>this).isNestedPrivate = _data['isNestedPrivate'];
         (<any>this).isNestedPublic = _data['isNestedPublic'];
         (<any>this).isNotPublic = _data['isNotPublic'];
         (<any>this).isPublic = _data['isPublic'];
         (<any>this).isAutoLayout = _data['isAutoLayout'];
         (<any>this).isExplicitLayout = _data['isExplicitLayout'];
         (<any>this).isLayoutSequential = _data['isLayoutSequential'];
         (<any>this).isAnsiClass = _data['isAnsiClass'];
         (<any>this).isAutoClass = _data['isAutoClass'];
         (<any>this).isUnicodeClass = _data['isUnicodeClass'];
         (<any>this).isCOMObject = _data['isCOMObject'];
         (<any>this).isContextful = _data['isContextful'];
         (<any>this).isEnum = _data['isEnum'];
         (<any>this).isMarshalByRef = _data['isMarshalByRef'];
         (<any>this).isPrimitive = _data['isPrimitive'];
         (<any>this).isValueType = _data['isValueType'];
         (<any>this).isSignatureType = _data['isSignatureType'];
         (<any>this).isSecurityCritical = _data['isSecurityCritical'];
         (<any>this).isSecuritySafeCritical = _data['isSecuritySafeCritical'];
         (<any>this).isSecurityTransparent = _data['isSecurityTransparent'];
         this.structLayoutAttribute = _data['structLayoutAttribute'] ? StructLayoutAttribute.fromJS(_data['structLayoutAttribute']) : <any>undefined;
         this.typeInitializer = _data['typeInitializer'] ? ConstructorInfo.fromJS(_data['typeInitializer']) : <any>undefined;
         this.typeHandle = _data['typeHandle'] ? RuntimeTypeHandle.fromJS(_data['typeHandle']) : <any>undefined;
         (<any>this).guid = _data['guid'];
         this.baseType = _data['baseType'] ? Type.fromJS(_data['baseType']) : <any>undefined;
         (<any>this).isSerializable = _data['isSerializable'];
         (<any>this).containsGenericParameters = _data['containsGenericParameters'];
         (<any>this).isVisible = _data['isVisible'];
         (<any>this).name = _data['name'];
         if (Array.isArray(_data['customAttributes'])) {
            (<any>this).customAttributes = [] as any;
            for (let item of _data['customAttributes']) (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
         }
         (<any>this).isCollectible = _data['isCollectible'];
         (<any>this).metadataToken = _data['metadataToken'];
      }
   }

   static fromJS(data: any): Type {
      data = typeof data === 'object' ? data : {};
      let result = new Type();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['isInterface'] = this.isInterface;
      data['memberType'] = this.memberType;
      data['namespace'] = this.namespace;
      data['assemblyQualifiedName'] = this.assemblyQualifiedName;
      data['fullName'] = this.fullName;
      data['assembly'] = this.assembly ? this.assembly.toJSON() : <any>undefined;
      data['module'] = this.module ? this.module.toJSON() : <any>undefined;
      data['isNested'] = this.isNested;
      data['declaringType'] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
      data['declaringMethod'] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
      data['reflectedType'] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
      data['underlyingSystemType'] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
      data['isTypeDefinition'] = this.isTypeDefinition;
      data['isArray'] = this.isArray;
      data['isByRef'] = this.isByRef;
      data['isPointer'] = this.isPointer;
      data['isConstructedGenericType'] = this.isConstructedGenericType;
      data['isGenericParameter'] = this.isGenericParameter;
      data['isGenericTypeParameter'] = this.isGenericTypeParameter;
      data['isGenericMethodParameter'] = this.isGenericMethodParameter;
      data['isGenericType'] = this.isGenericType;
      data['isGenericTypeDefinition'] = this.isGenericTypeDefinition;
      data['isSZArray'] = this.isSZArray;
      data['isVariableBoundArray'] = this.isVariableBoundArray;
      data['isByRefLike'] = this.isByRefLike;
      data['hasElementType'] = this.hasElementType;
      if (Array.isArray(this.genericTypeArguments)) {
         data['genericTypeArguments'] = [];
         for (let item of this.genericTypeArguments) data['genericTypeArguments'].push(item.toJSON());
      }
      data['genericParameterPosition'] = this.genericParameterPosition;
      data['genericParameterAttributes'] = this.genericParameterAttributes;
      data['attributes'] = this.attributes;
      data['isAbstract'] = this.isAbstract;
      data['isImport'] = this.isImport;
      data['isSealed'] = this.isSealed;
      data['isSpecialName'] = this.isSpecialName;
      data['isClass'] = this.isClass;
      data['isNestedAssembly'] = this.isNestedAssembly;
      data['isNestedFamANDAssem'] = this.isNestedFamANDAssem;
      data['isNestedFamily'] = this.isNestedFamily;
      data['isNestedFamORAssem'] = this.isNestedFamORAssem;
      data['isNestedPrivate'] = this.isNestedPrivate;
      data['isNestedPublic'] = this.isNestedPublic;
      data['isNotPublic'] = this.isNotPublic;
      data['isPublic'] = this.isPublic;
      data['isAutoLayout'] = this.isAutoLayout;
      data['isExplicitLayout'] = this.isExplicitLayout;
      data['isLayoutSequential'] = this.isLayoutSequential;
      data['isAnsiClass'] = this.isAnsiClass;
      data['isAutoClass'] = this.isAutoClass;
      data['isUnicodeClass'] = this.isUnicodeClass;
      data['isCOMObject'] = this.isCOMObject;
      data['isContextful'] = this.isContextful;
      data['isEnum'] = this.isEnum;
      data['isMarshalByRef'] = this.isMarshalByRef;
      data['isPrimitive'] = this.isPrimitive;
      data['isValueType'] = this.isValueType;
      data['isSignatureType'] = this.isSignatureType;
      data['isSecurityCritical'] = this.isSecurityCritical;
      data['isSecuritySafeCritical'] = this.isSecuritySafeCritical;
      data['isSecurityTransparent'] = this.isSecurityTransparent;
      data['structLayoutAttribute'] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
      data['typeInitializer'] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
      data['typeHandle'] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
      data['guid'] = this.guid;
      data['baseType'] = this.baseType ? this.baseType.toJSON() : <any>undefined;
      data['isSerializable'] = this.isSerializable;
      data['containsGenericParameters'] = this.containsGenericParameters;
      data['isVisible'] = this.isVisible;
      data['name'] = this.name;
      if (Array.isArray(this.customAttributes)) {
         data['customAttributes'] = [];
         for (let item of this.customAttributes) data['customAttributes'].push(item.toJSON());
      }
      data['isCollectible'] = this.isCollectible;
      data['metadataToken'] = this.metadataToken;
      return data;
   }

   clone(): Type {
      const json = this.toJSON();
      let result = new Type();
      result.init(json);
      return result;
   }
}

export interface IType {
   isInterface: boolean;
   memberType: MemberTypes;
   namespace: string | undefined;
   assemblyQualifiedName: string | undefined;
   fullName: string | undefined;
   assembly: Assembly;
   module: Module;
   isNested: boolean;
   declaringType: Type;
   declaringMethod: MethodBase;
   reflectedType: Type;
   underlyingSystemType: Type;
   isTypeDefinition: boolean;
   isArray: boolean;
   isByRef: boolean;
   isPointer: boolean;
   isConstructedGenericType: boolean;
   isGenericParameter: boolean;
   isGenericTypeParameter: boolean;
   isGenericMethodParameter: boolean;
   isGenericType: boolean;
   isGenericTypeDefinition: boolean;
   isSZArray: boolean;
   isVariableBoundArray: boolean;
   isByRefLike: boolean;
   hasElementType: boolean;
   genericTypeArguments: Type[] | undefined;
   genericParameterPosition: number;
   genericParameterAttributes: GenericParameterAttributes;
   attributes: TypeAttributes;
   isAbstract: boolean;
   isImport: boolean;
   isSealed: boolean;
   isSpecialName: boolean;
   isClass: boolean;
   isNestedAssembly: boolean;
   isNestedFamANDAssem: boolean;
   isNestedFamily: boolean;
   isNestedFamORAssem: boolean;
   isNestedPrivate: boolean;
   isNestedPublic: boolean;
   isNotPublic: boolean;
   isPublic: boolean;
   isAutoLayout: boolean;
   isExplicitLayout: boolean;
   isLayoutSequential: boolean;
   isAnsiClass: boolean;
   isAutoClass: boolean;
   isUnicodeClass: boolean;
   isCOMObject: boolean;
   isContextful: boolean;
   isEnum: boolean;
   isMarshalByRef: boolean;
   isPrimitive: boolean;
   isValueType: boolean;
   isSignatureType: boolean;
   isSecurityCritical: boolean;
   isSecuritySafeCritical: boolean;
   isSecurityTransparent: boolean;
   structLayoutAttribute: StructLayoutAttribute;
   typeInitializer: ConstructorInfo;
   typeHandle: RuntimeTypeHandle;
   guid: string;
   baseType: Type;
   isSerializable: boolean;
   containsGenericParameters: boolean;
   isVisible: boolean;
   name: string | undefined;
   customAttributes: CustomAttributeData[] | undefined;
   isCollectible: boolean;
   metadataToken: number;
}

export enum NotificationSeverity {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
}

export class TenantNotification implements ITenantNotification {
   tenantId: number | undefined;
   notificationName: string | undefined;
   data: NotificationData;
   entityType: Type;
   entityTypeName: string | undefined;
   entityId: any | undefined;
   severity: NotificationSeverity;
   creationTime: Date;
   id: string;

   constructor(data?: ITenantNotification) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.notificationName = _data['notificationName'];
         this.data = _data['data'] ? NotificationData.fromJS(_data['data']) : <any>undefined;
         this.entityType = _data['entityType'] ? Type.fromJS(_data['entityType']) : <any>undefined;
         this.entityTypeName = _data['entityTypeName'];
         this.entityId = _data['entityId'];
         this.severity = _data['severity'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): TenantNotification {
      data = typeof data === 'object' ? data : {};
      let result = new TenantNotification();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['notificationName'] = this.notificationName;
      data['data'] = this.data ? this.data.toJSON() : <any>undefined;
      data['entityType'] = this.entityType ? this.entityType.toJSON() : <any>undefined;
      data['entityTypeName'] = this.entityTypeName;
      data['entityId'] = this.entityId;
      data['severity'] = this.severity;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['id'] = this.id;
      return data;
   }

   clone(): TenantNotification {
      const json = this.toJSON();
      let result = new TenantNotification();
      result.init(json);
      return result;
   }
}

export interface ITenantNotification {
   tenantId: number | undefined;
   notificationName: string | undefined;
   data: NotificationData;
   entityType: Type;
   entityTypeName: string | undefined;
   entityId: any | undefined;
   severity: NotificationSeverity;
   creationTime: Date;
   id: string;
}

export class UserNotification implements IUserNotification {
   tenantId: number | undefined;
   userId: number;
   state: UserNotificationState;
   notification: TenantNotification;
   id: string;

   constructor(data?: IUserNotification) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.userId = _data['userId'];
         this.state = _data['state'];
         this.notification = _data['notification'] ? TenantNotification.fromJS(_data['notification']) : <any>undefined;
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): UserNotification {
      data = typeof data === 'object' ? data : {};
      let result = new UserNotification();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['userId'] = this.userId;
      data['state'] = this.state;
      data['notification'] = this.notification ? this.notification.toJSON() : <any>undefined;
      data['id'] = this.id;
      return data;
   }

   clone(): UserNotification {
      const json = this.toJSON();
      let result = new UserNotification();
      result.init(json);
      return result;
   }
}

export interface IUserNotification {
   tenantId: number | undefined;
   userId: number;
   state: UserNotificationState;
   notification: TenantNotification;
   id: string;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
   /** 未阅读消息数量 */
   unreadCount: number;
   totalCount: number;
   items: UserNotification[] | undefined;

   constructor(data?: IGetNotificationsOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.unreadCount = _data['unreadCount'];
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(UserNotification.fromJS(item));
         }
      }
   }

   static fromJS(data: any): GetNotificationsOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetNotificationsOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['unreadCount'] = this.unreadCount;
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): GetNotificationsOutput {
      const json = this.toJSON();
      let result = new GetNotificationsOutput();
      result.init(json);
      return result;
   }
}

export interface IGetNotificationsOutput {
   /** 未阅读消息数量 */
   unreadCount: number;
   totalCount: number;
   items: UserNotification[] | undefined;
}

export class GuidEntityDto implements IGuidEntityDto {
   id: string;

   constructor(data?: IGuidEntityDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): GuidEntityDto {
      data = typeof data === 'object' ? data : {};
      let result = new GuidEntityDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      return data;
   }

   clone(): GuidEntityDto {
      const json = this.toJSON();
      let result = new GuidEntityDto();
      result.init(json);
      return result;
   }
}

export interface IGuidEntityDto {
   id: string;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
   name: string;
   isSubscribed: boolean;

   constructor(data?: INotificationSubscriptionDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.isSubscribed = _data['isSubscribed'];
      }
   }

   static fromJS(data: any): NotificationSubscriptionDto {
      data = typeof data === 'object' ? data : {};
      let result = new NotificationSubscriptionDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['isSubscribed'] = this.isSubscribed;
      return data;
   }

   clone(): NotificationSubscriptionDto {
      const json = this.toJSON();
      let result = new NotificationSubscriptionDto();
      result.init(json);
      return result;
   }
}

export interface INotificationSubscriptionDto {
   name: string;
   isSubscribed: boolean;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
   receiveNotifications: boolean;
   notifications: NotificationSubscriptionDto[] | undefined;

   constructor(data?: IUpdateNotificationSettingsInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.receiveNotifications = _data['receiveNotifications'];
         if (Array.isArray(_data['notifications'])) {
            this.notifications = [] as any;
            for (let item of _data['notifications']) this.notifications.push(NotificationSubscriptionDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): UpdateNotificationSettingsInput {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateNotificationSettingsInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['receiveNotifications'] = this.receiveNotifications;
      if (Array.isArray(this.notifications)) {
         data['notifications'] = [];
         for (let item of this.notifications) data['notifications'].push(item.toJSON());
      }
      return data;
   }

   clone(): UpdateNotificationSettingsInput {
      const json = this.toJSON();
      let result = new UpdateNotificationSettingsInput();
      result.init(json);
      return result;
   }
}

export interface IUpdateNotificationSettingsInput {
   receiveNotifications: boolean;
   notifications: NotificationSubscriptionDto[] | undefined;
}

/** 创建订单Dto */
export class CreateOrderInput implements ICreateOrderInput {
   /** 订单编码 */
   code: string;
   /** 商品数量 */
   cargoCount: number;

   constructor(data?: ICreateOrderInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.code = _data['code'];
         this.cargoCount = _data['cargoCount'];
      }
   }

   static fromJS(data: any): CreateOrderInput {
      data = typeof data === 'object' ? data : {};
      let result = new CreateOrderInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['code'] = this.code;
      data['cargoCount'] = this.cargoCount;
      return data;
   }

   clone(): CreateOrderInput {
      const json = this.toJSON();
      let result = new CreateOrderInput();
      result.init(json);
      return result;
   }
}

/** 创建订单Dto */
export interface ICreateOrderInput {
   /** 订单编码 */
   code: string;
   /** 商品数量 */
   cargoCount: number;
}

export enum Status {
   _1 = 1,
   _2 = 2,
}

export class WeatherForecast implements IWeatherForecast {
   date: Date | undefined;
   temperatureC: number;
   readonly temperatureF: number;
   summary: string | undefined;
   status: Status;

   constructor(data?: IWeatherForecast) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
         this.temperatureC = _data['temperatureC'];
         (<any>this).temperatureF = _data['temperatureF'];
         this.summary = _data['summary'];
         this.status = _data['status'];
      }
   }

   static fromJS(data: any): WeatherForecast {
      data = typeof data === 'object' ? data : {};
      let result = new WeatherForecast();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['date'] = this.date ? this.date.toISOString() : <any>undefined;
      data['temperatureC'] = this.temperatureC;
      data['temperatureF'] = this.temperatureF;
      data['summary'] = this.summary;
      data['status'] = this.status;
      return data;
   }

   clone(): WeatherForecast {
      const json = this.toJSON();
      let result = new WeatherForecast();
      result.init(json);
      return result;
   }
}

export interface IWeatherForecast {
   date: Date | undefined;
   temperatureC: number;
   temperatureF: number;
   summary: string | undefined;
   status: Status;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
   entityChangeId: number;
   newValue: string | undefined;
   originalValue: string | undefined;
   propertyName: string | undefined;
   propertyTypeFullName: string | undefined;
   tenantId: number | undefined;
   id: number;

   constructor(data?: IEntityPropertyChangeDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.entityChangeId = _data['entityChangeId'];
         this.newValue = _data['newValue'];
         this.originalValue = _data['originalValue'];
         this.propertyName = _data['propertyName'];
         this.propertyTypeFullName = _data['propertyTypeFullName'];
         this.tenantId = _data['tenantId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): EntityPropertyChangeDto {
      data = typeof data === 'object' ? data : {};
      let result = new EntityPropertyChangeDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['entityChangeId'] = this.entityChangeId;
      data['newValue'] = this.newValue;
      data['originalValue'] = this.originalValue;
      data['propertyName'] = this.propertyName;
      data['propertyTypeFullName'] = this.propertyTypeFullName;
      data['tenantId'] = this.tenantId;
      data['id'] = this.id;
      return data;
   }

   clone(): EntityPropertyChangeDto {
      const json = this.toJSON();
      let result = new EntityPropertyChangeDto();
      result.init(json);
      return result;
   }
}

export interface IEntityPropertyChangeDto {
   entityChangeId: number;
   newValue: string | undefined;
   originalValue: string | undefined;
   propertyName: string | undefined;
   propertyTypeFullName: string | undefined;
   tenantId: number | undefined;
   id: number;
}

export class EntityPropertyChangeDetailDto implements IEntityPropertyChangeDetailDto {
   entityChangeId: number;
   newValue: string | undefined;
   originalValue: string | undefined;
   propertyName: string | undefined;
   propertyNameLocalized: string | undefined;
   propertyTypeFullName: string | undefined;
   userId: number | undefined;
   userName: string | undefined;
   changeTime: Date;
   changeType: EntityChangeType;
   readonly changeTypeName: string | undefined;
   id: number;

   constructor(data?: IEntityPropertyChangeDetailDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.entityChangeId = _data['entityChangeId'];
         this.newValue = _data['newValue'];
         this.originalValue = _data['originalValue'];
         this.propertyName = _data['propertyName'];
         this.propertyNameLocalized = _data['propertyNameLocalized'];
         this.propertyTypeFullName = _data['propertyTypeFullName'];
         this.userId = _data['userId'];
         this.userName = _data['userName'];
         this.changeTime = _data['changeTime'] ? new Date(_data['changeTime'].toString()) : <any>undefined;
         this.changeType = _data['changeType'];
         (<any>this).changeTypeName = _data['changeTypeName'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): EntityPropertyChangeDetailDto {
      data = typeof data === 'object' ? data : {};
      let result = new EntityPropertyChangeDetailDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['entityChangeId'] = this.entityChangeId;
      data['newValue'] = this.newValue;
      data['originalValue'] = this.originalValue;
      data['propertyName'] = this.propertyName;
      data['propertyNameLocalized'] = this.propertyNameLocalized;
      data['propertyTypeFullName'] = this.propertyTypeFullName;
      data['userId'] = this.userId;
      data['userName'] = this.userName;
      data['changeTime'] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
      data['changeType'] = this.changeType;
      data['changeTypeName'] = this.changeTypeName;
      data['id'] = this.id;
      return data;
   }

   clone(): EntityPropertyChangeDetailDto {
      const json = this.toJSON();
      let result = new EntityPropertyChangeDetailDto();
      result.init(json);
      return result;
   }
}

export interface IEntityPropertyChangeDetailDto {
   entityChangeId: number;
   newValue: string | undefined;
   originalValue: string | undefined;
   propertyName: string | undefined;
   propertyNameLocalized: string | undefined;
   propertyTypeFullName: string | undefined;
   userId: number | undefined;
   userName: string | undefined;
   changeTime: Date;
   changeType: EntityChangeType;
   changeTypeName: string | undefined;
   id: number;
}

export class EntityPropertyChangeDetailDtoPagedResultDto implements IEntityPropertyChangeDetailDtoPagedResultDto {
   totalCount: number;
   items: EntityPropertyChangeDetailDto[] | undefined;

   constructor(data?: IEntityPropertyChangeDetailDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(EntityPropertyChangeDetailDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): EntityPropertyChangeDetailDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new EntityPropertyChangeDetailDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): EntityPropertyChangeDetailDtoPagedResultDto {
      const json = this.toJSON();
      let result = new EntityPropertyChangeDetailDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IEntityPropertyChangeDetailDtoPagedResultDto {
   totalCount: number;
   items: EntityPropertyChangeDetailDto[] | undefined;
}

export class UpdateOrderInput implements IUpdateOrderInput {
   id: string;
   code: string;
   cargoCount: number;

   constructor(data?: IUpdateOrderInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
         this.code = _data['code'];
         this.cargoCount = _data['cargoCount'];
      }
   }

   static fromJS(data: any): UpdateOrderInput {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateOrderInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['code'] = this.code;
      data['cargoCount'] = this.cargoCount;
      return data;
   }

   clone(): UpdateOrderInput {
      const json = this.toJSON();
      let result = new UpdateOrderInput();
      result.init(json);
      return result;
   }
}

export interface IUpdateOrderInput {
   id: string;
   code: string;
   cargoCount: number;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
   userIds: number[] | undefined;
   organizationUnitId: number;

   constructor(data?: IUsersToOrganizationUnitInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['userIds'])) {
            this.userIds = [] as any;
            for (let item of _data['userIds']) this.userIds.push(item);
         }
         this.organizationUnitId = _data['organizationUnitId'];
      }
   }

   static fromJS(data: any): UsersToOrganizationUnitInput {
      data = typeof data === 'object' ? data : {};
      let result = new UsersToOrganizationUnitInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.userIds)) {
         data['userIds'] = [];
         for (let item of this.userIds) data['userIds'].push(item);
      }
      data['organizationUnitId'] = this.organizationUnitId;
      return data;
   }

   clone(): UsersToOrganizationUnitInput {
      const json = this.toJSON();
      let result = new UsersToOrganizationUnitInput();
      result.init(json);
      return result;
   }
}

export interface IUsersToOrganizationUnitInput {
   userIds: number[] | undefined;
   organizationUnitId: number;
}

export enum OrganizationType {
   _0 = 0,
   _1 = 1,
   _2 = 2,
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
   parentId: number | undefined;
   displayName: string;
   organizationType: OrganizationType;

   constructor(data?: ICreateOrganizationUnitInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.parentId = _data['parentId'];
         this.displayName = _data['displayName'];
         this.organizationType = _data['organizationType'];
      }
   }

   static fromJS(data: any): CreateOrganizationUnitInput {
      data = typeof data === 'object' ? data : {};
      let result = new CreateOrganizationUnitInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['parentId'] = this.parentId;
      data['displayName'] = this.displayName;
      data['organizationType'] = this.organizationType;
      return data;
   }

   clone(): CreateOrganizationUnitInput {
      const json = this.toJSON();
      let result = new CreateOrganizationUnitInput();
      result.init(json);
      return result;
   }
}

export interface ICreateOrganizationUnitInput {
   parentId: number | undefined;
   displayName: string;
   organizationType: OrganizationType;
}

/** 组织机构列表Dto */
export class OrganizationUnitListDto implements IOrganizationUnitListDto {
   parentId: number | undefined;
   code: string | undefined;
   displayName: string | undefined;
   organizationType: OrganizationType;
   memberCount: number;
   roleCount: number;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;

   constructor(data?: IOrganizationUnitListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.parentId = _data['parentId'];
         this.code = _data['code'];
         this.displayName = _data['displayName'];
         this.organizationType = _data['organizationType'];
         this.memberCount = _data['memberCount'];
         this.roleCount = _data['roleCount'];
         this.lastModificationTime = _data['lastModificationTime'] ? new Date(_data['lastModificationTime'].toString()) : <any>undefined;
         this.lastModifierUserId = _data['lastModifierUserId'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.creatorUserId = _data['creatorUserId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): OrganizationUnitListDto {
      data = typeof data === 'object' ? data : {};
      let result = new OrganizationUnitListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['parentId'] = this.parentId;
      data['code'] = this.code;
      data['displayName'] = this.displayName;
      data['organizationType'] = this.organizationType;
      data['memberCount'] = this.memberCount;
      data['roleCount'] = this.roleCount;
      data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
      data['lastModifierUserId'] = this.lastModifierUserId;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['creatorUserId'] = this.creatorUserId;
      data['id'] = this.id;
      return data;
   }

   clone(): OrganizationUnitListDto {
      const json = this.toJSON();
      let result = new OrganizationUnitListDto();
      result.init(json);
      return result;
   }
}

/** 组织机构列表Dto */
export interface IOrganizationUnitListDto {
   parentId: number | undefined;
   code: string | undefined;
   displayName: string | undefined;
   organizationType: OrganizationType;
   memberCount: number;
   roleCount: number;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;
}

export class FindUsersInput implements IFindUsersInput {
   organizationUnitId: number;
   maxResultCount: number;
   skipCount: number;
   filterText: string | undefined;

   constructor(data?: IFindUsersInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.organizationUnitId = _data['organizationUnitId'];
         this.maxResultCount = _data['maxResultCount'];
         this.skipCount = _data['skipCount'];
         this.filterText = _data['filterText'];
      }
   }

   static fromJS(data: any): FindUsersInput {
      data = typeof data === 'object' ? data : {};
      let result = new FindUsersInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['organizationUnitId'] = this.organizationUnitId;
      data['maxResultCount'] = this.maxResultCount;
      data['skipCount'] = this.skipCount;
      data['filterText'] = this.filterText;
      return data;
   }

   clone(): FindUsersInput {
      const json = this.toJSON();
      let result = new FindUsersInput();
      result.init(json);
      return result;
   }
}

export interface IFindUsersInput {
   organizationUnitId: number;
   maxResultCount: number;
   skipCount: number;
   filterText: string | undefined;
}

export class OrganizationUnitListDtoListResultDto implements IOrganizationUnitListDtoListResultDto {
   items: OrganizationUnitListDto[] | undefined;

   constructor(data?: IOrganizationUnitListDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(OrganizationUnitListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): OrganizationUnitListDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new OrganizationUnitListDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): OrganizationUnitListDtoListResultDto {
      const json = this.toJSON();
      let result = new OrganizationUnitListDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface IOrganizationUnitListDtoListResultDto {
   items: OrganizationUnitListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
   displayName: string | undefined;
   name: string | undefined;
   addedTime: Date;
   id: number;

   constructor(data?: IOrganizationUnitRoleListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.displayName = _data['displayName'];
         this.name = _data['name'];
         this.addedTime = _data['addedTime'] ? new Date(_data['addedTime'].toString()) : <any>undefined;
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): OrganizationUnitRoleListDto {
      data = typeof data === 'object' ? data : {};
      let result = new OrganizationUnitRoleListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['displayName'] = this.displayName;
      data['name'] = this.name;
      data['addedTime'] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
      data['id'] = this.id;
      return data;
   }

   clone(): OrganizationUnitRoleListDto {
      const json = this.toJSON();
      let result = new OrganizationUnitRoleListDto();
      result.init(json);
      return result;
   }
}

export interface IOrganizationUnitRoleListDto {
   displayName: string | undefined;
   name: string | undefined;
   addedTime: Date;
   id: number;
}

export class OrganizationUnitRoleListDtoPagedResultDto implements IOrganizationUnitRoleListDtoPagedResultDto {
   totalCount: number;
   items: OrganizationUnitRoleListDto[] | undefined;

   constructor(data?: IOrganizationUnitRoleListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(OrganizationUnitRoleListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): OrganizationUnitRoleListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new OrganizationUnitRoleListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): OrganizationUnitRoleListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new OrganizationUnitRoleListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IOrganizationUnitRoleListDtoPagedResultDto {
   totalCount: number;
   items: OrganizationUnitRoleListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
   userName: string | undefined;
   addedTime: Date;
   id: number;

   constructor(data?: IOrganizationUnitUserListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userName = _data['userName'];
         this.addedTime = _data['addedTime'] ? new Date(_data['addedTime'].toString()) : <any>undefined;
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): OrganizationUnitUserListDto {
      data = typeof data === 'object' ? data : {};
      let result = new OrganizationUnitUserListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userName'] = this.userName;
      data['addedTime'] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
      data['id'] = this.id;
      return data;
   }

   clone(): OrganizationUnitUserListDto {
      const json = this.toJSON();
      let result = new OrganizationUnitUserListDto();
      result.init(json);
      return result;
   }
}

export interface IOrganizationUnitUserListDto {
   userName: string | undefined;
   addedTime: Date;
   id: number;
}

export class OrganizationUnitUserListDtoPagedResultDto implements IOrganizationUnitUserListDtoPagedResultDto {
   totalCount: number;
   items: OrganizationUnitUserListDto[] | undefined;

   constructor(data?: IOrganizationUnitUserListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(OrganizationUnitUserListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): OrganizationUnitUserListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new OrganizationUnitUserListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): OrganizationUnitUserListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new OrganizationUnitUserListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IOrganizationUnitUserListDtoPagedResultDto {
   totalCount: number;
   items: OrganizationUnitUserListDto[] | undefined;
}

export class UserToOrganizationUnitInput implements IUserToOrganizationUnitInput {
   userId: number;
   organizationUnitId: number;

   constructor(data?: IUserToOrganizationUnitInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userId = _data['userId'];
         this.organizationUnitId = _data['organizationUnitId'];
      }
   }

   static fromJS(data: any): UserToOrganizationUnitInput {
      data = typeof data === 'object' ? data : {};
      let result = new UserToOrganizationUnitInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userId'] = this.userId;
      data['organizationUnitId'] = this.organizationUnitId;
      return data;
   }

   clone(): UserToOrganizationUnitInput {
      const json = this.toJSON();
      let result = new UserToOrganizationUnitInput();
      result.init(json);
      return result;
   }
}

export interface IUserToOrganizationUnitInput {
   userId: number;
   organizationUnitId: number;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
   id: number;
   newParentId: number | undefined;

   constructor(data?: IMoveOrganizationUnitInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
         this.newParentId = _data['newParentId'];
      }
   }

   static fromJS(data: any): MoveOrganizationUnitInput {
      data = typeof data === 'object' ? data : {};
      let result = new MoveOrganizationUnitInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['newParentId'] = this.newParentId;
      return data;
   }

   clone(): MoveOrganizationUnitInput {
      const json = this.toJSON();
      let result = new MoveOrganizationUnitInput();
      result.init(json);
      return result;
   }
}

export interface IMoveOrganizationUnitInput {
   id: number;
   newParentId: number | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
   id: number;
   displayName: string;
   organizationType: OrganizationType;

   constructor(data?: IUpdateOrganizationUnitInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
         this.displayName = _data['displayName'];
         this.organizationType = _data['organizationType'];
      }
   }

   static fromJS(data: any): UpdateOrganizationUnitInput {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateOrganizationUnitInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['displayName'] = this.displayName;
      data['organizationType'] = this.organizationType;
      return data;
   }

   clone(): UpdateOrganizationUnitInput {
      const json = this.toJSON();
      let result = new UpdateOrganizationUnitInput();
      result.init(json);
      return result;
   }
}

export interface IUpdateOrganizationUnitInput {
   id: number;
   displayName: string;
   organizationType: OrganizationType;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
   level: number;
   parentName: string | undefined;
   name: string | undefined;
   displayName: string | undefined;
   description: string | undefined;
   isGrantedByDefault: boolean;

   constructor(data?: IFlatPermissionWithLevelDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.level = _data['level'];
         this.parentName = _data['parentName'];
         this.name = _data['name'];
         this.displayName = _data['displayName'];
         this.description = _data['description'];
         this.isGrantedByDefault = _data['isGrantedByDefault'];
      }
   }

   static fromJS(data: any): FlatPermissionWithLevelDto {
      data = typeof data === 'object' ? data : {};
      let result = new FlatPermissionWithLevelDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['level'] = this.level;
      data['parentName'] = this.parentName;
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      data['description'] = this.description;
      data['isGrantedByDefault'] = this.isGrantedByDefault;
      return data;
   }

   clone(): FlatPermissionWithLevelDto {
      const json = this.toJSON();
      let result = new FlatPermissionWithLevelDto();
      result.init(json);
      return result;
   }
}

export interface IFlatPermissionWithLevelDto {
   level: number;
   parentName: string | undefined;
   name: string | undefined;
   displayName: string | undefined;
   description: string | undefined;
   isGrantedByDefault: boolean;
}

export class FlatPermissionWithLevelDtoListResultDto implements IFlatPermissionWithLevelDtoListResultDto {
   items: FlatPermissionWithLevelDto[] | undefined;

   constructor(data?: IFlatPermissionWithLevelDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(FlatPermissionWithLevelDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): FlatPermissionWithLevelDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new FlatPermissionWithLevelDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): FlatPermissionWithLevelDtoListResultDto {
      const json = this.toJSON();
      let result = new FlatPermissionWithLevelDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface IFlatPermissionWithLevelDtoListResultDto {
   items: FlatPermissionWithLevelDto[] | undefined;
}

export class TreePermissionDto implements ITreePermissionDto {
   parentName: string | undefined;
   name: string | undefined;
   displayName: string | undefined;
   description: string | undefined;
   children: TreePermissionDto[] | undefined;
   checked: boolean;

   constructor(data?: ITreePermissionDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.parentName = _data['parentName'];
         this.name = _data['name'];
         this.displayName = _data['displayName'];
         this.description = _data['description'];
         if (Array.isArray(_data['children'])) {
            this.children = [] as any;
            for (let item of _data['children']) this.children.push(TreePermissionDto.fromJS(item));
         }
         this.checked = _data['checked'];
      }
   }

   static fromJS(data: any): TreePermissionDto {
      data = typeof data === 'object' ? data : {};
      let result = new TreePermissionDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['parentName'] = this.parentName;
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      data['description'] = this.description;
      if (Array.isArray(this.children)) {
         data['children'] = [];
         for (let item of this.children) data['children'].push(item.toJSON());
      }
      data['checked'] = this.checked;
      return data;
   }

   clone(): TreePermissionDto {
      const json = this.toJSON();
      let result = new TreePermissionDto();
      result.init(json);
      return result;
   }
}

export interface ITreePermissionDto {
   parentName: string | undefined;
   name: string | undefined;
   displayName: string | undefined;
   description: string | undefined;
   children: TreePermissionDto[] | undefined;
   checked: boolean;
}

export class TreePermissionDtoListResultDto implements ITreePermissionDtoListResultDto {
   items: TreePermissionDto[] | undefined;

   constructor(data?: ITreePermissionDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(TreePermissionDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): TreePermissionDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new TreePermissionDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): TreePermissionDtoListResultDto {
      const json = this.toJSON();
      let result = new TreePermissionDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface ITreePermissionDtoListResultDto {
   items: TreePermissionDto[] | undefined;
}

export class CreateProductInput implements ICreateProductInput {
   productName: string;
   price: number;

   constructor(data?: ICreateProductInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.productName = _data['productName'];
         this.price = _data['price'];
      }
   }

   static fromJS(data: any): CreateProductInput {
      data = typeof data === 'object' ? data : {};
      let result = new CreateProductInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['productName'] = this.productName;
      data['price'] = this.price;
      return data;
   }

   clone(): CreateProductInput {
      const json = this.toJSON();
      let result = new CreateProductInput();
      result.init(json);
      return result;
   }
}

export interface ICreateProductInput {
   productName: string;
   price: number;
}

export class IEventData implements IIEventData {
   eventTime: Date;
   eventSource: any | undefined;

   constructor(data?: IIEventData) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.eventTime = _data['eventTime'] ? new Date(_data['eventTime'].toString()) : <any>undefined;
         this.eventSource = _data['eventSource'];
      }
   }

   static fromJS(data: any): IEventData {
      data = typeof data === 'object' ? data : {};
      let result = new IEventData();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['eventTime'] = this.eventTime ? this.eventTime.toISOString() : <any>undefined;
      data['eventSource'] = this.eventSource;
      return data;
   }

   clone(): IEventData {
      const json = this.toJSON();
      let result = new IEventData();
      result.init(json);
      return result;
   }
}

export interface IIEventData {
   eventTime: Date;
   eventSource: any | undefined;
}

export class Product implements IProduct {
   readonly productName: string | undefined;
   rowVersion: string | undefined;
   /** 并发检查时间戳 */
   concurrencyStamp: string | undefined;
   readonly domainEvents: IEventData[] | undefined;
   id: number;

   constructor(data?: IProduct) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         (<any>this).productName = _data['productName'];
         this.rowVersion = _data['rowVersion'];
         this.concurrencyStamp = _data['concurrencyStamp'];
         if (Array.isArray(_data['domainEvents'])) {
            (<any>this).domainEvents = [] as any;
            for (let item of _data['domainEvents']) (<any>this).domainEvents.push(IEventData.fromJS(item));
         }
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): Product {
      data = typeof data === 'object' ? data : {};
      let result = new Product();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['productName'] = this.productName;
      data['rowVersion'] = this.rowVersion;
      data['concurrencyStamp'] = this.concurrencyStamp;
      if (Array.isArray(this.domainEvents)) {
         data['domainEvents'] = [];
         for (let item of this.domainEvents) data['domainEvents'].push(item.toJSON());
      }
      data['id'] = this.id;
      return data;
   }

   clone(): Product {
      const json = this.toJSON();
      let result = new Product();
      result.init(json);
      return result;
   }
}

export interface IProduct {
   productName: string | undefined;
   rowVersion: string | undefined;
   /** 并发检查时间戳 */
   concurrencyStamp: string | undefined;
   domainEvents: IEventData[] | undefined;
   id: number;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
   languageName: string;

   constructor(data?: IChangeUserLanguageDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.languageName = _data['languageName'];
      }
   }

   static fromJS(data: any): ChangeUserLanguageDto {
      data = typeof data === 'object' ? data : {};
      let result = new ChangeUserLanguageDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['languageName'] = this.languageName;
      return data;
   }

   clone(): ChangeUserLanguageDto {
      const json = this.toJSON();
      let result = new ChangeUserLanguageDto();
      result.init(json);
      return result;
   }
}

export interface IChangeUserLanguageDto {
   languageName: string;
}

export class ChangePasswordInput implements IChangePasswordInput {
   currentPassword: string;
   newPassword: string;

   constructor(data?: IChangePasswordInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.currentPassword = _data['currentPassword'];
         this.newPassword = _data['newPassword'];
      }
   }

   static fromJS(data: any): ChangePasswordInput {
      data = typeof data === 'object' ? data : {};
      let result = new ChangePasswordInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['currentPassword'] = this.currentPassword;
      data['newPassword'] = this.newPassword;
      return data;
   }

   clone(): ChangePasswordInput {
      const json = this.toJSON();
      let result = new ChangePasswordInput();
      result.init(json);
      return result;
   }
}

export interface IChangePasswordInput {
   currentPassword: string;
   newPassword: string;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
   userName: string;
   fullName: string | undefined;
   emailAddress: string;
   phoneNumber: string | undefined;
   isPhoneNumberConfirmed: boolean;
   /** 时区 */
   timezone: string | undefined;

   constructor(data?: ICurrentUserProfileEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userName = _data['userName'];
         this.fullName = _data['fullName'];
         this.emailAddress = _data['emailAddress'];
         this.phoneNumber = _data['phoneNumber'];
         this.isPhoneNumberConfirmed = _data['isPhoneNumberConfirmed'];
         this.timezone = _data['timezone'];
      }
   }

   static fromJS(data: any): CurrentUserProfileEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new CurrentUserProfileEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userName'] = this.userName;
      data['fullName'] = this.fullName;
      data['emailAddress'] = this.emailAddress;
      data['phoneNumber'] = this.phoneNumber;
      data['isPhoneNumberConfirmed'] = this.isPhoneNumberConfirmed;
      data['timezone'] = this.timezone;
      return data;
   }

   clone(): CurrentUserProfileEditDto {
      const json = this.toJSON();
      let result = new CurrentUserProfileEditDto();
      result.init(json);
      return result;
   }
}

export interface ICurrentUserProfileEditDto {
   userName: string;
   fullName: string | undefined;
   emailAddress: string;
   phoneNumber: string | undefined;
   isPhoneNumberConfirmed: boolean;
   /** 时区 */
   timezone: string | undefined;
}

export class GetProfilePictureOutputDto implements IGetProfilePictureOutputDto {
   profilePicture: string | undefined;

   constructor(data?: IGetProfilePictureOutputDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.profilePicture = _data['profilePicture'];
      }
   }

   static fromJS(data: any): GetProfilePictureOutputDto {
      data = typeof data === 'object' ? data : {};
      let result = new GetProfilePictureOutputDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['profilePicture'] = this.profilePicture;
      return data;
   }

   clone(): GetProfilePictureOutputDto {
      const json = this.toJSON();
      let result = new GetProfilePictureOutputDto();
      result.init(json);
      return result;
   }
}

export interface IGetProfilePictureOutputDto {
   profilePicture: string | undefined;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
   fileToken: string;
   x: number;
   y: number;
   width: number;
   height: number;

   constructor(data?: IUpdateProfilePictureInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.fileToken = _data['fileToken'];
         this.x = _data['x'];
         this.y = _data['y'];
         this.width = _data['width'];
         this.height = _data['height'];
      }
   }

   static fromJS(data: any): UpdateProfilePictureInput {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateProfilePictureInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['fileToken'] = this.fileToken;
      data['x'] = this.x;
      data['y'] = this.y;
      data['width'] = this.width;
      data['height'] = this.height;
      return data;
   }

   clone(): UpdateProfilePictureInput {
      const json = this.toJSON();
      let result = new UpdateProfilePictureInput();
      result.init(json);
      return result;
   }
}

export interface IUpdateProfilePictureInput {
   fileToken: string;
   x: number;
   y: number;
   width: number;
   height: number;
}

export class RoleEditDto implements IRoleEditDto {
   id: number | undefined;
   displayName: string;
   isDefault: boolean;

   constructor(data?: IRoleEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
         this.displayName = _data['displayName'];
         this.isDefault = _data['isDefault'];
      }
   }

   static fromJS(data: any): RoleEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new RoleEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['displayName'] = this.displayName;
      data['isDefault'] = this.isDefault;
      return data;
   }

   clone(): RoleEditDto {
      const json = this.toJSON();
      let result = new RoleEditDto();
      result.init(json);
      return result;
   }
}

export interface IRoleEditDto {
   id: number | undefined;
   displayName: string;
   isDefault: boolean;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
   role: RoleEditDto;
   grantedPermissionNames: string[];

   constructor(data?: ICreateOrUpdateRoleInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.role = new RoleEditDto();
         this.grantedPermissionNames = [];
      }
   }

   init(_data?: any) {
      if (_data) {
         this.role = _data['role'] ? RoleEditDto.fromJS(_data['role']) : new RoleEditDto();
         if (Array.isArray(_data['grantedPermissionNames'])) {
            this.grantedPermissionNames = [] as any;
            for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames.push(item);
         }
      }
   }

   static fromJS(data: any): CreateOrUpdateRoleInput {
      data = typeof data === 'object' ? data : {};
      let result = new CreateOrUpdateRoleInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['role'] = this.role ? this.role.toJSON() : <any>undefined;
      if (Array.isArray(this.grantedPermissionNames)) {
         data['grantedPermissionNames'] = [];
         for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
      }
      return data;
   }

   clone(): CreateOrUpdateRoleInput {
      const json = this.toJSON();
      let result = new CreateOrUpdateRoleInput();
      result.init(json);
      return result;
   }
}

export interface ICreateOrUpdateRoleInput {
   role: RoleEditDto;
   grantedPermissionNames: string[];
}

export class RoleListDto implements IRoleListDto {
   name: string | undefined;
   displayName: string | undefined;
   isStatic: boolean;
   isDefault: boolean;
   creationTime: Date;
   id: number;

   constructor(data?: IRoleListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.displayName = _data['displayName'];
         this.isStatic = _data['isStatic'];
         this.isDefault = _data['isDefault'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): RoleListDto {
      data = typeof data === 'object' ? data : {};
      let result = new RoleListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      data['isStatic'] = this.isStatic;
      data['isDefault'] = this.isDefault;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['id'] = this.id;
      return data;
   }

   clone(): RoleListDto {
      const json = this.toJSON();
      let result = new RoleListDto();
      result.init(json);
      return result;
   }
}

export interface IRoleListDto {
   name: string | undefined;
   displayName: string | undefined;
   isStatic: boolean;
   isDefault: boolean;
   creationTime: Date;
   id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
   items: RoleListDto[] | undefined;

   constructor(data?: IRoleListDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(RoleListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): RoleListDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new RoleListDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): RoleListDtoListResultDto {
      const json = this.toJSON();
      let result = new RoleListDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface IRoleListDtoListResultDto {
   items: RoleListDto[] | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
   parentName: string | undefined;
   name: string | undefined;
   displayName: string | undefined;
   description: string | undefined;
   isGrantedByDefault: boolean;

   constructor(data?: IFlatPermissionDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.parentName = _data['parentName'];
         this.name = _data['name'];
         this.displayName = _data['displayName'];
         this.description = _data['description'];
         this.isGrantedByDefault = _data['isGrantedByDefault'];
      }
   }

   static fromJS(data: any): FlatPermissionDto {
      data = typeof data === 'object' ? data : {};
      let result = new FlatPermissionDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['parentName'] = this.parentName;
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      data['description'] = this.description;
      data['isGrantedByDefault'] = this.isGrantedByDefault;
      return data;
   }

   clone(): FlatPermissionDto {
      const json = this.toJSON();
      let result = new FlatPermissionDto();
      result.init(json);
      return result;
   }
}

export interface IFlatPermissionDto {
   parentName: string | undefined;
   name: string | undefined;
   displayName: string | undefined;
   description: string | undefined;
   isGrantedByDefault: boolean;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
   role: RoleEditDto;
   permissions: FlatPermissionDto[] | undefined;
   grantedPermissionNames: string[] | undefined;

   constructor(data?: IGetRoleForEditOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.role = _data['role'] ? RoleEditDto.fromJS(_data['role']) : <any>undefined;
         if (Array.isArray(_data['permissions'])) {
            this.permissions = [] as any;
            for (let item of _data['permissions']) this.permissions.push(FlatPermissionDto.fromJS(item));
         }
         if (Array.isArray(_data['grantedPermissionNames'])) {
            this.grantedPermissionNames = [] as any;
            for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames.push(item);
         }
      }
   }

   static fromJS(data: any): GetRoleForEditOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetRoleForEditOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['role'] = this.role ? this.role.toJSON() : <any>undefined;
      if (Array.isArray(this.permissions)) {
         data['permissions'] = [];
         for (let item of this.permissions) data['permissions'].push(item.toJSON());
      }
      if (Array.isArray(this.grantedPermissionNames)) {
         data['grantedPermissionNames'] = [];
         for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
      }
      return data;
   }

   clone(): GetRoleForEditOutput {
      const json = this.toJSON();
      let result = new GetRoleForEditOutput();
      result.init(json);
      return result;
   }
}

export interface IGetRoleForEditOutput {
   role: RoleEditDto;
   permissions: FlatPermissionDto[] | undefined;
   grantedPermissionNames: string[] | undefined;
}

export class RoleListDtoPagedResultDto implements IRoleListDtoPagedResultDto {
   totalCount: number;
   items: RoleListDto[] | undefined;

   constructor(data?: IRoleListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(RoleListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): RoleListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new RoleListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): RoleListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new RoleListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IRoleListDtoPagedResultDto {
   totalCount: number;
   items: RoleListDto[] | undefined;
}

export class UpdateRolePermissionsInput implements IUpdateRolePermissionsInput {
   roleId: number;
   grantedPermissionNames: string[];

   constructor(data?: IUpdateRolePermissionsInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.grantedPermissionNames = [];
      }
   }

   init(_data?: any) {
      if (_data) {
         this.roleId = _data['roleId'];
         if (Array.isArray(_data['grantedPermissionNames'])) {
            this.grantedPermissionNames = [] as any;
            for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames.push(item);
         }
      }
   }

   static fromJS(data: any): UpdateRolePermissionsInput {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateRolePermissionsInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['roleId'] = this.roleId;
      if (Array.isArray(this.grantedPermissionNames)) {
         data['grantedPermissionNames'] = [];
         for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
      }
      return data;
   }

   clone(): UpdateRolePermissionsInput {
      const json = this.toJSON();
      let result = new UpdateRolePermissionsInput();
      result.init(json);
      return result;
   }
}

export interface IUpdateRolePermissionsInput {
   roleId: number;
   grantedPermissionNames: string[];
}

export enum ResetterType {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
}

export enum RulerType {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
}

export enum PaddingSide {
   _0 = 0,
   _1 = 1,
   _2 = 2,
}

export class EditSequenceSettingDto implements IEditSequenceSettingDto {
   /** 规则序号(注意此字段在一个业务编码下需唯一) */
   order: number;
   /** 规则显示名称 */
   name: string;
   rulerTypeId: RulerType;
   /** 规则参数 */
   ruleValue: string | undefined;
   paddingSide: PaddingSide;
   /** 补齐宽度 */
   paddingWidth: number;
   /** 补齐时填充字符 */
   paddingChar: string | undefined;

   constructor(data?: IEditSequenceSettingDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.order = _data['order'];
         this.name = _data['name'];
         this.rulerTypeId = _data['rulerTypeId'];
         this.ruleValue = _data['ruleValue'];
         this.paddingSide = _data['paddingSide'];
         this.paddingWidth = _data['paddingWidth'];
         this.paddingChar = _data['paddingChar'];
      }
   }

   static fromJS(data: any): EditSequenceSettingDto {
      data = typeof data === 'object' ? data : {};
      let result = new EditSequenceSettingDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['order'] = this.order;
      data['name'] = this.name;
      data['rulerTypeId'] = this.rulerTypeId;
      data['ruleValue'] = this.ruleValue;
      data['paddingSide'] = this.paddingSide;
      data['paddingWidth'] = this.paddingWidth;
      data['paddingChar'] = this.paddingChar;
      return data;
   }

   clone(): EditSequenceSettingDto {
      const json = this.toJSON();
      let result = new EditSequenceSettingDto();
      result.init(json);
      return result;
   }
}

export interface IEditSequenceSettingDto {
   /** 规则序号(注意此字段在一个业务编码下需唯一) */
   order: number;
   /** 规则显示名称 */
   name: string;
   rulerTypeId: RulerType;
   /** 规则参数 */
   ruleValue: string | undefined;
   paddingSide: PaddingSide;
   /** 补齐宽度 */
   paddingWidth: number;
   /** 补齐时填充字符 */
   paddingChar: string | undefined;
}

export class CreateOrUpdateSequenceDto implements ICreateOrUpdateSequenceDto {
   /** 唯一编码 */
   uniqueCode: string;
   /** 名称 */
   name: string;
   /** 分割符号 */
   delimiter: string | undefined;
   resetterTypeId: ResetterType;
   /** 步长 */
   step: number;
   /** 规则明细 */
   settings: EditSequenceSettingDto[] | undefined;

   constructor(data?: ICreateOrUpdateSequenceDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.uniqueCode = _data['uniqueCode'];
         this.name = _data['name'];
         this.delimiter = _data['delimiter'];
         this.resetterTypeId = _data['resetterTypeId'];
         this.step = _data['step'];
         if (Array.isArray(_data['settings'])) {
            this.settings = [] as any;
            for (let item of _data['settings']) this.settings.push(EditSequenceSettingDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): CreateOrUpdateSequenceDto {
      data = typeof data === 'object' ? data : {};
      let result = new CreateOrUpdateSequenceDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['uniqueCode'] = this.uniqueCode;
      data['name'] = this.name;
      data['delimiter'] = this.delimiter;
      data['resetterTypeId'] = this.resetterTypeId;
      data['step'] = this.step;
      if (Array.isArray(this.settings)) {
         data['settings'] = [];
         for (let item of this.settings) data['settings'].push(item.toJSON());
      }
      return data;
   }

   clone(): CreateOrUpdateSequenceDto {
      const json = this.toJSON();
      let result = new CreateOrUpdateSequenceDto();
      result.init(json);
      return result;
   }
}

export interface ICreateOrUpdateSequenceDto {
   /** 唯一编码 */
   uniqueCode: string;
   /** 名称 */
   name: string;
   /** 分割符号 */
   delimiter: string | undefined;
   resetterTypeId: ResetterType;
   /** 步长 */
   step: number;
   /** 规则明细 */
   settings: EditSequenceSettingDto[] | undefined;
}

export class SequenceDefinitionListDto implements ISequenceDefinitionListDto {
   /** 显示名称 */
   name: string | undefined;
   /** 分割符号.留白表示无分隔符 */
   delimiter: string | undefined;
   resetterTypeId: ResetterType;
   /** 步长 */
   step: number;
   /** 创建人名称 */
   creatorUserName: string | undefined;
   /** 最后修改人名称 */
   modifierUserName: string | undefined;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: string | undefined;

   constructor(data?: ISequenceDefinitionListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.delimiter = _data['delimiter'];
         this.resetterTypeId = _data['resetterTypeId'];
         this.step = _data['step'];
         this.creatorUserName = _data['creatorUserName'];
         this.modifierUserName = _data['modifierUserName'];
         this.lastModificationTime = _data['lastModificationTime'] ? new Date(_data['lastModificationTime'].toString()) : <any>undefined;
         this.lastModifierUserId = _data['lastModifierUserId'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.creatorUserId = _data['creatorUserId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): SequenceDefinitionListDto {
      data = typeof data === 'object' ? data : {};
      let result = new SequenceDefinitionListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['delimiter'] = this.delimiter;
      data['resetterTypeId'] = this.resetterTypeId;
      data['step'] = this.step;
      data['creatorUserName'] = this.creatorUserName;
      data['modifierUserName'] = this.modifierUserName;
      data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
      data['lastModifierUserId'] = this.lastModifierUserId;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['creatorUserId'] = this.creatorUserId;
      data['id'] = this.id;
      return data;
   }

   clone(): SequenceDefinitionListDto {
      const json = this.toJSON();
      let result = new SequenceDefinitionListDto();
      result.init(json);
      return result;
   }
}

export interface ISequenceDefinitionListDto {
   /** 显示名称 */
   name: string | undefined;
   /** 分割符号.留白表示无分隔符 */
   delimiter: string | undefined;
   resetterTypeId: ResetterType;
   /** 步长 */
   step: number;
   /** 创建人名称 */
   creatorUserName: string | undefined;
   /** 最后修改人名称 */
   modifierUserName: string | undefined;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: string | undefined;
}

export class SequenceDefinitionListDtoPagedResultDto implements ISequenceDefinitionListDtoPagedResultDto {
   totalCount: number;
   items: SequenceDefinitionListDto[] | undefined;

   constructor(data?: ISequenceDefinitionListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(SequenceDefinitionListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): SequenceDefinitionListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new SequenceDefinitionListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): SequenceDefinitionListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new SequenceDefinitionListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface ISequenceDefinitionListDtoPagedResultDto {
   totalCount: number;
   items: SequenceDefinitionListDto[] | undefined;
}

export class UserToken implements IUserToken {
   tenantId: number | undefined;
   userId: number;
   loginProvider: string | undefined;
   name: string | undefined;
   value: string | undefined;
   expireDate: Date | undefined;
   id: number;

   constructor(data?: IUserToken) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.userId = _data['userId'];
         this.loginProvider = _data['loginProvider'];
         this.name = _data['name'];
         this.value = _data['value'];
         this.expireDate = _data['expireDate'] ? new Date(_data['expireDate'].toString()) : <any>undefined;
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): UserToken {
      data = typeof data === 'object' ? data : {};
      let result = new UserToken();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['userId'] = this.userId;
      data['loginProvider'] = this.loginProvider;
      data['name'] = this.name;
      data['value'] = this.value;
      data['expireDate'] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
      data['id'] = this.id;
      return data;
   }

   clone(): UserToken {
      const json = this.toJSON();
      let result = new UserToken();
      result.init(json);
      return result;
   }
}

export interface IUserToken {
   tenantId: number | undefined;
   userId: number;
   loginProvider: string | undefined;
   name: string | undefined;
   value: string | undefined;
   expireDate: Date | undefined;
   id: number;
}

export class UserLogin implements IUserLogin {
   tenantId: number | undefined;
   userId: number;
   loginProvider: string;
   providerKey: string;
   id: number;

   constructor(data?: IUserLogin) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.userId = _data['userId'];
         this.loginProvider = _data['loginProvider'];
         this.providerKey = _data['providerKey'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): UserLogin {
      data = typeof data === 'object' ? data : {};
      let result = new UserLogin();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['userId'] = this.userId;
      data['loginProvider'] = this.loginProvider;
      data['providerKey'] = this.providerKey;
      data['id'] = this.id;
      return data;
   }

   clone(): UserLogin {
      const json = this.toJSON();
      let result = new UserLogin();
      result.init(json);
      return result;
   }
}

export interface IUserLogin {
   tenantId: number | undefined;
   userId: number;
   loginProvider: string;
   providerKey: string;
   id: number;
}

export class UserRole implements IUserRole {
   tenantId: number | undefined;
   userId: number;
   roleId: number;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;

   constructor(data?: IUserRole) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.userId = _data['userId'];
         this.roleId = _data['roleId'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.creatorUserId = _data['creatorUserId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): UserRole {
      data = typeof data === 'object' ? data : {};
      let result = new UserRole();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['userId'] = this.userId;
      data['roleId'] = this.roleId;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['creatorUserId'] = this.creatorUserId;
      data['id'] = this.id;
      return data;
   }

   clone(): UserRole {
      const json = this.toJSON();
      let result = new UserRole();
      result.init(json);
      return result;
   }
}

export interface IUserRole {
   tenantId: number | undefined;
   userId: number;
   roleId: number;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;
}

export class UserClaim implements IUserClaim {
   tenantId: number | undefined;
   userId: number;
   claimType: string | undefined;
   claimValue: string | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;

   constructor(data?: IUserClaim) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.userId = _data['userId'];
         this.claimType = _data['claimType'];
         this.claimValue = _data['claimValue'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.creatorUserId = _data['creatorUserId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): UserClaim {
      data = typeof data === 'object' ? data : {};
      let result = new UserClaim();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['userId'] = this.userId;
      data['claimType'] = this.claimType;
      data['claimValue'] = this.claimValue;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['creatorUserId'] = this.creatorUserId;
      data['id'] = this.id;
      return data;
   }

   clone(): UserClaim {
      const json = this.toJSON();
      let result = new UserClaim();
      result.init(json);
      return result;
   }
}

export interface IUserClaim {
   tenantId: number | undefined;
   userId: number;
   claimType: string | undefined;
   claimValue: string | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
   userId: number;
   tenantId: number | undefined;
   name: string;
   isGranted: boolean;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;

   constructor(data?: IUserPermissionSetting) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userId = _data['userId'];
         this.tenantId = _data['tenantId'];
         this.name = _data['name'];
         this.isGranted = _data['isGranted'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.creatorUserId = _data['creatorUserId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): UserPermissionSetting {
      data = typeof data === 'object' ? data : {};
      let result = new UserPermissionSetting();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userId'] = this.userId;
      data['tenantId'] = this.tenantId;
      data['name'] = this.name;
      data['isGranted'] = this.isGranted;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['creatorUserId'] = this.creatorUserId;
      data['id'] = this.id;
      return data;
   }

   clone(): UserPermissionSetting {
      const json = this.toJSON();
      let result = new UserPermissionSetting();
      result.init(json);
      return result;
   }
}

export interface IUserPermissionSetting {
   userId: number;
   tenantId: number | undefined;
   name: string;
   isGranted: boolean;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;
}

export class Setting implements ISetting {
   tenantId: number | undefined;
   userId: number | undefined;
   name: string;
   value: string | undefined;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;

   constructor(data?: ISetting) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.userId = _data['userId'];
         this.name = _data['name'];
         this.value = _data['value'];
         this.lastModificationTime = _data['lastModificationTime'] ? new Date(_data['lastModificationTime'].toString()) : <any>undefined;
         this.lastModifierUserId = _data['lastModifierUserId'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.creatorUserId = _data['creatorUserId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): Setting {
      data = typeof data === 'object' ? data : {};
      let result = new Setting();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['userId'] = this.userId;
      data['name'] = this.name;
      data['value'] = this.value;
      data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
      data['lastModifierUserId'] = this.lastModifierUserId;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['creatorUserId'] = this.creatorUserId;
      data['id'] = this.id;
      return data;
   }

   clone(): Setting {
      const json = this.toJSON();
      let result = new Setting();
      result.init(json);
      return result;
   }
}

export interface ISetting {
   tenantId: number | undefined;
   userId: number | undefined;
   name: string;
   value: string | undefined;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;
}

export class User implements IUser {
   signInToken: string | undefined;
   /** 需要修改密码 */
   needToChangeThePassword: boolean;
   signInTokenExpireTimeUtc: Date | undefined;
   concurrencyStamp: string | undefined;
   /** 个人头像Id */
   profilePictureId: string | undefined;
   /** 显示名称 */
   displayName: string | undefined;
   normalizedUserName: string;
   normalizedEmailAddress: string;
   tokens: UserToken[] | undefined;
   deleterUser: User;
   creatorUser: User;
   lastModifierUser: User;
   authenticationSource: string | undefined;
   userName: string;
   tenantId: number | undefined;
   emailAddress: string;
   readonly fullName: string | undefined;
   password: string;
   emailConfirmationCode: string | undefined;
   passwordResetCode: string | undefined;
   lockoutEndDateUtc: Date | undefined;
   accessFailedCount: number;
   isLockoutEnabled: boolean;
   phoneNumber: string | undefined;
   isPhoneNumberConfirmed: boolean;
   securityStamp: string | undefined;
   isTwoFactorEnabled: boolean;
   logins: UserLogin[] | undefined;
   roles: UserRole[] | undefined;
   claims: UserClaim[] | undefined;
   permissions: UserPermissionSetting[] | undefined;
   settings: Setting[] | undefined;
   isEmailConfirmed: boolean;
   isActive: boolean;
   isDeleted: boolean;
   deleterUserId: number | undefined;
   deletionTime: Date | undefined;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;

   constructor(data?: IUser) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.signInToken = _data['signInToken'];
         this.needToChangeThePassword = _data['needToChangeThePassword'];
         this.signInTokenExpireTimeUtc = _data['signInTokenExpireTimeUtc'] ? new Date(_data['signInTokenExpireTimeUtc'].toString()) : <any>undefined;
         this.concurrencyStamp = _data['concurrencyStamp'];
         this.profilePictureId = _data['profilePictureId'];
         this.displayName = _data['displayName'];
         this.normalizedUserName = _data['normalizedUserName'];
         this.normalizedEmailAddress = _data['normalizedEmailAddress'];
         if (Array.isArray(_data['tokens'])) {
            this.tokens = [] as any;
            for (let item of _data['tokens']) this.tokens.push(UserToken.fromJS(item));
         }
         this.deleterUser = _data['deleterUser'] ? User.fromJS(_data['deleterUser']) : <any>undefined;
         this.creatorUser = _data['creatorUser'] ? User.fromJS(_data['creatorUser']) : <any>undefined;
         this.lastModifierUser = _data['lastModifierUser'] ? User.fromJS(_data['lastModifierUser']) : <any>undefined;
         this.authenticationSource = _data['authenticationSource'];
         this.userName = _data['userName'];
         this.tenantId = _data['tenantId'];
         this.emailAddress = _data['emailAddress'];
         (<any>this).fullName = _data['fullName'];
         this.password = _data['password'];
         this.emailConfirmationCode = _data['emailConfirmationCode'];
         this.passwordResetCode = _data['passwordResetCode'];
         this.lockoutEndDateUtc = _data['lockoutEndDateUtc'] ? new Date(_data['lockoutEndDateUtc'].toString()) : <any>undefined;
         this.accessFailedCount = _data['accessFailedCount'];
         this.isLockoutEnabled = _data['isLockoutEnabled'];
         this.phoneNumber = _data['phoneNumber'];
         this.isPhoneNumberConfirmed = _data['isPhoneNumberConfirmed'];
         this.securityStamp = _data['securityStamp'];
         this.isTwoFactorEnabled = _data['isTwoFactorEnabled'];
         if (Array.isArray(_data['logins'])) {
            this.logins = [] as any;
            for (let item of _data['logins']) this.logins.push(UserLogin.fromJS(item));
         }
         if (Array.isArray(_data['roles'])) {
            this.roles = [] as any;
            for (let item of _data['roles']) this.roles.push(UserRole.fromJS(item));
         }
         if (Array.isArray(_data['claims'])) {
            this.claims = [] as any;
            for (let item of _data['claims']) this.claims.push(UserClaim.fromJS(item));
         }
         if (Array.isArray(_data['permissions'])) {
            this.permissions = [] as any;
            for (let item of _data['permissions']) this.permissions.push(UserPermissionSetting.fromJS(item));
         }
         if (Array.isArray(_data['settings'])) {
            this.settings = [] as any;
            for (let item of _data['settings']) this.settings.push(Setting.fromJS(item));
         }
         this.isEmailConfirmed = _data['isEmailConfirmed'];
         this.isActive = _data['isActive'];
         this.isDeleted = _data['isDeleted'];
         this.deleterUserId = _data['deleterUserId'];
         this.deletionTime = _data['deletionTime'] ? new Date(_data['deletionTime'].toString()) : <any>undefined;
         this.lastModificationTime = _data['lastModificationTime'] ? new Date(_data['lastModificationTime'].toString()) : <any>undefined;
         this.lastModifierUserId = _data['lastModifierUserId'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.creatorUserId = _data['creatorUserId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): User {
      data = typeof data === 'object' ? data : {};
      let result = new User();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['signInToken'] = this.signInToken;
      data['needToChangeThePassword'] = this.needToChangeThePassword;
      data['signInTokenExpireTimeUtc'] = this.signInTokenExpireTimeUtc ? this.signInTokenExpireTimeUtc.toISOString() : <any>undefined;
      data['concurrencyStamp'] = this.concurrencyStamp;
      data['profilePictureId'] = this.profilePictureId;
      data['displayName'] = this.displayName;
      data['normalizedUserName'] = this.normalizedUserName;
      data['normalizedEmailAddress'] = this.normalizedEmailAddress;
      if (Array.isArray(this.tokens)) {
         data['tokens'] = [];
         for (let item of this.tokens) data['tokens'].push(item.toJSON());
      }
      data['deleterUser'] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
      data['creatorUser'] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
      data['lastModifierUser'] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
      data['authenticationSource'] = this.authenticationSource;
      data['userName'] = this.userName;
      data['tenantId'] = this.tenantId;
      data['emailAddress'] = this.emailAddress;
      data['fullName'] = this.fullName;
      data['password'] = this.password;
      data['emailConfirmationCode'] = this.emailConfirmationCode;
      data['passwordResetCode'] = this.passwordResetCode;
      data['lockoutEndDateUtc'] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
      data['accessFailedCount'] = this.accessFailedCount;
      data['isLockoutEnabled'] = this.isLockoutEnabled;
      data['phoneNumber'] = this.phoneNumber;
      data['isPhoneNumberConfirmed'] = this.isPhoneNumberConfirmed;
      data['securityStamp'] = this.securityStamp;
      data['isTwoFactorEnabled'] = this.isTwoFactorEnabled;
      if (Array.isArray(this.logins)) {
         data['logins'] = [];
         for (let item of this.logins) data['logins'].push(item.toJSON());
      }
      if (Array.isArray(this.roles)) {
         data['roles'] = [];
         for (let item of this.roles) data['roles'].push(item.toJSON());
      }
      if (Array.isArray(this.claims)) {
         data['claims'] = [];
         for (let item of this.claims) data['claims'].push(item.toJSON());
      }
      if (Array.isArray(this.permissions)) {
         data['permissions'] = [];
         for (let item of this.permissions) data['permissions'].push(item.toJSON());
      }
      if (Array.isArray(this.settings)) {
         data['settings'] = [];
         for (let item of this.settings) data['settings'].push(item.toJSON());
      }
      data['isEmailConfirmed'] = this.isEmailConfirmed;
      data['isActive'] = this.isActive;
      data['isDeleted'] = this.isDeleted;
      data['deleterUserId'] = this.deleterUserId;
      data['deletionTime'] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
      data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
      data['lastModifierUserId'] = this.lastModifierUserId;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['creatorUserId'] = this.creatorUserId;
      data['id'] = this.id;
      return data;
   }

   clone(): User {
      const json = this.toJSON();
      let result = new User();
      result.init(json);
      return result;
   }
}

export interface IUser {
   signInToken: string | undefined;
   /** 需要修改密码 */
   needToChangeThePassword: boolean;
   signInTokenExpireTimeUtc: Date | undefined;
   concurrencyStamp: string | undefined;
   /** 个人头像Id */
   profilePictureId: string | undefined;
   /** 显示名称 */
   displayName: string | undefined;
   normalizedUserName: string;
   normalizedEmailAddress: string;
   tokens: UserToken[] | undefined;
   deleterUser: User;
   creatorUser: User;
   lastModifierUser: User;
   authenticationSource: string | undefined;
   userName: string;
   tenantId: number | undefined;
   emailAddress: string;
   fullName: string | undefined;
   password: string;
   emailConfirmationCode: string | undefined;
   passwordResetCode: string | undefined;
   lockoutEndDateUtc: Date | undefined;
   accessFailedCount: number;
   isLockoutEnabled: boolean;
   phoneNumber: string | undefined;
   isPhoneNumberConfirmed: boolean;
   securityStamp: string | undefined;
   isTwoFactorEnabled: boolean;
   logins: UserLogin[] | undefined;
   roles: UserRole[] | undefined;
   claims: UserClaim[] | undefined;
   permissions: UserPermissionSetting[] | undefined;
   settings: Setting[] | undefined;
   isEmailConfirmed: boolean;
   isActive: boolean;
   isDeleted: boolean;
   deleterUserId: number | undefined;
   deletionTime: Date | undefined;
   lastModificationTime: Date | undefined;
   lastModifierUserId: number | undefined;
   creationTime: Date;
   creatorUserId: number | undefined;
   id: number;
}

/** 当前用户信息 */
export class UserLoginInfoDto implements IUserLoginInfoDto {
   name: string | undefined;
   surname: string | undefined;
   userName: string | undefined;
   emailAddress: string | undefined;
   profileImgUrl: string | undefined;
   id: number;

   constructor(data?: IUserLoginInfoDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.surname = _data['surname'];
         this.userName = _data['userName'];
         this.emailAddress = _data['emailAddress'];
         this.profileImgUrl = _data['profileImgUrl'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): UserLoginInfoDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserLoginInfoDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['surname'] = this.surname;
      data['userName'] = this.userName;
      data['emailAddress'] = this.emailAddress;
      data['profileImgUrl'] = this.profileImgUrl;
      data['id'] = this.id;
      return data;
   }

   clone(): UserLoginInfoDto {
      const json = this.toJSON();
      let result = new UserLoginInfoDto();
      result.init(json);
      return result;
   }
}

/** 当前用户信息 */
export interface IUserLoginInfoDto {
   name: string | undefined;
   surname: string | undefined;
   userName: string | undefined;
   emailAddress: string | undefined;
   profileImgUrl: string | undefined;
   id: number;
}

export class EditionInfoDto implements IEditionInfoDto {
   displayName: string | undefined;
   trialDayCount: number | undefined;
   monthlyPrice: number | undefined;
   annualPrice: number | undefined;
   isHighestEdition: boolean;
   isFree: boolean;
   id: number;

   constructor(data?: IEditionInfoDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.displayName = _data['displayName'];
         this.trialDayCount = _data['trialDayCount'];
         this.monthlyPrice = _data['monthlyPrice'];
         this.annualPrice = _data['annualPrice'];
         this.isHighestEdition = _data['isHighestEdition'];
         this.isFree = _data['isFree'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): EditionInfoDto {
      data = typeof data === 'object' ? data : {};
      let result = new EditionInfoDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['displayName'] = this.displayName;
      data['trialDayCount'] = this.trialDayCount;
      data['monthlyPrice'] = this.monthlyPrice;
      data['annualPrice'] = this.annualPrice;
      data['isHighestEdition'] = this.isHighestEdition;
      data['isFree'] = this.isFree;
      data['id'] = this.id;
      return data;
   }

   clone(): EditionInfoDto {
      const json = this.toJSON();
      let result = new EditionInfoDto();
      result.init(json);
      return result;
   }
}

export interface IEditionInfoDto {
   displayName: string | undefined;
   trialDayCount: number | undefined;
   monthlyPrice: number | undefined;
   annualPrice: number | undefined;
   isHighestEdition: boolean;
   isFree: boolean;
   id: number;
}

/** 租户基础信息 */
export class TenantLoginInfoDto implements ITenantLoginInfoDto {
   /** 租户名称 */
   tenancyName: string | undefined;
   name: string | undefined;
   logoId: string | undefined;
   edition: EditionInfoDto;
   creationTime: Date;
   creationTimeString: string | undefined;
   id: number;

   constructor(data?: ITenantLoginInfoDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenancyName = _data['tenancyName'];
         this.name = _data['name'];
         this.logoId = _data['logoId'];
         this.edition = _data['edition'] ? EditionInfoDto.fromJS(_data['edition']) : <any>undefined;
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.creationTimeString = _data['creationTimeString'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): TenantLoginInfoDto {
      data = typeof data === 'object' ? data : {};
      let result = new TenantLoginInfoDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenancyName'] = this.tenancyName;
      data['name'] = this.name;
      data['logoId'] = this.logoId;
      data['edition'] = this.edition ? this.edition.toJSON() : <any>undefined;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['creationTimeString'] = this.creationTimeString;
      data['id'] = this.id;
      return data;
   }

   clone(): TenantLoginInfoDto {
      const json = this.toJSON();
      let result = new TenantLoginInfoDto();
      result.init(json);
      return result;
   }
}

/** 租户基础信息 */
export interface ITenantLoginInfoDto {
   /** 租户名称 */
   tenancyName: string | undefined;
   name: string | undefined;
   logoId: string | undefined;
   edition: EditionInfoDto;
   creationTime: Date;
   creationTimeString: string | undefined;
   id: number;
}

/** 应用程序信息 */
export class ApplicationInfoDto implements IApplicationInfoDto {
   /** 版本 */
   version: string | undefined;
   /** 编译时间 */
   releaseDate: Date;
   /** 包含的特性集合 */
   features: { [key: string]: boolean } | undefined;

   constructor(data?: IApplicationInfoDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.version = _data['version'];
         this.releaseDate = _data['releaseDate'] ? new Date(_data['releaseDate'].toString()) : <any>undefined;
         if (_data['features']) {
            this.features = {} as any;
            for (let key in _data['features']) {
               if (_data['features'].hasOwnProperty(key)) this.features[key] = _data['features'][key];
            }
         }
      }
   }

   static fromJS(data: any): ApplicationInfoDto {
      data = typeof data === 'object' ? data : {};
      let result = new ApplicationInfoDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['version'] = this.version;
      data['releaseDate'] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
      if (this.features) {
         data['features'] = {};
         for (let key in this.features) {
            if (this.features.hasOwnProperty(key)) data['features'][key] = this.features[key];
         }
      }
      return data;
   }

   clone(): ApplicationInfoDto {
      const json = this.toJSON();
      let result = new ApplicationInfoDto();
      result.init(json);
      return result;
   }
}

/** 应用程序信息 */
export interface IApplicationInfoDto {
   /** 版本 */
   version: string | undefined;
   /** 编译时间 */
   releaseDate: Date;
   /** 包含的特性集合 */
   features: { [key: string]: boolean } | undefined;
}

/** 当前登录用户信息 */
export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
   user: UserLoginInfoDto;
   tenant: TenantLoginInfoDto;
   application: ApplicationInfoDto;

   constructor(data?: IGetCurrentLoginInformationsOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.user = _data['user'] ? UserLoginInfoDto.fromJS(_data['user']) : <any>undefined;
         this.tenant = _data['tenant'] ? TenantLoginInfoDto.fromJS(_data['tenant']) : <any>undefined;
         this.application = _data['application'] ? ApplicationInfoDto.fromJS(_data['application']) : <any>undefined;
      }
   }

   static fromJS(data: any): GetCurrentLoginInformationsOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetCurrentLoginInformationsOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['user'] = this.user ? this.user.toJSON() : <any>undefined;
      data['tenant'] = this.tenant ? this.tenant.toJSON() : <any>undefined;
      data['application'] = this.application ? this.application.toJSON() : <any>undefined;
      return data;
   }

   clone(): GetCurrentLoginInformationsOutput {
      const json = this.toJSON();
      let result = new GetCurrentLoginInformationsOutput();
      result.init(json);
      return result;
   }
}

/** 当前登录用户信息 */
export interface IGetCurrentLoginInformationsOutput {
   user: UserLoginInfoDto;
   tenant: TenantLoginInfoDto;
   application: ApplicationInfoDto;
}

export enum MultiTenancySides {
   _1 = 1,
   _2 = 2,
}

export class AbpMultiTenancySidesConfigDto implements IAbpMultiTenancySidesConfigDto {
   host: MultiTenancySides;
   tenant: MultiTenancySides;

   constructor(data?: IAbpMultiTenancySidesConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.host = _data['host'];
         this.tenant = _data['tenant'];
      }
   }

   static fromJS(data: any): AbpMultiTenancySidesConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpMultiTenancySidesConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['host'] = this.host;
      data['tenant'] = this.tenant;
      return data;
   }

   clone(): AbpMultiTenancySidesConfigDto {
      const json = this.toJSON();
      let result = new AbpMultiTenancySidesConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpMultiTenancySidesConfigDto {
   host: MultiTenancySides;
   tenant: MultiTenancySides;
}

export class AbpMultiTenancyConfigDto implements IAbpMultiTenancyConfigDto {
   isEnabled: boolean;
   ignoreFeatureCheckForHostUsers: boolean;
   sides: AbpMultiTenancySidesConfigDto;

   constructor(data?: IAbpMultiTenancyConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.isEnabled = _data['isEnabled'];
         this.ignoreFeatureCheckForHostUsers = _data['ignoreFeatureCheckForHostUsers'];
         this.sides = _data['sides'] ? AbpMultiTenancySidesConfigDto.fromJS(_data['sides']) : <any>undefined;
      }
   }

   static fromJS(data: any): AbpMultiTenancyConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpMultiTenancyConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['isEnabled'] = this.isEnabled;
      data['ignoreFeatureCheckForHostUsers'] = this.ignoreFeatureCheckForHostUsers;
      data['sides'] = this.sides ? this.sides.toJSON() : <any>undefined;
      return data;
   }

   clone(): AbpMultiTenancyConfigDto {
      const json = this.toJSON();
      let result = new AbpMultiTenancyConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpMultiTenancyConfigDto {
   isEnabled: boolean;
   ignoreFeatureCheckForHostUsers: boolean;
   sides: AbpMultiTenancySidesConfigDto;
}

export class AbpUserSessionConfigDto implements IAbpUserSessionConfigDto {
   userId: number | undefined;
   tenantId: number | undefined;
   impersonatorUserId: number | undefined;
   impersonatorTenantId: number | undefined;
   multiTenancySide: MultiTenancySides;

   constructor(data?: IAbpUserSessionConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userId = _data['userId'];
         this.tenantId = _data['tenantId'];
         this.impersonatorUserId = _data['impersonatorUserId'];
         this.impersonatorTenantId = _data['impersonatorTenantId'];
         this.multiTenancySide = _data['multiTenancySide'];
      }
   }

   static fromJS(data: any): AbpUserSessionConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserSessionConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userId'] = this.userId;
      data['tenantId'] = this.tenantId;
      data['impersonatorUserId'] = this.impersonatorUserId;
      data['impersonatorTenantId'] = this.impersonatorTenantId;
      data['multiTenancySide'] = this.multiTenancySide;
      return data;
   }

   clone(): AbpUserSessionConfigDto {
      const json = this.toJSON();
      let result = new AbpUserSessionConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserSessionConfigDto {
   userId: number | undefined;
   tenantId: number | undefined;
   impersonatorUserId: number | undefined;
   impersonatorTenantId: number | undefined;
   multiTenancySide: MultiTenancySides;
}

export class AbpUserCurrentCultureConfigDto implements IAbpUserCurrentCultureConfigDto {
   name: string | undefined;
   displayName: string | undefined;

   constructor(data?: IAbpUserCurrentCultureConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.displayName = _data['displayName'];
      }
   }

   static fromJS(data: any): AbpUserCurrentCultureConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserCurrentCultureConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      return data;
   }

   clone(): AbpUserCurrentCultureConfigDto {
      const json = this.toJSON();
      let result = new AbpUserCurrentCultureConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserCurrentCultureConfigDto {
   name: string | undefined;
   displayName: string | undefined;
}

export class LanguageInfo implements ILanguageInfo {
   name: string | undefined;
   displayName: string | undefined;
   icon: string | undefined;
   isDefault: boolean;
   isDisabled: boolean;
   readonly isRightToLeft: boolean;

   constructor(data?: ILanguageInfo) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.displayName = _data['displayName'];
         this.icon = _data['icon'];
         this.isDefault = _data['isDefault'];
         this.isDisabled = _data['isDisabled'];
         (<any>this).isRightToLeft = _data['isRightToLeft'];
      }
   }

   static fromJS(data: any): LanguageInfo {
      data = typeof data === 'object' ? data : {};
      let result = new LanguageInfo();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      data['icon'] = this.icon;
      data['isDefault'] = this.isDefault;
      data['isDisabled'] = this.isDisabled;
      data['isRightToLeft'] = this.isRightToLeft;
      return data;
   }

   clone(): LanguageInfo {
      const json = this.toJSON();
      let result = new LanguageInfo();
      result.init(json);
      return result;
   }
}

export interface ILanguageInfo {
   name: string | undefined;
   displayName: string | undefined;
   icon: string | undefined;
   isDefault: boolean;
   isDisabled: boolean;
   isRightToLeft: boolean;
}

export class AbpLocalizationSourceDto implements IAbpLocalizationSourceDto {
   name: string | undefined;
   type: string | undefined;

   constructor(data?: IAbpLocalizationSourceDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.type = _data['type'];
      }
   }

   static fromJS(data: any): AbpLocalizationSourceDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpLocalizationSourceDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['type'] = this.type;
      return data;
   }

   clone(): AbpLocalizationSourceDto {
      const json = this.toJSON();
      let result = new AbpLocalizationSourceDto();
      result.init(json);
      return result;
   }
}

export interface IAbpLocalizationSourceDto {
   name: string | undefined;
   type: string | undefined;
}

export class AbpUserLocalizationConfigDto implements IAbpUserLocalizationConfigDto {
   currentCulture: AbpUserCurrentCultureConfigDto;
   languages: LanguageInfo[] | undefined;
   currentLanguage: LanguageInfo;
   sources: AbpLocalizationSourceDto[] | undefined;
   values: { [key: string]: { [key: string]: string } } | undefined;

   constructor(data?: IAbpUserLocalizationConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.currentCulture = _data['currentCulture'] ? AbpUserCurrentCultureConfigDto.fromJS(_data['currentCulture']) : <any>undefined;
         if (Array.isArray(_data['languages'])) {
            this.languages = [] as any;
            for (let item of _data['languages']) this.languages.push(LanguageInfo.fromJS(item));
         }
         this.currentLanguage = _data['currentLanguage'] ? LanguageInfo.fromJS(_data['currentLanguage']) : <any>undefined;
         if (Array.isArray(_data['sources'])) {
            this.sources = [] as any;
            for (let item of _data['sources']) this.sources.push(AbpLocalizationSourceDto.fromJS(item));
         }
         if (_data['values']) {
            this.values = {} as any;
            for (let key in _data['values']) {
               if (_data['values'].hasOwnProperty(key)) this.values[key] = _data['values'][key] !== undefined ? _data['values'][key] : {};
            }
         }
      }
   }

   static fromJS(data: any): AbpUserLocalizationConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserLocalizationConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['currentCulture'] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
      if (Array.isArray(this.languages)) {
         data['languages'] = [];
         for (let item of this.languages) data['languages'].push(item.toJSON());
      }
      data['currentLanguage'] = this.currentLanguage ? this.currentLanguage.toJSON() : <any>undefined;
      if (Array.isArray(this.sources)) {
         data['sources'] = [];
         for (let item of this.sources) data['sources'].push(item.toJSON());
      }
      if (this.values) {
         data['values'] = {};
         for (let key in this.values) {
            if (this.values.hasOwnProperty(key)) data['values'][key] = this.values[key];
         }
      }
      return data;
   }

   clone(): AbpUserLocalizationConfigDto {
      const json = this.toJSON();
      let result = new AbpUserLocalizationConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserLocalizationConfigDto {
   currentCulture: AbpUserCurrentCultureConfigDto;
   languages: LanguageInfo[] | undefined;
   currentLanguage: LanguageInfo;
   sources: AbpLocalizationSourceDto[] | undefined;
   values: { [key: string]: { [key: string]: string } } | undefined;
}

export class AbpStringValueDto implements IAbpStringValueDto {
   value: string | undefined;

   constructor(data?: IAbpStringValueDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.value = _data['value'];
      }
   }

   static fromJS(data: any): AbpStringValueDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpStringValueDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['value'] = this.value;
      return data;
   }

   clone(): AbpStringValueDto {
      const json = this.toJSON();
      let result = new AbpStringValueDto();
      result.init(json);
      return result;
   }
}

export interface IAbpStringValueDto {
   value: string | undefined;
}

export class AbpUserFeatureConfigDto implements IAbpUserFeatureConfigDto {
   allFeatures: { [key: string]: AbpStringValueDto } | undefined;

   constructor(data?: IAbpUserFeatureConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (_data['allFeatures']) {
            this.allFeatures = {} as any;
            for (let key in _data['allFeatures']) {
               if (_data['allFeatures'].hasOwnProperty(key))
                  this.allFeatures[key] = _data['allFeatures'][key] ? AbpStringValueDto.fromJS(_data['allFeatures'][key]) : new AbpStringValueDto();
            }
         }
      }
   }

   static fromJS(data: any): AbpUserFeatureConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserFeatureConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (this.allFeatures) {
         data['allFeatures'] = {};
         for (let key in this.allFeatures) {
            if (this.allFeatures.hasOwnProperty(key))
               data['allFeatures'][key] = this.allFeatures[key] ? this.allFeatures[key].toJSON() : <any>undefined;
         }
      }
      return data;
   }

   clone(): AbpUserFeatureConfigDto {
      const json = this.toJSON();
      let result = new AbpUserFeatureConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserFeatureConfigDto {
   allFeatures: { [key: string]: AbpStringValueDto } | undefined;
}

export class AbpUserAuthConfigDto implements IAbpUserAuthConfigDto {
   allPermissions: { [key: string]: string } | undefined;
   grantedPermissions: { [key: string]: string } | undefined;

   constructor(data?: IAbpUserAuthConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (_data['allPermissions']) {
            this.allPermissions = {} as any;
            for (let key in _data['allPermissions']) {
               if (_data['allPermissions'].hasOwnProperty(key)) this.allPermissions[key] = _data['allPermissions'][key];
            }
         }
         if (_data['grantedPermissions']) {
            this.grantedPermissions = {} as any;
            for (let key in _data['grantedPermissions']) {
               if (_data['grantedPermissions'].hasOwnProperty(key)) this.grantedPermissions[key] = _data['grantedPermissions'][key];
            }
         }
      }
   }

   static fromJS(data: any): AbpUserAuthConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserAuthConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (this.allPermissions) {
         data['allPermissions'] = {};
         for (let key in this.allPermissions) {
            if (this.allPermissions.hasOwnProperty(key)) data['allPermissions'][key] = this.allPermissions[key];
         }
      }
      if (this.grantedPermissions) {
         data['grantedPermissions'] = {};
         for (let key in this.grantedPermissions) {
            if (this.grantedPermissions.hasOwnProperty(key)) data['grantedPermissions'][key] = this.grantedPermissions[key];
         }
      }
      return data;
   }

   clone(): AbpUserAuthConfigDto {
      const json = this.toJSON();
      let result = new AbpUserAuthConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserAuthConfigDto {
   allPermissions: { [key: string]: string } | undefined;
   grantedPermissions: { [key: string]: string } | undefined;
}

export class UserMenuItem implements IUserMenuItem {
   name: string | undefined;
   icon: string | undefined;
   displayName: string | undefined;
   order: number;
   url: string | undefined;
   customData: any | undefined;
   target: string | undefined;
   isEnabled: boolean;
   isVisible: boolean;
   items: UserMenuItem[] | undefined;

   constructor(data?: IUserMenuItem) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.icon = _data['icon'];
         this.displayName = _data['displayName'];
         this.order = _data['order'];
         this.url = _data['url'];
         this.customData = _data['customData'];
         this.target = _data['target'];
         this.isEnabled = _data['isEnabled'];
         this.isVisible = _data['isVisible'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(UserMenuItem.fromJS(item));
         }
      }
   }

   static fromJS(data: any): UserMenuItem {
      data = typeof data === 'object' ? data : {};
      let result = new UserMenuItem();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['icon'] = this.icon;
      data['displayName'] = this.displayName;
      data['order'] = this.order;
      data['url'] = this.url;
      data['customData'] = this.customData;
      data['target'] = this.target;
      data['isEnabled'] = this.isEnabled;
      data['isVisible'] = this.isVisible;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): UserMenuItem {
      const json = this.toJSON();
      let result = new UserMenuItem();
      result.init(json);
      return result;
   }
}

export interface IUserMenuItem {
   name: string | undefined;
   icon: string | undefined;
   displayName: string | undefined;
   order: number;
   url: string | undefined;
   customData: any | undefined;
   target: string | undefined;
   isEnabled: boolean;
   isVisible: boolean;
   items: UserMenuItem[] | undefined;
}

export class UserMenu implements IUserMenu {
   name: string | undefined;
   displayName: string | undefined;
   customData: any | undefined;
   items: UserMenuItem[] | undefined;

   constructor(data?: IUserMenu) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.displayName = _data['displayName'];
         this.customData = _data['customData'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(UserMenuItem.fromJS(item));
         }
      }
   }

   static fromJS(data: any): UserMenu {
      data = typeof data === 'object' ? data : {};
      let result = new UserMenu();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['displayName'] = this.displayName;
      data['customData'] = this.customData;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): UserMenu {
      const json = this.toJSON();
      let result = new UserMenu();
      result.init(json);
      return result;
   }
}

export interface IUserMenu {
   name: string | undefined;
   displayName: string | undefined;
   customData: any | undefined;
   items: UserMenuItem[] | undefined;
}

export class AbpUserNavConfigDto implements IAbpUserNavConfigDto {
   menus: { [key: string]: UserMenu } | undefined;

   constructor(data?: IAbpUserNavConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (_data['menus']) {
            this.menus = {} as any;
            for (let key in _data['menus']) {
               if (_data['menus'].hasOwnProperty(key)) this.menus[key] = _data['menus'][key] ? UserMenu.fromJS(_data['menus'][key]) : new UserMenu();
            }
         }
      }
   }

   static fromJS(data: any): AbpUserNavConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserNavConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (this.menus) {
         data['menus'] = {};
         for (let key in this.menus) {
            if (this.menus.hasOwnProperty(key)) data['menus'][key] = this.menus[key] ? this.menus[key].toJSON() : <any>undefined;
         }
      }
      return data;
   }

   clone(): AbpUserNavConfigDto {
      const json = this.toJSON();
      let result = new AbpUserNavConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserNavConfigDto {
   menus: { [key: string]: UserMenu } | undefined;
}

export class AbpUserSettingConfigDto implements IAbpUserSettingConfigDto {
   values: { [key: string]: string } | undefined;

   constructor(data?: IAbpUserSettingConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (_data['values']) {
            this.values = {} as any;
            for (let key in _data['values']) {
               if (_data['values'].hasOwnProperty(key)) this.values[key] = _data['values'][key];
            }
         }
      }
   }

   static fromJS(data: any): AbpUserSettingConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserSettingConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (this.values) {
         data['values'] = {};
         for (let key in this.values) {
            if (this.values.hasOwnProperty(key)) data['values'][key] = this.values[key];
         }
      }
      return data;
   }

   clone(): AbpUserSettingConfigDto {
      const json = this.toJSON();
      let result = new AbpUserSettingConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserSettingConfigDto {
   values: { [key: string]: string } | undefined;
}

export class AbpUserClockConfigDto implements IAbpUserClockConfigDto {
   provider: string | undefined;

   constructor(data?: IAbpUserClockConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.provider = _data['provider'];
      }
   }

   static fromJS(data: any): AbpUserClockConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserClockConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['provider'] = this.provider;
      return data;
   }

   clone(): AbpUserClockConfigDto {
      const json = this.toJSON();
      let result = new AbpUserClockConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserClockConfigDto {
   provider: string | undefined;
}

export class AbpUserWindowsTimeZoneConfigDto implements IAbpUserWindowsTimeZoneConfigDto {
   timeZoneId: string | undefined;
   baseUtcOffsetInMilliseconds: number;
   currentUtcOffsetInMilliseconds: number;
   isDaylightSavingTimeNow: boolean;

   constructor(data?: IAbpUserWindowsTimeZoneConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.timeZoneId = _data['timeZoneId'];
         this.baseUtcOffsetInMilliseconds = _data['baseUtcOffsetInMilliseconds'];
         this.currentUtcOffsetInMilliseconds = _data['currentUtcOffsetInMilliseconds'];
         this.isDaylightSavingTimeNow = _data['isDaylightSavingTimeNow'];
      }
   }

   static fromJS(data: any): AbpUserWindowsTimeZoneConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserWindowsTimeZoneConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['timeZoneId'] = this.timeZoneId;
      data['baseUtcOffsetInMilliseconds'] = this.baseUtcOffsetInMilliseconds;
      data['currentUtcOffsetInMilliseconds'] = this.currentUtcOffsetInMilliseconds;
      data['isDaylightSavingTimeNow'] = this.isDaylightSavingTimeNow;
      return data;
   }

   clone(): AbpUserWindowsTimeZoneConfigDto {
      const json = this.toJSON();
      let result = new AbpUserWindowsTimeZoneConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserWindowsTimeZoneConfigDto {
   timeZoneId: string | undefined;
   baseUtcOffsetInMilliseconds: number;
   currentUtcOffsetInMilliseconds: number;
   isDaylightSavingTimeNow: boolean;
}

export class AbpUserIanaTimeZoneConfigDto implements IAbpUserIanaTimeZoneConfigDto {
   timeZoneId: string | undefined;

   constructor(data?: IAbpUserIanaTimeZoneConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.timeZoneId = _data['timeZoneId'];
      }
   }

   static fromJS(data: any): AbpUserIanaTimeZoneConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserIanaTimeZoneConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['timeZoneId'] = this.timeZoneId;
      return data;
   }

   clone(): AbpUserIanaTimeZoneConfigDto {
      const json = this.toJSON();
      let result = new AbpUserIanaTimeZoneConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserIanaTimeZoneConfigDto {
   timeZoneId: string | undefined;
}

export class AbpUserTimeZoneConfigDto implements IAbpUserTimeZoneConfigDto {
   windows: AbpUserWindowsTimeZoneConfigDto;
   iana: AbpUserIanaTimeZoneConfigDto;

   constructor(data?: IAbpUserTimeZoneConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.windows = _data['windows'] ? AbpUserWindowsTimeZoneConfigDto.fromJS(_data['windows']) : <any>undefined;
         this.iana = _data['iana'] ? AbpUserIanaTimeZoneConfigDto.fromJS(_data['iana']) : <any>undefined;
      }
   }

   static fromJS(data: any): AbpUserTimeZoneConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserTimeZoneConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['windows'] = this.windows ? this.windows.toJSON() : <any>undefined;
      data['iana'] = this.iana ? this.iana.toJSON() : <any>undefined;
      return data;
   }

   clone(): AbpUserTimeZoneConfigDto {
      const json = this.toJSON();
      let result = new AbpUserTimeZoneConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserTimeZoneConfigDto {
   windows: AbpUserWindowsTimeZoneConfigDto;
   iana: AbpUserIanaTimeZoneConfigDto;
}

export class AbpUserTimingConfigDto implements IAbpUserTimingConfigDto {
   timeZoneInfo: AbpUserTimeZoneConfigDto;

   constructor(data?: IAbpUserTimingConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.timeZoneInfo = _data['timeZoneInfo'] ? AbpUserTimeZoneConfigDto.fromJS(_data['timeZoneInfo']) : <any>undefined;
      }
   }

   static fromJS(data: any): AbpUserTimingConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserTimingConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['timeZoneInfo'] = this.timeZoneInfo ? this.timeZoneInfo.toJSON() : <any>undefined;
      return data;
   }

   clone(): AbpUserTimingConfigDto {
      const json = this.toJSON();
      let result = new AbpUserTimingConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserTimingConfigDto {
   timeZoneInfo: AbpUserTimeZoneConfigDto;
}

export class AbpUserAntiForgeryConfigDto implements IAbpUserAntiForgeryConfigDto {
   tokenCookieName: string | undefined;
   tokenHeaderName: string | undefined;

   constructor(data?: IAbpUserAntiForgeryConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tokenCookieName = _data['tokenCookieName'];
         this.tokenHeaderName = _data['tokenHeaderName'];
      }
   }

   static fromJS(data: any): AbpUserAntiForgeryConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserAntiForgeryConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tokenCookieName'] = this.tokenCookieName;
      data['tokenHeaderName'] = this.tokenHeaderName;
      return data;
   }

   clone(): AbpUserAntiForgeryConfigDto {
      const json = this.toJSON();
      let result = new AbpUserAntiForgeryConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserAntiForgeryConfigDto {
   tokenCookieName: string | undefined;
   tokenHeaderName: string | undefined;
}

export class AbpUserSecurityConfigDto implements IAbpUserSecurityConfigDto {
   antiForgery: AbpUserAntiForgeryConfigDto;

   constructor(data?: IAbpUserSecurityConfigDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.antiForgery = _data['antiForgery'] ? AbpUserAntiForgeryConfigDto.fromJS(_data['antiForgery']) : <any>undefined;
      }
   }

   static fromJS(data: any): AbpUserSecurityConfigDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserSecurityConfigDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['antiForgery'] = this.antiForgery ? this.antiForgery.toJSON() : <any>undefined;
      return data;
   }

   clone(): AbpUserSecurityConfigDto {
      const json = this.toJSON();
      let result = new AbpUserSecurityConfigDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserSecurityConfigDto {
   antiForgery: AbpUserAntiForgeryConfigDto;
}

export class AbpUserConfigurationDto implements IAbpUserConfigurationDto {
   multiTenancy: AbpMultiTenancyConfigDto;
   session: AbpUserSessionConfigDto;
   localization: AbpUserLocalizationConfigDto;
   features: AbpUserFeatureConfigDto;
   auth: AbpUserAuthConfigDto;
   nav: AbpUserNavConfigDto;
   setting: AbpUserSettingConfigDto;
   clock: AbpUserClockConfigDto;
   timing: AbpUserTimingConfigDto;
   security: AbpUserSecurityConfigDto;
   custom: { [key: string]: any } | undefined;

   constructor(data?: IAbpUserConfigurationDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.multiTenancy = _data['multiTenancy'] ? AbpMultiTenancyConfigDto.fromJS(_data['multiTenancy']) : <any>undefined;
         this.session = _data['session'] ? AbpUserSessionConfigDto.fromJS(_data['session']) : <any>undefined;
         this.localization = _data['localization'] ? AbpUserLocalizationConfigDto.fromJS(_data['localization']) : <any>undefined;
         this.features = _data['features'] ? AbpUserFeatureConfigDto.fromJS(_data['features']) : <any>undefined;
         this.auth = _data['auth'] ? AbpUserAuthConfigDto.fromJS(_data['auth']) : <any>undefined;
         this.nav = _data['nav'] ? AbpUserNavConfigDto.fromJS(_data['nav']) : <any>undefined;
         this.setting = _data['setting'] ? AbpUserSettingConfigDto.fromJS(_data['setting']) : <any>undefined;
         this.clock = _data['clock'] ? AbpUserClockConfigDto.fromJS(_data['clock']) : <any>undefined;
         this.timing = _data['timing'] ? AbpUserTimingConfigDto.fromJS(_data['timing']) : <any>undefined;
         this.security = _data['security'] ? AbpUserSecurityConfigDto.fromJS(_data['security']) : <any>undefined;
         if (_data['custom']) {
            this.custom = {} as any;
            for (let key in _data['custom']) {
               if (_data['custom'].hasOwnProperty(key)) this.custom[key] = _data['custom'][key];
            }
         }
      }
   }

   static fromJS(data: any): AbpUserConfigurationDto {
      data = typeof data === 'object' ? data : {};
      let result = new AbpUserConfigurationDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['multiTenancy'] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
      data['session'] = this.session ? this.session.toJSON() : <any>undefined;
      data['localization'] = this.localization ? this.localization.toJSON() : <any>undefined;
      data['features'] = this.features ? this.features.toJSON() : <any>undefined;
      data['auth'] = this.auth ? this.auth.toJSON() : <any>undefined;
      data['nav'] = this.nav ? this.nav.toJSON() : <any>undefined;
      data['setting'] = this.setting ? this.setting.toJSON() : <any>undefined;
      data['clock'] = this.clock ? this.clock.toJSON() : <any>undefined;
      data['timing'] = this.timing ? this.timing.toJSON() : <any>undefined;
      data['security'] = this.security ? this.security.toJSON() : <any>undefined;
      if (this.custom) {
         data['custom'] = {};
         for (let key in this.custom) {
            if (this.custom.hasOwnProperty(key)) data['custom'][key] = this.custom[key];
         }
      }
      return data;
   }

   clone(): AbpUserConfigurationDto {
      const json = this.toJSON();
      let result = new AbpUserConfigurationDto();
      result.init(json);
      return result;
   }
}

export interface IAbpUserConfigurationDto {
   multiTenancy: AbpMultiTenancyConfigDto;
   session: AbpUserSessionConfigDto;
   localization: AbpUserLocalizationConfigDto;
   features: AbpUserFeatureConfigDto;
   auth: AbpUserAuthConfigDto;
   nav: AbpUserNavConfigDto;
   setting: AbpUserSettingConfigDto;
   clock: AbpUserClockConfigDto;
   timing: AbpUserTimingConfigDto;
   security: AbpUserSecurityConfigDto;
   custom: { [key: string]: any } | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
   signInToken: string | undefined;
   encodedUserId: string | undefined;
   encodedTenantId: string | undefined;

   constructor(data?: IUpdateUserSignInTokenOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.signInToken = _data['signInToken'];
         this.encodedUserId = _data['encodedUserId'];
         this.encodedTenantId = _data['encodedTenantId'];
      }
   }

   static fromJS(data: any): UpdateUserSignInTokenOutput {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateUserSignInTokenOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['signInToken'] = this.signInToken;
      data['encodedUserId'] = this.encodedUserId;
      data['encodedTenantId'] = this.encodedTenantId;
      return data;
   }

   clone(): UpdateUserSignInTokenOutput {
      const json = this.toJSON();
      let result = new UpdateUserSignInTokenOutput();
      result.init(json);
      return result;
   }
}

export interface IUpdateUserSignInTokenOutput {
   signInToken: string | undefined;
   encodedUserId: string | undefined;
   encodedTenantId: string | undefined;
}

export class EntityDto implements IEntityDto {
   id: number;

   constructor(data?: IEntityDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): EntityDto {
      data = typeof data === 'object' ? data : {};
      let result = new EntityDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      return data;
   }

   clone(): EntityDto {
      const json = this.toJSON();
      let result = new EntityDto();
      result.init(json);
      return result;
   }
}

export interface IEntityDto {
   id: number;
}

export class CreateTenantInput implements ICreateTenantInput {
   tenancyName: string;
   name: string;
   adminEmailAddress: string;
   adminPassword: string | undefined;
   connectionString: string | undefined;
   shouldChangePasswordOnNextLogin: boolean;
   sendActivationEmail: boolean;
   editionId: number | undefined;
   isActive: boolean;
   subscriptionEndUtc: Date | undefined;
   isInTrialPeriod: boolean;

   constructor(data?: ICreateTenantInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenancyName = _data['tenancyName'];
         this.name = _data['name'];
         this.adminEmailAddress = _data['adminEmailAddress'];
         this.adminPassword = _data['adminPassword'];
         this.connectionString = _data['connectionString'];
         this.shouldChangePasswordOnNextLogin = _data['shouldChangePasswordOnNextLogin'];
         this.sendActivationEmail = _data['sendActivationEmail'];
         this.editionId = _data['editionId'];
         this.isActive = _data['isActive'];
         this.subscriptionEndUtc = _data['subscriptionEndUtc'] ? new Date(_data['subscriptionEndUtc'].toString()) : <any>undefined;
         this.isInTrialPeriod = _data['isInTrialPeriod'];
      }
   }

   static fromJS(data: any): CreateTenantInput {
      data = typeof data === 'object' ? data : {};
      let result = new CreateTenantInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenancyName'] = this.tenancyName;
      data['name'] = this.name;
      data['adminEmailAddress'] = this.adminEmailAddress;
      data['adminPassword'] = this.adminPassword;
      data['connectionString'] = this.connectionString;
      data['shouldChangePasswordOnNextLogin'] = this.shouldChangePasswordOnNextLogin;
      data['sendActivationEmail'] = this.sendActivationEmail;
      data['editionId'] = this.editionId;
      data['isActive'] = this.isActive;
      data['subscriptionEndUtc'] = this.subscriptionEndUtc ? this.subscriptionEndUtc.toISOString() : <any>undefined;
      data['isInTrialPeriod'] = this.isInTrialPeriod;
      return data;
   }

   clone(): CreateTenantInput {
      const json = this.toJSON();
      let result = new CreateTenantInput();
      result.init(json);
      return result;
   }
}

export interface ICreateTenantInput {
   tenancyName: string;
   name: string;
   adminEmailAddress: string;
   adminPassword: string | undefined;
   connectionString: string | undefined;
   shouldChangePasswordOnNextLogin: boolean;
   sendActivationEmail: boolean;
   editionId: number | undefined;
   isActive: boolean;
   subscriptionEndUtc: Date | undefined;
   isInTrialPeriod: boolean;
}

export class TenantEditDto implements ITenantEditDto {
   tenancyName: string;
   name: string;
   connectionString: string | undefined;
   editionId: number | undefined;
   isActive: boolean;
   subscriptionEndUtc: Date | undefined;
   isInTrialPeriod: boolean;
   id: number;

   constructor(data?: ITenantEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenancyName = _data['tenancyName'];
         this.name = _data['name'];
         this.connectionString = _data['connectionString'];
         this.editionId = _data['editionId'];
         this.isActive = _data['isActive'];
         this.subscriptionEndUtc = _data['subscriptionEndUtc'] ? new Date(_data['subscriptionEndUtc'].toString()) : <any>undefined;
         this.isInTrialPeriod = _data['isInTrialPeriod'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): TenantEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new TenantEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenancyName'] = this.tenancyName;
      data['name'] = this.name;
      data['connectionString'] = this.connectionString;
      data['editionId'] = this.editionId;
      data['isActive'] = this.isActive;
      data['subscriptionEndUtc'] = this.subscriptionEndUtc ? this.subscriptionEndUtc.toISOString() : <any>undefined;
      data['isInTrialPeriod'] = this.isInTrialPeriod;
      data['id'] = this.id;
      return data;
   }

   clone(): TenantEditDto {
      const json = this.toJSON();
      let result = new TenantEditDto();
      result.init(json);
      return result;
   }
}

export interface ITenantEditDto {
   tenancyName: string;
   name: string;
   connectionString: string | undefined;
   editionId: number | undefined;
   isActive: boolean;
   subscriptionEndUtc: Date | undefined;
   isInTrialPeriod: boolean;
   id: number;
}

export class TenantListDto implements ITenantListDto {
   tenancyName: string | undefined;
   name: string | undefined;
   editionDisplayName: string | undefined;
   connectionString: string | undefined;
   isActive: boolean;
   creationTime: Date;
   subscriptionEndUtc: Date | undefined;
   editionId: number | undefined;
   id: number;

   constructor(data?: ITenantListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenancyName = _data['tenancyName'];
         this.name = _data['name'];
         this.editionDisplayName = _data['editionDisplayName'];
         this.connectionString = _data['connectionString'];
         this.isActive = _data['isActive'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.subscriptionEndUtc = _data['subscriptionEndUtc'] ? new Date(_data['subscriptionEndUtc'].toString()) : <any>undefined;
         this.editionId = _data['editionId'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): TenantListDto {
      data = typeof data === 'object' ? data : {};
      let result = new TenantListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenancyName'] = this.tenancyName;
      data['name'] = this.name;
      data['editionDisplayName'] = this.editionDisplayName;
      data['connectionString'] = this.connectionString;
      data['isActive'] = this.isActive;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['subscriptionEndUtc'] = this.subscriptionEndUtc ? this.subscriptionEndUtc.toISOString() : <any>undefined;
      data['editionId'] = this.editionId;
      data['id'] = this.id;
      return data;
   }

   clone(): TenantListDto {
      const json = this.toJSON();
      let result = new TenantListDto();
      result.init(json);
      return result;
   }
}

export interface ITenantListDto {
   tenancyName: string | undefined;
   name: string | undefined;
   editionDisplayName: string | undefined;
   connectionString: string | undefined;
   isActive: boolean;
   creationTime: Date;
   subscriptionEndUtc: Date | undefined;
   editionId: number | undefined;
   id: number;
}

export class TenantListDtoPagedResultDto implements ITenantListDtoPagedResultDto {
   totalCount: number;
   items: TenantListDto[] | undefined;

   constructor(data?: ITenantListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(TenantListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): TenantListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new TenantListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): TenantListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new TenantListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface ITenantListDtoPagedResultDto {
   totalCount: number;
   items: TenantListDto[] | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
   featureValues: NameValueDto[] | undefined;
   features: FlatFeatureDto[] | undefined;

   constructor(data?: IGetTenantFeaturesEditOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['featureValues'])) {
            this.featureValues = [] as any;
            for (let item of _data['featureValues']) this.featureValues.push(NameValueDto.fromJS(item));
         }
         if (Array.isArray(_data['features'])) {
            this.features = [] as any;
            for (let item of _data['features']) this.features.push(FlatFeatureDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): GetTenantFeaturesEditOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetTenantFeaturesEditOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.featureValues)) {
         data['featureValues'] = [];
         for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
      }
      if (Array.isArray(this.features)) {
         data['features'] = [];
         for (let item of this.features) data['features'].push(item.toJSON());
      }
      return data;
   }

   clone(): GetTenantFeaturesEditOutput {
      const json = this.toJSON();
      let result = new GetTenantFeaturesEditOutput();
      result.init(json);
      return result;
   }
}

export interface IGetTenantFeaturesEditOutput {
   featureValues: NameValueDto[] | undefined;
   features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
   id: number;
   featureValues: NameValueDto[];

   constructor(data?: IUpdateTenantFeaturesInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.featureValues = [];
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
         if (Array.isArray(_data['featureValues'])) {
            this.featureValues = [] as any;
            for (let item of _data['featureValues']) this.featureValues.push(NameValueDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): UpdateTenantFeaturesInput {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateTenantFeaturesInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      if (Array.isArray(this.featureValues)) {
         data['featureValues'] = [];
         for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
      }
      return data;
   }

   clone(): UpdateTenantFeaturesInput {
      const json = this.toJSON();
      let result = new UpdateTenantFeaturesInput();
      result.init(json);
      return result;
   }
}

export interface IUpdateTenantFeaturesInput {
   id: number;
   featureValues: NameValueDto[];
}

/** 创建租户的DTO信息 */
export class CreateTenantDto implements ICreateTenantDto {
   /** 全局唯一的租户Id */
   tenancyName: string;
   /** 租户名称 */
   name: string;
   userName: string | undefined;
   adminEmailAddress: string;
   connectionString: string | undefined;
   isActive: boolean;
   /** 验证码 */
   verificationCode: string | undefined;
   /** 租户管理员密码 */
   tenantAdminPassword: string | undefined;

   constructor(data?: ICreateTenantDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenancyName = _data['tenancyName'];
         this.name = _data['name'];
         this.userName = _data['userName'];
         this.adminEmailAddress = _data['adminEmailAddress'];
         this.connectionString = _data['connectionString'];
         this.isActive = _data['isActive'];
         this.verificationCode = _data['verificationCode'];
         this.tenantAdminPassword = _data['tenantAdminPassword'];
      }
   }

   static fromJS(data: any): CreateTenantDto {
      data = typeof data === 'object' ? data : {};
      let result = new CreateTenantDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenancyName'] = this.tenancyName;
      data['name'] = this.name;
      data['userName'] = this.userName;
      data['adminEmailAddress'] = this.adminEmailAddress;
      data['connectionString'] = this.connectionString;
      data['isActive'] = this.isActive;
      data['verificationCode'] = this.verificationCode;
      data['tenantAdminPassword'] = this.tenantAdminPassword;
      return data;
   }

   clone(): CreateTenantDto {
      const json = this.toJSON();
      let result = new CreateTenantDto();
      result.init(json);
      return result;
   }
}

/** 创建租户的DTO信息 */
export interface ICreateTenantDto {
   /** 全局唯一的租户Id */
   tenancyName: string;
   /** 租户名称 */
   name: string;
   userName: string | undefined;
   adminEmailAddress: string;
   connectionString: string | undefined;
   isActive: boolean;
   /** 验证码 */
   verificationCode: string | undefined;
   /** 租户管理员密码 */
   tenantAdminPassword: string | undefined;
}

export class RegisterTenantResultDto implements IRegisterTenantResultDto {
   /** 租户Id */
   tenantId: number;
   /** 租户是否激活 */
   isActive: boolean;
   /** 租户启用了用户登陆验证码 */
   useCaptchaOnUserLogin: boolean;

   constructor(data?: IRegisterTenantResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.isActive = _data['isActive'];
         this.useCaptchaOnUserLogin = _data['useCaptchaOnUserLogin'];
      }
   }

   static fromJS(data: any): RegisterTenantResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new RegisterTenantResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['isActive'] = this.isActive;
      data['useCaptchaOnUserLogin'] = this.useCaptchaOnUserLogin;
      return data;
   }

   clone(): RegisterTenantResultDto {
      const json = this.toJSON();
      let result = new RegisterTenantResultDto();
      result.init(json);
      return result;
   }
}

export interface IRegisterTenantResultDto {
   /** 租户Id */
   tenantId: number;
   /** 租户是否激活 */
   isActive: boolean;
   /** 租户启用了用户登陆验证码 */
   useCaptchaOnUserLogin: boolean;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
   /** 是否启用注册 */
   allowSelfRegistration: boolean;
   /** 是否新注册用户默认激活 */
   isNewRegisteredUserActiveByDefault: boolean;
   /** 是否必须校验邮箱才能登陆 */
   isEmailConfirmationRequiredForLogin: boolean;
   /** 是否注册使用验证码 */
   useCaptchaOnUserRegistration: boolean;
   captchaOnUserRegistrationType: ValidateCodeType;
   /** 注册验证码长度 */
   captchaOnUserRegistrationLength: number;
   /** 是否登陆使用验证码 */
   useCaptchaOnUserLogin: boolean;
   captchaOnUserLoginType: ValidateCodeType;
   /** 登陆验证码长度 */
   captchaOnUserLoginLength: number;

   constructor(data?: ITenantUserManagementSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.allowSelfRegistration = _data['allowSelfRegistration'];
         this.isNewRegisteredUserActiveByDefault = _data['isNewRegisteredUserActiveByDefault'];
         this.isEmailConfirmationRequiredForLogin = _data['isEmailConfirmationRequiredForLogin'];
         this.useCaptchaOnUserRegistration = _data['useCaptchaOnUserRegistration'];
         this.captchaOnUserRegistrationType = _data['captchaOnUserRegistrationType'];
         this.captchaOnUserRegistrationLength = _data['captchaOnUserRegistrationLength'];
         this.useCaptchaOnUserLogin = _data['useCaptchaOnUserLogin'];
         this.captchaOnUserLoginType = _data['captchaOnUserLoginType'];
         this.captchaOnUserLoginLength = _data['captchaOnUserLoginLength'];
      }
   }

   static fromJS(data: any): TenantUserManagementSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new TenantUserManagementSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['allowSelfRegistration'] = this.allowSelfRegistration;
      data['isNewRegisteredUserActiveByDefault'] = this.isNewRegisteredUserActiveByDefault;
      data['isEmailConfirmationRequiredForLogin'] = this.isEmailConfirmationRequiredForLogin;
      data['useCaptchaOnUserRegistration'] = this.useCaptchaOnUserRegistration;
      data['captchaOnUserRegistrationType'] = this.captchaOnUserRegistrationType;
      data['captchaOnUserRegistrationLength'] = this.captchaOnUserRegistrationLength;
      data['useCaptchaOnUserLogin'] = this.useCaptchaOnUserLogin;
      data['captchaOnUserLoginType'] = this.captchaOnUserLoginType;
      data['captchaOnUserLoginLength'] = this.captchaOnUserLoginLength;
      return data;
   }

   clone(): TenantUserManagementSettingsEditDto {
      const json = this.toJSON();
      let result = new TenantUserManagementSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface ITenantUserManagementSettingsEditDto {
   /** 是否启用注册 */
   allowSelfRegistration: boolean;
   /** 是否新注册用户默认激活 */
   isNewRegisteredUserActiveByDefault: boolean;
   /** 是否必须校验邮箱才能登陆 */
   isEmailConfirmationRequiredForLogin: boolean;
   /** 是否注册使用验证码 */
   useCaptchaOnUserRegistration: boolean;
   captchaOnUserRegistrationType: ValidateCodeType;
   /** 注册验证码长度 */
   captchaOnUserRegistrationLength: number;
   /** 是否登陆使用验证码 */
   useCaptchaOnUserLogin: boolean;
   captchaOnUserLoginType: ValidateCodeType;
   /** 登陆验证码长度 */
   captchaOnUserLoginLength: number;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
   /** 模块启用 */
   isModuleEnabled: boolean;
   /** 启用 */
   isEnabled: boolean;
   domain: string | undefined;
   /** 用户名 */
   userName: string | undefined;
   /** 密码 */
   password: string | undefined;

   constructor(data?: ILdapSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.isModuleEnabled = _data['isModuleEnabled'];
         this.isEnabled = _data['isEnabled'];
         this.domain = _data['domain'];
         this.userName = _data['userName'];
         this.password = _data['password'];
      }
   }

   static fromJS(data: any): LdapSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new LdapSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['isModuleEnabled'] = this.isModuleEnabled;
      data['isEnabled'] = this.isEnabled;
      data['domain'] = this.domain;
      data['userName'] = this.userName;
      data['password'] = this.password;
      return data;
   }

   clone(): LdapSettingsEditDto {
      const json = this.toJSON();
      let result = new LdapSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface ILdapSettingsEditDto {
   /** 模块启用 */
   isModuleEnabled: boolean;
   /** 启用 */
   isEnabled: boolean;
   domain: string | undefined;
   /** 用户名 */
   userName: string | undefined;
   /** 密码 */
   password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
   legalName: string | undefined;
   address: string | undefined;
   taxVatNo: string | undefined;

   constructor(data?: ITenantBillingSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.legalName = _data['legalName'];
         this.address = _data['address'];
         this.taxVatNo = _data['taxVatNo'];
      }
   }

   static fromJS(data: any): TenantBillingSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new TenantBillingSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['legalName'] = this.legalName;
      data['address'] = this.address;
      data['taxVatNo'] = this.taxVatNo;
      return data;
   }

   clone(): TenantBillingSettingsEditDto {
      const json = this.toJSON();
      let result = new TenantBillingSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface ITenantBillingSettingsEditDto {
   legalName: string | undefined;
   address: string | undefined;
   taxVatNo: string | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
   general: GeneralSettingsEditDto;
   userManagement: TenantUserManagementSettingsEditDto;
   email: EmailSettingsEditDto;
   ldap: LdapSettingsEditDto;
   security: SecuritySettingsEditDto;
   billing: TenantBillingSettingsEditDto;

   constructor(data?: ITenantSettingsEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.userManagement = new TenantUserManagementSettingsEditDto();
         this.security = new SecuritySettingsEditDto();
      }
   }

   init(_data?: any) {
      if (_data) {
         this.general = _data['general'] ? GeneralSettingsEditDto.fromJS(_data['general']) : <any>undefined;
         this.userManagement = _data['userManagement']
            ? TenantUserManagementSettingsEditDto.fromJS(_data['userManagement'])
            : new TenantUserManagementSettingsEditDto();
         this.email = _data['email'] ? EmailSettingsEditDto.fromJS(_data['email']) : <any>undefined;
         this.ldap = _data['ldap'] ? LdapSettingsEditDto.fromJS(_data['ldap']) : <any>undefined;
         this.security = _data['security'] ? SecuritySettingsEditDto.fromJS(_data['security']) : new SecuritySettingsEditDto();
         this.billing = _data['billing'] ? TenantBillingSettingsEditDto.fromJS(_data['billing']) : <any>undefined;
      }
   }

   static fromJS(data: any): TenantSettingsEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new TenantSettingsEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['general'] = this.general ? this.general.toJSON() : <any>undefined;
      data['userManagement'] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
      data['email'] = this.email ? this.email.toJSON() : <any>undefined;
      data['ldap'] = this.ldap ? this.ldap.toJSON() : <any>undefined;
      data['security'] = this.security ? this.security.toJSON() : <any>undefined;
      data['billing'] = this.billing ? this.billing.toJSON() : <any>undefined;
      return data;
   }

   clone(): TenantSettingsEditDto {
      const json = this.toJSON();
      let result = new TenantSettingsEditDto();
      result.init(json);
      return result;
   }
}

export interface ITenantSettingsEditDto {
   general: GeneralSettingsEditDto;
   userManagement: TenantUserManagementSettingsEditDto;
   email: EmailSettingsEditDto;
   ldap: LdapSettingsEditDto;
   security: SecuritySettingsEditDto;
   billing: TenantBillingSettingsEditDto;
}

export enum SettingScopes {
   _1 = 1,
   _2 = 2,
   _4 = 4,
   _7 = 7,
}

export class NameValueDtoListResultDto implements INameValueDtoListResultDto {
   items: NameValueDto[] | undefined;

   constructor(data?: INameValueDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(NameValueDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): NameValueDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new NameValueDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): NameValueDtoListResultDto {
      const json = this.toJSON();
      let result = new NameValueDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface INameValueDtoListResultDto {
   items: NameValueDto[] | undefined;
}

/** 用户信息编辑用Dto */
export class UserEditDto implements IUserEditDto {
   /** 根据id是否有值来判断是创建还是添加 */
   id: number | undefined;
   /** 用户名 */
   userName: string;
   displayName: string;
   /** 用户邮箱 */
   emailAddress: string;
   /** 手机号 */
   phoneNumber: string | undefined;
   /** 密码 */
   password: string | undefined;
   /** 是否锁定 */
   isLockoutEnabled: boolean;
   /** 需要修改密码 */
   needToChangeThePassword: boolean;
   /** 头像Id */
   profilePictureId: string | undefined;
   /** 是否开启二次验证 */
   isTwoFactorEnabled: boolean;
   /** 是否有效 */
   isActive: boolean;

   constructor(data?: IUserEditDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
         this.userName = _data['userName'];
         this.displayName = _data['displayName'];
         this.emailAddress = _data['emailAddress'];
         this.phoneNumber = _data['phoneNumber'];
         this.password = _data['password'];
         this.isLockoutEnabled = _data['isLockoutEnabled'];
         this.needToChangeThePassword = _data['needToChangeThePassword'];
         this.profilePictureId = _data['profilePictureId'];
         this.isTwoFactorEnabled = _data['isTwoFactorEnabled'];
         this.isActive = _data['isActive'];
      }
   }

   static fromJS(data: any): UserEditDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserEditDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['userName'] = this.userName;
      data['displayName'] = this.displayName;
      data['emailAddress'] = this.emailAddress;
      data['phoneNumber'] = this.phoneNumber;
      data['password'] = this.password;
      data['isLockoutEnabled'] = this.isLockoutEnabled;
      data['needToChangeThePassword'] = this.needToChangeThePassword;
      data['profilePictureId'] = this.profilePictureId;
      data['isTwoFactorEnabled'] = this.isTwoFactorEnabled;
      data['isActive'] = this.isActive;
      return data;
   }

   clone(): UserEditDto {
      const json = this.toJSON();
      let result = new UserEditDto();
      result.init(json);
      return result;
   }
}

/** 用户信息编辑用Dto */
export interface IUserEditDto {
   /** 根据id是否有值来判断是创建还是添加 */
   id: number | undefined;
   /** 用户名 */
   userName: string;
   displayName: string;
   /** 用户邮箱 */
   emailAddress: string;
   /** 手机号 */
   phoneNumber: string | undefined;
   /** 密码 */
   password: string | undefined;
   /** 是否锁定 */
   isLockoutEnabled: boolean;
   /** 需要修改密码 */
   needToChangeThePassword: boolean;
   /** 头像Id */
   profilePictureId: string | undefined;
   /** 是否开启二次验证 */
   isTwoFactorEnabled: boolean;
   /** 是否有效 */
   isActive: boolean;
}

/** 用户信息新增和编辑时用Dto */
export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
   user: UserEditDto;
   /** 授权的角色 */
   assignedRoleNames: string[];
   /** 所在的组织机构的ID */
   organizationUnits: number[] | undefined;
   /** 发送激活邮件 */
   sendActivationEmail: boolean;
   /** 设置随机密码 */
   setRandomPassword: boolean;

   constructor(data?: ICreateOrUpdateUserInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.assignedRoleNames = [];
      }
   }

   init(_data?: any) {
      if (_data) {
         this.user = _data['user'] ? UserEditDto.fromJS(_data['user']) : <any>undefined;
         if (Array.isArray(_data['assignedRoleNames'])) {
            this.assignedRoleNames = [] as any;
            for (let item of _data['assignedRoleNames']) this.assignedRoleNames.push(item);
         }
         if (Array.isArray(_data['organizationUnits'])) {
            this.organizationUnits = [] as any;
            for (let item of _data['organizationUnits']) this.organizationUnits.push(item);
         }
         this.sendActivationEmail = _data['sendActivationEmail'];
         this.setRandomPassword = _data['setRandomPassword'];
      }
   }

   static fromJS(data: any): CreateOrUpdateUserInput {
      data = typeof data === 'object' ? data : {};
      let result = new CreateOrUpdateUserInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['user'] = this.user ? this.user.toJSON() : <any>undefined;
      if (Array.isArray(this.assignedRoleNames)) {
         data['assignedRoleNames'] = [];
         for (let item of this.assignedRoleNames) data['assignedRoleNames'].push(item);
      }
      if (Array.isArray(this.organizationUnits)) {
         data['organizationUnits'] = [];
         for (let item of this.organizationUnits) data['organizationUnits'].push(item);
      }
      data['sendActivationEmail'] = this.sendActivationEmail;
      data['setRandomPassword'] = this.setRandomPassword;
      return data;
   }

   clone(): CreateOrUpdateUserInput {
      const json = this.toJSON();
      let result = new CreateOrUpdateUserInput();
      result.init(json);
      return result;
   }
}

/** 用户信息新增和编辑时用Dto */
export interface ICreateOrUpdateUserInput {
   user: UserEditDto;
   /** 授权的角色 */
   assignedRoleNames: string[];
   /** 所在的组织机构的ID */
   organizationUnits: number[] | undefined;
   /** 发送激活邮件 */
   sendActivationEmail: boolean;
   /** 设置随机密码 */
   setRandomPassword: boolean;
}

export class UserRoleDto implements IUserRoleDto {
   roleId: number;
   roleName: string | undefined;
   roleDisplayName: string | undefined;
   isAssigned: boolean;

   constructor(data?: IUserRoleDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.roleId = _data['roleId'];
         this.roleName = _data['roleName'];
         this.roleDisplayName = _data['roleDisplayName'];
         this.isAssigned = _data['isAssigned'];
      }
   }

   static fromJS(data: any): UserRoleDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserRoleDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['roleId'] = this.roleId;
      data['roleName'] = this.roleName;
      data['roleDisplayName'] = this.roleDisplayName;
      data['isAssigned'] = this.isAssigned;
      return data;
   }

   clone(): UserRoleDto {
      const json = this.toJSON();
      let result = new UserRoleDto();
      result.init(json);
      return result;
   }
}

export interface IUserRoleDto {
   roleId: number;
   roleName: string | undefined;
   roleDisplayName: string | undefined;
   isAssigned: boolean;
}

export class GetUserForEditTreeOutput implements IGetUserForEditTreeOutput {
   user: UserEditDto;
   roles: UserRoleDto[] | undefined;
   allOrganizationUnits: OrganizationUnitListDto[] | undefined;
   memberedOrganizationUnits: string[] | undefined;

   constructor(data?: IGetUserForEditTreeOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.user = _data['user'] ? UserEditDto.fromJS(_data['user']) : <any>undefined;
         if (Array.isArray(_data['roles'])) {
            this.roles = [] as any;
            for (let item of _data['roles']) this.roles.push(UserRoleDto.fromJS(item));
         }
         if (Array.isArray(_data['allOrganizationUnits'])) {
            this.allOrganizationUnits = [] as any;
            for (let item of _data['allOrganizationUnits']) this.allOrganizationUnits.push(OrganizationUnitListDto.fromJS(item));
         }
         if (Array.isArray(_data['memberedOrganizationUnits'])) {
            this.memberedOrganizationUnits = [] as any;
            for (let item of _data['memberedOrganizationUnits']) this.memberedOrganizationUnits.push(item);
         }
      }
   }

   static fromJS(data: any): GetUserForEditTreeOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetUserForEditTreeOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['user'] = this.user ? this.user.toJSON() : <any>undefined;
      if (Array.isArray(this.roles)) {
         data['roles'] = [];
         for (let item of this.roles) data['roles'].push(item.toJSON());
      }
      if (Array.isArray(this.allOrganizationUnits)) {
         data['allOrganizationUnits'] = [];
         for (let item of this.allOrganizationUnits) data['allOrganizationUnits'].push(item.toJSON());
      }
      if (Array.isArray(this.memberedOrganizationUnits)) {
         data['memberedOrganizationUnits'] = [];
         for (let item of this.memberedOrganizationUnits) data['memberedOrganizationUnits'].push(item);
      }
      return data;
   }

   clone(): GetUserForEditTreeOutput {
      const json = this.toJSON();
      let result = new GetUserForEditTreeOutput();
      result.init(json);
      return result;
   }
}

export interface IGetUserForEditTreeOutput {
   user: UserEditDto;
   roles: UserRoleDto[] | undefined;
   allOrganizationUnits: OrganizationUnitListDto[] | undefined;
   memberedOrganizationUnits: string[] | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
   roleId: number;
   roleName: string | undefined;

   constructor(data?: IUserListRoleDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.roleId = _data['roleId'];
         this.roleName = _data['roleName'];
      }
   }

   static fromJS(data: any): UserListRoleDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserListRoleDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['roleId'] = this.roleId;
      data['roleName'] = this.roleName;
      return data;
   }

   clone(): UserListRoleDto {
      const json = this.toJSON();
      let result = new UserListRoleDto();
      result.init(json);
      return result;
   }
}

export interface IUserListRoleDto {
   roleId: number;
   roleName: string | undefined;
}

/** 用户信息列表Dto */
export class UserListDto implements IUserListDto {
   /** 用户名 */
   userName: string | undefined;
   /** 姓名 */
   displayName: string | undefined;
   emailAddress: string | undefined;
   phoneNumber: string | undefined;
   isEmailConfirmed: boolean;
   roles: UserListRoleDto[] | undefined;
   /** 角色名拼接 */
   roleNames: string | undefined;
   /** 上次登录时间 */
   lastLoginTime: Date | undefined;
   /** 创建时间 */
   creationTime: Date;
   isActive: boolean;
   id: number;

   constructor(data?: IUserListDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userName = _data['userName'];
         this.displayName = _data['displayName'];
         this.emailAddress = _data['emailAddress'];
         this.phoneNumber = _data['phoneNumber'];
         this.isEmailConfirmed = _data['isEmailConfirmed'];
         if (Array.isArray(_data['roles'])) {
            this.roles = [] as any;
            for (let item of _data['roles']) this.roles.push(UserListRoleDto.fromJS(item));
         }
         this.roleNames = _data['roleNames'];
         this.lastLoginTime = _data['lastLoginTime'] ? new Date(_data['lastLoginTime'].toString()) : <any>undefined;
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
         this.isActive = _data['isActive'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): UserListDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserListDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userName'] = this.userName;
      data['displayName'] = this.displayName;
      data['emailAddress'] = this.emailAddress;
      data['phoneNumber'] = this.phoneNumber;
      data['isEmailConfirmed'] = this.isEmailConfirmed;
      if (Array.isArray(this.roles)) {
         data['roles'] = [];
         for (let item of this.roles) data['roles'].push(item.toJSON());
      }
      data['roleNames'] = this.roleNames;
      data['lastLoginTime'] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data['isActive'] = this.isActive;
      data['id'] = this.id;
      return data;
   }

   clone(): UserListDto {
      const json = this.toJSON();
      let result = new UserListDto();
      result.init(json);
      return result;
   }
}

/** 用户信息列表Dto */
export interface IUserListDto {
   /** 用户名 */
   userName: string | undefined;
   /** 姓名 */
   displayName: string | undefined;
   emailAddress: string | undefined;
   phoneNumber: string | undefined;
   isEmailConfirmed: boolean;
   roles: UserListRoleDto[] | undefined;
   /** 角色名拼接 */
   roleNames: string | undefined;
   /** 上次登录时间 */
   lastLoginTime: Date | undefined;
   /** 创建时间 */
   creationTime: Date;
   isActive: boolean;
   id: number;
}

export class UserListDtoPagedResultDto implements IUserListDtoPagedResultDto {
   totalCount: number;
   items: UserListDto[] | undefined;

   constructor(data?: IUserListDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(UserListDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): UserListDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserListDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): UserListDtoPagedResultDto {
      const json = this.toJSON();
      let result = new UserListDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface IUserListDtoPagedResultDto {
   totalCount: number;
   items: UserListDto[] | undefined;
}

export class GetUserPermissionsTreeForEditOutput implements IGetUserPermissionsTreeForEditOutput {
   permissions: FlatPermissionDto[] | undefined;
   grantedPermissionNames: string[] | undefined;

   constructor(data?: IGetUserPermissionsTreeForEditOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['permissions'])) {
            this.permissions = [] as any;
            for (let item of _data['permissions']) this.permissions.push(FlatPermissionDto.fromJS(item));
         }
         if (Array.isArray(_data['grantedPermissionNames'])) {
            this.grantedPermissionNames = [] as any;
            for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames.push(item);
         }
      }
   }

   static fromJS(data: any): GetUserPermissionsTreeForEditOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetUserPermissionsTreeForEditOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.permissions)) {
         data['permissions'] = [];
         for (let item of this.permissions) data['permissions'].push(item.toJSON());
      }
      if (Array.isArray(this.grantedPermissionNames)) {
         data['grantedPermissionNames'] = [];
         for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
      }
      return data;
   }

   clone(): GetUserPermissionsTreeForEditOutput {
      const json = this.toJSON();
      let result = new GetUserPermissionsTreeForEditOutput();
      result.init(json);
      return result;
   }
}

export interface IGetUserPermissionsTreeForEditOutput {
   permissions: FlatPermissionDto[] | undefined;
   grantedPermissionNames: string[] | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
   profilePictureId: string | undefined;
   user: UserEditDto;
   roles: UserRoleDto[] | undefined;
   allOrganizationUnits: OrganizationUnitListDto[] | undefined;
   memberedOrganizationUnits: string[] | undefined;

   constructor(data?: IGetUserForEditOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.profilePictureId = _data['profilePictureId'];
         this.user = _data['user'] ? UserEditDto.fromJS(_data['user']) : <any>undefined;
         if (Array.isArray(_data['roles'])) {
            this.roles = [] as any;
            for (let item of _data['roles']) this.roles.push(UserRoleDto.fromJS(item));
         }
         if (Array.isArray(_data['allOrganizationUnits'])) {
            this.allOrganizationUnits = [] as any;
            for (let item of _data['allOrganizationUnits']) this.allOrganizationUnits.push(OrganizationUnitListDto.fromJS(item));
         }
         if (Array.isArray(_data['memberedOrganizationUnits'])) {
            this.memberedOrganizationUnits = [] as any;
            for (let item of _data['memberedOrganizationUnits']) this.memberedOrganizationUnits.push(item);
         }
      }
   }

   static fromJS(data: any): GetUserForEditOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetUserForEditOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['profilePictureId'] = this.profilePictureId;
      data['user'] = this.user ? this.user.toJSON() : <any>undefined;
      if (Array.isArray(this.roles)) {
         data['roles'] = [];
         for (let item of this.roles) data['roles'].push(item.toJSON());
      }
      if (Array.isArray(this.allOrganizationUnits)) {
         data['allOrganizationUnits'] = [];
         for (let item of this.allOrganizationUnits) data['allOrganizationUnits'].push(item.toJSON());
      }
      if (Array.isArray(this.memberedOrganizationUnits)) {
         data['memberedOrganizationUnits'] = [];
         for (let item of this.memberedOrganizationUnits) data['memberedOrganizationUnits'].push(item);
      }
      return data;
   }

   clone(): GetUserForEditOutput {
      const json = this.toJSON();
      let result = new GetUserForEditOutput();
      result.init(json);
      return result;
   }
}

export interface IGetUserForEditOutput {
   profilePictureId: string | undefined;
   user: UserEditDto;
   roles: UserRoleDto[] | undefined;
   allOrganizationUnits: OrganizationUnitListDto[] | undefined;
   memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
   /** 所有的权限 */
   permissions: FlatPermissionDto[] | undefined;
   /** 已有权限 */
   grantedPermissionNames: string[] | undefined;

   constructor(data?: IGetUserPermissionsForEditOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['permissions'])) {
            this.permissions = [] as any;
            for (let item of _data['permissions']) this.permissions.push(FlatPermissionDto.fromJS(item));
         }
         if (Array.isArray(_data['grantedPermissionNames'])) {
            this.grantedPermissionNames = [] as any;
            for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames.push(item);
         }
      }
   }

   static fromJS(data: any): GetUserPermissionsForEditOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetUserPermissionsForEditOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.permissions)) {
         data['permissions'] = [];
         for (let item of this.permissions) data['permissions'].push(item.toJSON());
      }
      if (Array.isArray(this.grantedPermissionNames)) {
         data['grantedPermissionNames'] = [];
         for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
      }
      return data;
   }

   clone(): GetUserPermissionsForEditOutput {
      const json = this.toJSON();
      let result = new GetUserPermissionsForEditOutput();
      result.init(json);
      return result;
   }
}

export interface IGetUserPermissionsForEditOutput {
   /** 所有的权限 */
   permissions: FlatPermissionDto[] | undefined;
   /** 已有权限 */
   grantedPermissionNames: string[] | undefined;
}

export class Int64NullableIdDto implements IInt64NullableIdDto {
   id: number | undefined;

   constructor(data?: IInt64NullableIdDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): Int64NullableIdDto {
      data = typeof data === 'object' ? data : {};
      let result = new Int64NullableIdDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      return data;
   }

   clone(): Int64NullableIdDto {
      const json = this.toJSON();
      let result = new Int64NullableIdDto();
      result.init(json);
      return result;
   }
}

export interface IInt64NullableIdDto {
   id: number | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
   id: number;

   constructor(data?: IInt64EntityDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): Int64EntityDto {
      data = typeof data === 'object' ? data : {};
      let result = new Int64EntityDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      return data;
   }

   clone(): Int64EntityDto {
      const json = this.toJSON();
      let result = new Int64EntityDto();
      result.init(json);
      return result;
   }
}

export interface IInt64EntityDto {
   id: number;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
   id: number;
   grantedPermissionNames: string[];

   constructor(data?: IUpdateUserPermissionsInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.grantedPermissionNames = [];
      }
   }

   init(_data?: any) {
      if (_data) {
         this.id = _data['id'];
         if (Array.isArray(_data['grantedPermissionNames'])) {
            this.grantedPermissionNames = [] as any;
            for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames.push(item);
         }
      }
   }

   static fromJS(data: any): UpdateUserPermissionsInput {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateUserPermissionsInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      if (Array.isArray(this.grantedPermissionNames)) {
         data['grantedPermissionNames'] = [];
         for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
      }
      return data;
   }

   clone(): UpdateUserPermissionsInput {
      const json = this.toJSON();
      let result = new UpdateUserPermissionsInput();
      result.init(json);
      return result;
   }
}

export interface IUpdateUserPermissionsInput {
   id: number;
   grantedPermissionNames: string[];
}

export class LinkedUserDto implements ILinkedUserDto {
   tenantId: number | undefined;
   tenancyName: string | undefined;
   username: string | undefined;
   id: number;

   constructor(data?: ILinkedUserDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.tenancyName = _data['tenancyName'];
         this.username = _data['username'];
         this.id = _data['id'];
      }
   }

   static fromJS(data: any): LinkedUserDto {
      data = typeof data === 'object' ? data : {};
      let result = new LinkedUserDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['tenancyName'] = this.tenancyName;
      data['username'] = this.username;
      data['id'] = this.id;
      return data;
   }

   clone(): LinkedUserDto {
      const json = this.toJSON();
      let result = new LinkedUserDto();
      result.init(json);
      return result;
   }
}

export interface ILinkedUserDto {
   tenantId: number | undefined;
   tenancyName: string | undefined;
   username: string | undefined;
   id: number;
}

export class LinkedUserDtoPagedResultDto implements ILinkedUserDtoPagedResultDto {
   totalCount: number;
   items: LinkedUserDto[] | undefined;

   constructor(data?: ILinkedUserDtoPagedResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.totalCount = _data['totalCount'];
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(LinkedUserDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): LinkedUserDtoPagedResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new LinkedUserDtoPagedResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['totalCount'] = this.totalCount;
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): LinkedUserDtoPagedResultDto {
      const json = this.toJSON();
      let result = new LinkedUserDtoPagedResultDto();
      result.init(json);
      return result;
   }
}

export interface ILinkedUserDtoPagedResultDto {
   totalCount: number;
   items: LinkedUserDto[] | undefined;
}

export class LinkedUserDtoListResultDto implements ILinkedUserDtoListResultDto {
   items: LinkedUserDto[] | undefined;

   constructor(data?: ILinkedUserDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(LinkedUserDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): LinkedUserDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new LinkedUserDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): LinkedUserDtoListResultDto {
      const json = this.toJSON();
      let result = new LinkedUserDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface ILinkedUserDtoListResultDto {
   items: LinkedUserDto[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
   tenancyName: string | undefined;
   usernameOrEmailAddress: string;
   password: string;

   constructor(data?: ILinkToUserInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenancyName = _data['tenancyName'];
         this.usernameOrEmailAddress = _data['usernameOrEmailAddress'];
         this.password = _data['password'];
      }
   }

   static fromJS(data: any): LinkToUserInput {
      data = typeof data === 'object' ? data : {};
      let result = new LinkToUserInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenancyName'] = this.tenancyName;
      data['usernameOrEmailAddress'] = this.usernameOrEmailAddress;
      data['password'] = this.password;
      return data;
   }

   clone(): LinkToUserInput {
      const json = this.toJSON();
      let result = new LinkToUserInput();
      result.init(json);
      return result;
   }
}

export interface ILinkToUserInput {
   tenancyName: string | undefined;
   usernameOrEmailAddress: string;
   password: string;
}

export class UnlinkUserInput implements IUnlinkUserInput {
   tenantId: number | undefined;
   userId: number;

   constructor(data?: IUnlinkUserInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenantId = _data['tenantId'];
         this.userId = _data['userId'];
      }
   }

   static fromJS(data: any): UnlinkUserInput {
      data = typeof data === 'object' ? data : {};
      let result = new UnlinkUserInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenantId'] = this.tenantId;
      data['userId'] = this.userId;
      return data;
   }

   clone(): UnlinkUserInput {
      const json = this.toJSON();
      let result = new UnlinkUserInput();
      result.init(json);
      return result;
   }
}

export interface IUnlinkUserInput {
   tenantId: number | undefined;
   userId: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
   tenancyName: string | undefined;
   userNameOrEmailAddress: string | undefined;
   clientIpAddress: string | undefined;
   clientName: string | undefined;
   browserInfo: string | undefined;
   result: string | undefined;
   creationTime: Date;

   constructor(data?: IUserLoginAttemptDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.tenancyName = _data['tenancyName'];
         this.userNameOrEmailAddress = _data['userNameOrEmailAddress'];
         this.clientIpAddress = _data['clientIpAddress'];
         this.clientName = _data['clientName'];
         this.browserInfo = _data['browserInfo'];
         this.result = _data['result'];
         this.creationTime = _data['creationTime'] ? new Date(_data['creationTime'].toString()) : <any>undefined;
      }
   }

   static fromJS(data: any): UserLoginAttemptDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserLoginAttemptDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['tenancyName'] = this.tenancyName;
      data['userNameOrEmailAddress'] = this.userNameOrEmailAddress;
      data['clientIpAddress'] = this.clientIpAddress;
      data['clientName'] = this.clientName;
      data['browserInfo'] = this.browserInfo;
      data['result'] = this.result;
      data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      return data;
   }

   clone(): UserLoginAttemptDto {
      const json = this.toJSON();
      let result = new UserLoginAttemptDto();
      result.init(json);
      return result;
   }
}

export interface IUserLoginAttemptDto {
   tenancyName: string | undefined;
   userNameOrEmailAddress: string | undefined;
   clientIpAddress: string | undefined;
   clientName: string | undefined;
   browserInfo: string | undefined;
   result: string | undefined;
   creationTime: Date;
}

export class UserLoginAttemptDtoListResultDto implements IUserLoginAttemptDtoListResultDto {
   items: UserLoginAttemptDto[] | undefined;

   constructor(data?: IUserLoginAttemptDtoListResultDto) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['items'])) {
            this.items = [] as any;
            for (let item of _data['items']) this.items.push(UserLoginAttemptDto.fromJS(item));
         }
      }
   }

   static fromJS(data: any): UserLoginAttemptDtoListResultDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserLoginAttemptDtoListResultDto();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.items)) {
         data['items'] = [];
         for (let item of this.items) data['items'].push(item.toJSON());
      }
      return data;
   }

   clone(): UserLoginAttemptDtoListResultDto {
      const json = this.toJSON();
      let result = new UserLoginAttemptDtoListResultDto();
      result.init(json);
      return result;
   }
}

export interface IUserLoginAttemptDtoListResultDto {
   items: UserLoginAttemptDto[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
   latestWebLogLines: string[] | undefined;

   constructor(data?: IGetLatestWebLogsOutput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['latestWebLogLines'])) {
            this.latestWebLogLines = [] as any;
            for (let item of _data['latestWebLogLines']) this.latestWebLogLines.push(item);
         }
      }
   }

   static fromJS(data: any): GetLatestWebLogsOutput {
      data = typeof data === 'object' ? data : {};
      let result = new GetLatestWebLogsOutput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.latestWebLogLines)) {
         data['latestWebLogLines'] = [];
         for (let item of this.latestWebLogLines) data['latestWebLogLines'].push(item);
      }
      return data;
   }

   clone(): GetLatestWebLogsOutput {
      const json = this.toJSON();
      let result = new GetLatestWebLogsOutput();
      result.init(json);
      return result;
   }
}

export interface IGetLatestWebLogsOutput {
   latestWebLogLines: string[] | undefined;
}

export class SendTextInput implements ISendTextInput {
   /** 企业应用的id，可在应用的设置页面查看 */
   agentId: number;
   /** 消息内容 */
   content: string | undefined;
   /** User邮箱列表 */
   toUsers: string[] | undefined;
   /** 表示是否是保密消息，0表示否，1表示是，默认0 */
   safe: number;

   constructor(data?: ISendTextInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.agentId = _data['agentId'];
         this.content = _data['content'];
         if (Array.isArray(_data['toUsers'])) {
            this.toUsers = [] as any;
            for (let item of _data['toUsers']) this.toUsers.push(item);
         }
         this.safe = _data['safe'];
      }
   }

   static fromJS(data: any): SendTextInput {
      data = typeof data === 'object' ? data : {};
      let result = new SendTextInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['agentId'] = this.agentId;
      data['content'] = this.content;
      if (Array.isArray(this.toUsers)) {
         data['toUsers'] = [];
         for (let item of this.toUsers) data['toUsers'].push(item);
      }
      data['safe'] = this.safe;
      return data;
   }

   clone(): SendTextInput {
      const json = this.toJSON();
      let result = new SendTextInput();
      result.init(json);
      return result;
   }
}

export interface ISendTextInput {
   /** 企业应用的id，可在应用的设置页面查看 */
   agentId: number;
   /** 消息内容 */
   content: string | undefined;
   /** User邮箱列表 */
   toUsers: string[] | undefined;
   /** 表示是否是保密消息，0表示否，1表示是，默认0 */
   safe: number;
}

export class TestSendTextInput implements ITestSendTextInput {
   /** 邮箱集合 */
   emails: string[];

   constructor(data?: ITestSendTextInput) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
      if (!data) {
         this.emails = [];
      }
   }

   init(_data?: any) {
      if (_data) {
         if (Array.isArray(_data['emails'])) {
            this.emails = [] as any;
            for (let item of _data['emails']) this.emails.push(item);
         }
      }
   }

   static fromJS(data: any): TestSendTextInput {
      data = typeof data === 'object' ? data : {};
      let result = new TestSendTextInput();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.emails)) {
         data['emails'] = [];
         for (let item of this.emails) data['emails'].push(item);
      }
      return data;
   }

   clone(): TestSendTextInput {
      const json = this.toJSON();
      let result = new TestSendTextInput();
      result.init(json);
      return result;
   }
}

export interface ITestSendTextInput {
   /** 邮箱集合 */
   emails: string[];
}

export enum ActivateType {
   _0 = 0,
   _1 = 1,
}

export class ActivateAccountModel implements IActivateAccountModel {
   emailAddress: string;
   password: string;
   userId: string | undefined;
   /** 验证码 */
   verificationCode: string | undefined;
   activateType: ActivateType;

   constructor(data?: IActivateAccountModel) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.emailAddress = _data['emailAddress'];
         this.password = _data['password'];
         this.userId = _data['userId'];
         this.verificationCode = _data['verificationCode'];
         this.activateType = _data['activateType'];
      }
   }

   static fromJS(data: any): ActivateAccountModel {
      data = typeof data === 'object' ? data : {};
      let result = new ActivateAccountModel();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['emailAddress'] = this.emailAddress;
      data['password'] = this.password;
      data['userId'] = this.userId;
      data['verificationCode'] = this.verificationCode;
      data['activateType'] = this.activateType;
      return data;
   }

   clone(): ActivateAccountModel {
      const json = this.toJSON();
      let result = new ActivateAccountModel();
      result.init(json);
      return result;
   }
}

export interface IActivateAccountModel {
   emailAddress: string;
   password: string;
   userId: string | undefined;
   /** 验证码 */
   verificationCode: string | undefined;
   activateType: ActivateType;
}

export class ActivateAccountResultModel implements IActivateAccountResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;
   userId: number;

   constructor(data?: IActivateAccountResultModel) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.accessToken = _data['accessToken'];
         this.encryptedAccessToken = _data['encryptedAccessToken'];
         this.expireInSeconds = _data['expireInSeconds'];
         this.userId = _data['userId'];
      }
   }

   static fromJS(data: any): ActivateAccountResultModel {
      data = typeof data === 'object' ? data : {};
      let result = new ActivateAccountResultModel();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['accessToken'] = this.accessToken;
      data['encryptedAccessToken'] = this.encryptedAccessToken;
      data['expireInSeconds'] = this.expireInSeconds;
      data['userId'] = this.userId;
      return data;
   }

   clone(): ActivateAccountResultModel {
      const json = this.toJSON();
      let result = new ActivateAccountResultModel();
      result.init(json);
      return result;
   }
}

export interface IActivateAccountResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;
   userId: number;
}

export class AuthenticateModel implements IAuthenticateModel {
   userNameOrEmailAddress: string;
   password: string;
   /** 验证码 */
   verificationCode: string | undefined;
   rememberClient: boolean;
   returnUrl: string | undefined;

   constructor(data?: IAuthenticateModel) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.userNameOrEmailAddress = _data['userNameOrEmailAddress'];
         this.password = _data['password'];
         this.verificationCode = _data['verificationCode'];
         this.rememberClient = _data['rememberClient'];
         this.returnUrl = _data['returnUrl'];
      }
   }

   static fromJS(data: any): AuthenticateModel {
      data = typeof data === 'object' ? data : {};
      let result = new AuthenticateModel();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userNameOrEmailAddress'] = this.userNameOrEmailAddress;
      data['password'] = this.password;
      data['verificationCode'] = this.verificationCode;
      data['rememberClient'] = this.rememberClient;
      data['returnUrl'] = this.returnUrl;
      return data;
   }

   clone(): AuthenticateModel {
      const json = this.toJSON();
      let result = new AuthenticateModel();
      result.init(json);
      return result;
   }
}

export interface IAuthenticateModel {
   userNameOrEmailAddress: string;
   password: string;
   /** 验证码 */
   verificationCode: string | undefined;
   rememberClient: boolean;
   returnUrl: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;
   userId: number;
   shouldResetPassword: boolean;
   passwordResetCode: string | undefined;
   returnUrl: string | undefined;
   /** 等待激活 */
   waitingForActivation: boolean;

   constructor(data?: IAuthenticateResultModel) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.accessToken = _data['accessToken'];
         this.encryptedAccessToken = _data['encryptedAccessToken'];
         this.expireInSeconds = _data['expireInSeconds'];
         this.userId = _data['userId'];
         this.shouldResetPassword = _data['shouldResetPassword'];
         this.passwordResetCode = _data['passwordResetCode'];
         this.returnUrl = _data['returnUrl'];
         this.waitingForActivation = _data['waitingForActivation'];
      }
   }

   static fromJS(data: any): AuthenticateResultModel {
      data = typeof data === 'object' ? data : {};
      let result = new AuthenticateResultModel();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['accessToken'] = this.accessToken;
      data['encryptedAccessToken'] = this.encryptedAccessToken;
      data['expireInSeconds'] = this.expireInSeconds;
      data['userId'] = this.userId;
      data['shouldResetPassword'] = this.shouldResetPassword;
      data['passwordResetCode'] = this.passwordResetCode;
      data['returnUrl'] = this.returnUrl;
      data['waitingForActivation'] = this.waitingForActivation;
      return data;
   }

   clone(): AuthenticateResultModel {
      const json = this.toJSON();
      let result = new AuthenticateResultModel();
      result.init(json);
      return result;
   }
}

export interface IAuthenticateResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;
   userId: number;
   shouldResetPassword: boolean;
   passwordResetCode: string | undefined;
   returnUrl: string | undefined;
   /** 等待激活 */
   waitingForActivation: boolean;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
   authProvider: string;
   providerKey: string;
   providerAccessCode: string;

   constructor(data?: IExternalAuthenticateModel) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.authProvider = _data['authProvider'];
         this.providerKey = _data['providerKey'];
         this.providerAccessCode = _data['providerAccessCode'];
      }
   }

   static fromJS(data: any): ExternalAuthenticateModel {
      data = typeof data === 'object' ? data : {};
      let result = new ExternalAuthenticateModel();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['authProvider'] = this.authProvider;
      data['providerKey'] = this.providerKey;
      data['providerAccessCode'] = this.providerAccessCode;
      return data;
   }

   clone(): ExternalAuthenticateModel {
      const json = this.toJSON();
      let result = new ExternalAuthenticateModel();
      result.init(json);
      return result;
   }
}

export interface IExternalAuthenticateModel {
   authProvider: string;
   providerKey: string;
   providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;
   waitingForActivation: boolean;
   userId: number;

   constructor(data?: IExternalAuthenticateResultModel) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.accessToken = _data['accessToken'];
         this.encryptedAccessToken = _data['encryptedAccessToken'];
         this.expireInSeconds = _data['expireInSeconds'];
         this.waitingForActivation = _data['waitingForActivation'];
         this.userId = _data['userId'];
      }
   }

   static fromJS(data: any): ExternalAuthenticateResultModel {
      data = typeof data === 'object' ? data : {};
      let result = new ExternalAuthenticateResultModel();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['accessToken'] = this.accessToken;
      data['encryptedAccessToken'] = this.encryptedAccessToken;
      data['expireInSeconds'] = this.expireInSeconds;
      data['waitingForActivation'] = this.waitingForActivation;
      data['userId'] = this.userId;
      return data;
   }

   clone(): ExternalAuthenticateResultModel {
      const json = this.toJSON();
      let result = new ExternalAuthenticateResultModel();
      result.init(json);
      return result;
   }
}

export interface IExternalAuthenticateResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;
   waitingForActivation: boolean;
   userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
   name: string | undefined;
   clientId: string | undefined;
   additionalParams: { [key: string]: string } | undefined;

   constructor(data?: IExternalLoginProviderInfoModel) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.name = _data['name'];
         this.clientId = _data['clientId'];
         if (_data['additionalParams']) {
            this.additionalParams = {} as any;
            for (let key in _data['additionalParams']) {
               if (_data['additionalParams'].hasOwnProperty(key)) this.additionalParams[key] = _data['additionalParams'][key];
            }
         }
      }
   }

   static fromJS(data: any): ExternalLoginProviderInfoModel {
      data = typeof data === 'object' ? data : {};
      let result = new ExternalLoginProviderInfoModel();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['name'] = this.name;
      data['clientId'] = this.clientId;
      if (this.additionalParams) {
         data['additionalParams'] = {};
         for (let key in this.additionalParams) {
            if (this.additionalParams.hasOwnProperty(key)) data['additionalParams'][key] = this.additionalParams[key];
         }
      }
      return data;
   }

   clone(): ExternalLoginProviderInfoModel {
      const json = this.toJSON();
      let result = new ExternalLoginProviderInfoModel();
      result.init(json);
      return result;
   }
}

export interface IExternalLoginProviderInfoModel {
   name: string | undefined;
   clientId: string | undefined;
   additionalParams: { [key: string]: string } | undefined;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;

   constructor(data?: IImpersonatedAuthenticateResultModel) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.accessToken = _data['accessToken'];
         this.encryptedAccessToken = _data['encryptedAccessToken'];
         this.expireInSeconds = _data['expireInSeconds'];
      }
   }

   static fromJS(data: any): ImpersonatedAuthenticateResultModel {
      data = typeof data === 'object' ? data : {};
      let result = new ImpersonatedAuthenticateResultModel();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['accessToken'] = this.accessToken;
      data['encryptedAccessToken'] = this.encryptedAccessToken;
      data['expireInSeconds'] = this.expireInSeconds;
      return data;
   }

   clone(): ImpersonatedAuthenticateResultModel {
      const json = this.toJSON();
      let result = new ImpersonatedAuthenticateResultModel();
      result.init(json);
      return result;
   }
}

export interface IImpersonatedAuthenticateResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;

   constructor(data?: ISwitchedAccountAuthenticateResultModel) {
      if (data) {
         for (var property in data) {
            if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
         }
      }
   }

   init(_data?: any) {
      if (_data) {
         this.accessToken = _data['accessToken'];
         this.encryptedAccessToken = _data['encryptedAccessToken'];
         this.expireInSeconds = _data['expireInSeconds'];
      }
   }

   static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
      data = typeof data === 'object' ? data : {};
      let result = new SwitchedAccountAuthenticateResultModel();
      result.init(data);
      return result;
   }

   toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['accessToken'] = this.accessToken;
      data['encryptedAccessToken'] = this.encryptedAccessToken;
      data['expireInSeconds'] = this.expireInSeconds;
      return data;
   }

   clone(): SwitchedAccountAuthenticateResultModel {
      const json = this.toJSON();
      let result = new SwitchedAccountAuthenticateResultModel();
      result.init(json);
      return result;
   }
}

export interface ISwitchedAccountAuthenticateResultModel {
   accessToken: string | undefined;
   encryptedAccessToken: string | undefined;
   expireInSeconds: number;
}

/** 验证码类型 */
export enum CaptchaType {
   _0 = 0,
   _1 = 1,
   _2 = 2,
   _3 = 3,
   _4 = 4,
}

export class ApiException extends Error {
   message: string;
   status: number;
   response: string;
   headers: { [key: string]: any };
   result: any;

   constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
      super();

      this.message = message;
      this.status = status;
      this.response = response;
      this.headers = headers;
      this.result = result;
   }

   protected isApiException = true;

   static isApiException(obj: any): obj is ApiException {
      return obj.isApiException === true;
   }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): Observable<any> {
   if (result !== null && result !== undefined) return _observableThrow(result);
   else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
   return new Observable<string>((observer: any) => {
      if (!blob) {
         observer.next('');
         observer.complete();
      } else {
         let reader = new FileReader();
         reader.onload = (event) => {
            observer.next((<any>event.target).result);
            observer.complete();
         };
         reader.readAsText(blob);
      }
   });
}
